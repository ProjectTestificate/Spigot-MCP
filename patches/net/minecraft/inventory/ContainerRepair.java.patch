--- decompiled\net\minecraft\inventory\ContainerRepair.java
+++ src\main\java\net\minecraft\inventory\ContainerRepair.java
@@ -1,9 +1,12 @@
 package net.minecraft.inventory;
 
+import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Map;
+
 import net.minecraft.block.BlockAnvil;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.enchantment.Enchantment;
 import net.minecraft.enchantment.EnchantmentHelper;
 import net.minecraft.entity.player.EntityPlayer;
@@ -11,144 +14,172 @@
 import net.minecraft.init.Blocks;
 import net.minecraft.init.Items;
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.BlockPos;
 import net.minecraft.world.World;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
+
 import org.apache.commons.lang3.StringUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.inventory.CraftInventory;
+import org.bukkit.craftbukkit.inventory.CraftInventoryAnvil;
+import org.bukkit.craftbukkit.inventory.CraftInventoryView;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.InventoryHolder;
 
-public class ContainerRepair extends Container
-{
+public class ContainerRepair extends Container {
+
     private static final Logger logger = LogManager.getLogger();
     private IInventory outputSlot;
     private IInventory inputSlots;
     private World theWorld;
     private BlockPos selfPosition;
     public int maximumCost;
-    private int materialCost;
+    public int materialCost;
     private String repairedItemName;
     private final EntityPlayer thePlayer;
+    // CraftBukkit start
+    private CraftInventoryView bukkitEntity = null;
+    private InventoryPlayer player;
+    // CraftBukkit end
     private static final String __OBFID = "CL_00001732";
 
-    @SideOnly(Side.CLIENT)
-    public ContainerRepair(InventoryPlayer playerInventory, World worldIn, EntityPlayer player)
-    {
-        this(playerInventory, worldIn, BlockPos.ORIGIN, player);
+    // SpigotMCP -- Annonomous inner class ContainerRepair$1 -> ContainerAnvilInventory
+    public class ContainerAnvilInventory extends InventoryBasic {
+
+        private static final String __OBFID = "CL_00001733";
+
+        // CraftBukkit start
+        public List transaction = new ArrayList();
+        public Player player;
+        private int maxStack = MAX_STACK;
+
+        public ItemStack[] getContents() {
+            return this.inventoryContents;
+        }
+
+        public void onOpen(CraftHumanEntity who) {
+            transaction.add(who);
+        }
+
+        public void onClose(CraftHumanEntity who) {
+            transaction.remove(who);
+        }
+
+        public List getViewers() {
+            return transaction;
+        }
+
+        public InventoryHolder getOwner() {
+            return this.player;
+        }
+
+        public void setMaxStackSize(int size) {
+            maxStack = size;
+        }
+        // CraftBukkit end
+
+        public ContainerAnvilInventory(String title, boolean customName, int slotCount) {
+            super(title, customName, slotCount);
+        }
+
+        public void markDirty() {
+            super.markDirty();
+            ContainerRepair.this.onCraftMatrixChanged(this);
+        }
+
+        // CraftBukkit start - override inherited maxStack from InventorySubcontainer
+        @Override
+        public int getInventoryStackLimit() {
+            return maxStack;
+        }
+        // CraftBukkit end
     }
 
-    public ContainerRepair(InventoryPlayer playerInventory, final World worldIn, final BlockPos blockPosIn, EntityPlayer player)
-    {
+    public ContainerRepair(InventoryPlayer playerInventory, final World worldIn, final BlockPos blockPosIn, EntityPlayer player) {
         this.outputSlot = new InventoryCraftResult();
-        this.inputSlots = new InventoryBasic("Repair", true, 2)
-        {
-            private static final String __OBFID = "CL_00001733";
-            public void markDirty()
-            {
-                super.markDirty();
-                ContainerRepair.this.onCraftMatrixChanged(this);
-            }
-        };
+        this.inputSlots = new ContainerAnvilInventory("Repair", true, 2); // SpigotMCP -- Use inner class
+        this.player = playerInventory; // CraftBukkit
         this.selfPosition = blockPosIn;
         this.theWorld = worldIn;
         this.thePlayer = player;
         this.addSlotToContainer(new Slot(this.inputSlots, 0, 27, 47));
         this.addSlotToContainer(new Slot(this.inputSlots, 1, 76, 47));
-        this.addSlotToContainer(new Slot(this.outputSlot, 2, 134, 47)
-        {
+        this.addSlotToContainer(new Slot(this.outputSlot, 2, 134, 47) {
+
             private static final String __OBFID = "CL_00001734";
-            public boolean isItemValid(ItemStack stack)
-            {
+
+            public boolean isItemValid(ItemStack stack) {
                 return false;
             }
-            public boolean canTakeStack(EntityPlayer playerIn)
-            {
+
+            public boolean canTakeStack(EntityPlayer playerIn) {
                 return (playerIn.capabilities.isCreativeMode || playerIn.experienceLevel >= ContainerRepair.this.maximumCost) && ContainerRepair.this.maximumCost > 0 && this.getHasStack();
             }
-            public void onPickupFromSlot(EntityPlayer playerIn, ItemStack stack)
-            {
-                if (!playerIn.capabilities.isCreativeMode)
-                {
+
+            public void onPickupFromSlot(EntityPlayer playerIn, ItemStack stack) {
+                if (!playerIn.capabilities.isCreativeMode) {
                     playerIn.addExperienceLevel(-ContainerRepair.this.maximumCost);
                 }
 
-                ContainerRepair.this.inputSlots.setInventorySlotContents(0, (ItemStack)null);
+                ContainerRepair.this.inputSlots.setInventorySlotContents(0, (ItemStack) null);
 
-                if (ContainerRepair.this.materialCost > 0)
-                {
+                if (ContainerRepair.this.materialCost > 0) {
                     ItemStack itemstack1 = ContainerRepair.this.inputSlots.getStackInSlot(1);
 
-                    if (itemstack1 != null && itemstack1.stackSize > ContainerRepair.this.materialCost)
-                    {
+                    if (itemstack1 != null && itemstack1.stackSize > ContainerRepair.this.materialCost) {
                         itemstack1.stackSize -= ContainerRepair.this.materialCost;
                         ContainerRepair.this.inputSlots.setInventorySlotContents(1, itemstack1);
+                    } else {
+                        ContainerRepair.this.inputSlots.setInventorySlotContents(1, (ItemStack) null);
                     }
-                    else
-                    {
-                        ContainerRepair.this.inputSlots.setInventorySlotContents(1, (ItemStack)null);
-                    }
+                } else {
+                    ContainerRepair.this.inputSlots.setInventorySlotContents(1, (ItemStack) null);
                 }
-                else
-                {
-                    ContainerRepair.this.inputSlots.setInventorySlotContents(1, (ItemStack)null);
-                }
 
                 ContainerRepair.this.maximumCost = 0;
                 IBlockState iblockstate = worldIn.getBlockState(blockPosIn);
 
-                if (!playerIn.capabilities.isCreativeMode && !worldIn.isRemote && iblockstate.getBlock() == Blocks.anvil && playerIn.getRNG().nextFloat() < 0.12F)
-                {
-                    int k = ((Integer)iblockstate.getValue(BlockAnvil.DAMAGE)).intValue();
+                if (!playerIn.capabilities.isCreativeMode && !worldIn.isRemote && iblockstate.getBlock() == Blocks.anvil && playerIn.getRNG().nextFloat() < 0.12F) {
+                    int k = ((Integer) iblockstate.getValue(BlockAnvil.DAMAGE)).intValue();
                     ++k;
 
-                    if (k > 2)
-                    {
+                    if (k > 2) {
                         worldIn.setBlockToAir(blockPosIn);
                         worldIn.playAuxSFX(1020, blockPosIn, 0);
-                    }
-                    else
-                    {
+                    } else {
                         worldIn.setBlockState(blockPosIn, iblockstate.withProperty(BlockAnvil.DAMAGE, Integer.valueOf(k)), 2);
                         worldIn.playAuxSFX(1021, blockPosIn, 0);
                     }
-                }
-                else if (!worldIn.isRemote)
-                {
+                } else if (!worldIn.isRemote) {
                     worldIn.playAuxSFX(1021, blockPosIn, 0);
                 }
             }
         });
         int i;
 
-        for (i = 0; i < 3; ++i)
-        {
-            for (int j = 0; j < 9; ++j)
-            {
+        for (i = 0; i < 3; ++i) {
+            for (int j = 0; j < 9; ++j) {
                 this.addSlotToContainer(new Slot(playerInventory, j + i * 9 + 9, 8 + j * 18, 84 + i * 18));
             }
         }
 
-        for (i = 0; i < 9; ++i)
-        {
+        for (i = 0; i < 9; ++i) {
             this.addSlotToContainer(new Slot(playerInventory, i, 8 + i * 18, 142));
         }
     }
 
-    public void onCraftMatrixChanged(IInventory inventoryIn)
-    {
+    public void onCraftMatrixChanged(IInventory inventoryIn) {
         super.onCraftMatrixChanged(inventoryIn);
 
-        if (inventoryIn == this.inputSlots)
-        {
+        if (inventoryIn == this.inputSlots) {
             this.updateRepairOutput();
         }
     }
 
-    public void updateRepairOutput()
-    {
+    public void updateRepairOutput() {
         boolean flag = false;
         boolean flag1 = true;
         boolean flag2 = true;
         boolean flag3 = true;
         boolean flag4 = true;
@@ -158,140 +189,116 @@
         this.maximumCost = 1;
         int i = 0;
         byte b0 = 0;
         byte b1 = 0;
 
-        if (itemstack == null)
-        {
-            this.outputSlot.setInventorySlotContents(0, (ItemStack)null);
+        if (itemstack == null) {
+            this.outputSlot.setInventorySlotContents(0, (ItemStack) null);
             this.maximumCost = 0;
-        }
-        else
-        {
+        } else {
             ItemStack itemstack1 = itemstack.copy();
             ItemStack itemstack2 = this.inputSlots.getStackInSlot(1);
             Map map = EnchantmentHelper.getEnchantments(itemstack1);
             boolean flag7 = false;
             int i2 = b0 + itemstack.getRepairCost() + (itemstack2 == null ? 0 : itemstack2.getRepairCost());
             this.materialCost = 0;
             int j;
 
-            if (itemstack2 != null)
-            {
+            if (itemstack2 != null) {
                 flag7 = itemstack2.getItem() == Items.enchanted_book && Items.enchanted_book.getEnchantments(itemstack2).tagCount() > 0;
                 int k;
                 int l;
 
-                if (itemstack1.isItemStackDamageable() && itemstack1.getItem().getIsRepairable(itemstack, itemstack2))
-                {
+                if (itemstack1.isItemStackDamageable() && itemstack1.getItem().getIsRepairable(itemstack, itemstack2)) {
                     j = Math.min(itemstack1.getItemDamage(), itemstack1.getMaxDamage() / 4);
 
-                    if (j <= 0)
-                    {
-                        this.outputSlot.setInventorySlotContents(0, (ItemStack)null);
+                    if (j <= 0) {
+                        this.outputSlot.setInventorySlotContents(0, (ItemStack) null);
                         this.maximumCost = 0;
                         return;
                     }
 
-                    for (k = 0; j > 0 && k < itemstack2.stackSize; ++k)
-                    {
+                    for (k = 0; j > 0 && k < itemstack2.stackSize; ++k) {
                         l = itemstack1.getItemDamage() - j;
                         itemstack1.setItemDamage(l);
                         ++i;
                         j = Math.min(itemstack1.getItemDamage(), itemstack1.getMaxDamage() / 4);
                     }
 
                     this.materialCost = k;
-                }
-                else
-                {
-                    if (!flag7 && (itemstack1.getItem() != itemstack2.getItem() || !itemstack1.isItemStackDamageable()))
-                    {
-                        this.outputSlot.setInventorySlotContents(0, (ItemStack)null);
+                } else {
+                    if (!flag7 && (itemstack1.getItem() != itemstack2.getItem() || !itemstack1.isItemStackDamageable())) {
+                        this.outputSlot.setInventorySlotContents(0, (ItemStack) null);
                         this.maximumCost = 0;
                         return;
                     }
 
                     int j1;
 
-                    if (itemstack1.isItemStackDamageable() && !flag7)
-                    {
+                    if (itemstack1.isItemStackDamageable() && !flag7) {
                         j = itemstack.getMaxDamage() - itemstack.getItemDamage();
                         k = itemstack2.getMaxDamage() - itemstack2.getItemDamage();
                         l = k + itemstack1.getMaxDamage() * 12 / 100;
                         int i1 = j + l;
                         j1 = itemstack1.getMaxDamage() - i1;
 
-                        if (j1 < 0)
-                        {
+                        if (j1 < 0) {
                             j1 = 0;
                         }
 
-                        if (j1 < itemstack1.getMetadata())
-                        {
+                        if (j1 < itemstack1.getMetadata()) {
                             itemstack1.setItemDamage(j1);
                             i += 2;
                         }
                     }
 
                     Map map1 = EnchantmentHelper.getEnchantments(itemstack2);
                     Iterator iterator1 = map1.keySet().iterator();
 
-                    while (iterator1.hasNext())
-                    {
-                        l = ((Integer)iterator1.next()).intValue();
+                    while (iterator1.hasNext()) {
+                        l = ((Integer) iterator1.next()).intValue();
                         Enchantment enchantment = Enchantment.getEnchantmentById(l);
 
-                        if (enchantment != null)
-                        {
-                            j1 = map.containsKey(Integer.valueOf(l)) ? ((Integer)map.get(Integer.valueOf(l))).intValue() : 0;
-                            int k1 = ((Integer)map1.get(Integer.valueOf(l))).intValue();
+                        if (enchantment != null) {
+                            j1 = map.containsKey(Integer.valueOf(l)) ? ((Integer) map.get(Integer.valueOf(l))).intValue() : 0;
+                            int k1 = ((Integer) map1.get(Integer.valueOf(l))).intValue();
                             int k2;
 
-                            if (j1 == k1)
-                            {
+                            if (j1 == k1) {
                                 ++k1;
                                 k2 = k1;
-                            }
-                            else
-                            {
+                            } else {
                                 k2 = Math.max(k1, j1);
                             }
 
                             k1 = k2;
                             boolean flag8 = enchantment.canApply(itemstack);
 
-                            if (this.thePlayer.capabilities.isCreativeMode || itemstack.getItem() == Items.enchanted_book)
-                            {
+                            if (this.thePlayer.capabilities.isCreativeMode || itemstack.getItem() == Items.enchanted_book) {
                                 flag8 = true;
                             }
 
                             Iterator iterator = map.keySet().iterator();
 
-                            while (iterator.hasNext())
-                            {
-                                int l1 = ((Integer)iterator.next()).intValue();
+                            while (iterator.hasNext()) {
+                                int l1 = ((Integer) iterator.next()).intValue();
 
-                                if (l1 != l && !enchantment.canApplyTogether(Enchantment.getEnchantmentById(l1)))
-                                {
+                                if (l1 != l && !enchantment.canApplyTogether(Enchantment.getEnchantmentById(l1))) {
                                     flag8 = false;
                                     ++i;
                                 }
                             }
 
-                            if (flag8)
-                            {
-                                if (k1 > enchantment.getMaxLevel())
-                                {
+                            if (flag8) {
+                                if (k1 > enchantment.getMaxLevel()) {
                                     k1 = enchantment.getMaxLevel();
                                 }
 
                                 map.put(Integer.valueOf(l), Integer.valueOf(k1));
                                 int j2 = 0;
 
-                                switch (enchantment.getWeight())
-                                {
+                                switch (enchantment.getWeight()) {
                                     case 1:
                                         j2 = 8;
                                         break;
                                     case 2:
                                         j2 = 4;
@@ -308,61 +315,51 @@
                                         break;
                                     case 10:
                                         j2 = 1;
                                 }
 
-                                if (flag7)
-                                {
+                                if (flag7) {
                                     j2 = Math.max(1, j2 / 2);
                                 }
 
                                 i += j2 * k1;
                             }
                         }
                     }
                 }
             }
 
-            if (StringUtils.isBlank(this.repairedItemName))
-            {
-                if (itemstack.hasDisplayName())
-                {
+            if (StringUtils.isBlank(this.repairedItemName)) {
+                if (itemstack.hasDisplayName()) {
                     b1 = 1;
                     i += b1;
                     itemstack1.clearCustomName();
                 }
-            }
-            else if (!this.repairedItemName.equals(itemstack.getDisplayName()))
-            {
+            } else if (!this.repairedItemName.equals(itemstack.getDisplayName())) {
                 b1 = 1;
                 i += b1;
                 itemstack1.setStackDisplayName(this.repairedItemName);
             }
 
             this.maximumCost = i2 + i;
 
-            if (i <= 0)
-            {
+            if (i <= 0) {
                 itemstack1 = null;
             }
 
-            if (b1 == i && b1 > 0 && this.maximumCost >= 40)
-            {
+            if (b1 == i && b1 > 0 && this.maximumCost >= 40) {
                 this.maximumCost = 39;
             }
 
-            if (this.maximumCost >= 40 && !this.thePlayer.capabilities.isCreativeMode)
-            {
+            if (this.maximumCost >= 40 && !this.thePlayer.capabilities.isCreativeMode) {
                 itemstack1 = null;
             }
 
-            if (itemstack1 != null)
-            {
+            if (itemstack1 != null) {
                 j = itemstack1.getRepairCost();
 
-                if (itemstack2 != null && j < itemstack2.getRepairCost())
-                {
+                if (itemstack2 != null && j < itemstack2.getRepairCost()) {
                     j = itemstack2.getRepairCost();
                 }
 
                 j = j * 2 + 1;
                 itemstack1.setRepairCost(j);
@@ -372,115 +369,96 @@
             this.outputSlot.setInventorySlotContents(0, itemstack1);
             this.detectAndSendChanges();
         }
     }
 
-    public void addCraftingToCrafters(ICrafting listener)
-    {
+    public void addCraftingToCrafters(ICrafting listener) {
         super.addCraftingToCrafters(listener);
         listener.sendProgressBarUpdate(this, 0, this.maximumCost);
     }
 
-    @SideOnly(Side.CLIENT)
-    public void updateProgressBar(int id, int data)
-    {
-        if (id == 0)
-        {
-            this.maximumCost = data;
-        }
-    }
-
-    public void onContainerClosed(EntityPlayer playerIn)
-    {
+    public void onContainerClosed(EntityPlayer playerIn) {
         super.onContainerClosed(playerIn);
 
-        if (!this.theWorld.isRemote)
-        {
-            for (int i = 0; i < this.inputSlots.getSizeInventory(); ++i)
-            {
+        if (!this.theWorld.isRemote) {
+            for (int i = 0; i < this.inputSlots.getSizeInventory(); ++i) {
                 ItemStack itemstack = this.inputSlots.getStackInSlotOnClosing(i);
 
-                if (itemstack != null)
-                {
+                if (itemstack != null) {
                     playerIn.dropPlayerItemWithRandomChoice(itemstack, false);
                 }
             }
         }
     }
 
-    public boolean canInteractWith(EntityPlayer playerIn)
-    {
-        return this.theWorld.getBlockState(this.selfPosition).getBlock() != Blocks.anvil ? false : playerIn.getDistanceSq((double)this.selfPosition.getX() + 0.5D, (double)this.selfPosition.getY() + 0.5D, (double)this.selfPosition.getZ() + 0.5D) <= 64.0D;
+    public boolean canInteractWith(EntityPlayer playerIn) {
+        if (!this.checkReachable) return true; // CraftBukkit
+        return this.theWorld.getBlockState(this.selfPosition).getBlock() != Blocks.anvil ? false : playerIn.getDistanceSq((double) this.selfPosition.getX() + 0.5D, (double) this.selfPosition.getY() + 0.5D, (double) this.selfPosition.getZ() + 0.5D) <= 64.0D;
     }
 
-    public ItemStack transferStackInSlot(EntityPlayer playerIn, int index)
-    {
+    public ItemStack transferStackInSlot(EntityPlayer playerIn, int index) {
         ItemStack itemstack = null;
-        Slot slot = (Slot)this.inventorySlots.get(index);
+        Slot slot = (Slot) this.inventorySlots.get(index);
 
-        if (slot != null && slot.getHasStack())
-        {
+        if (slot != null && slot.getHasStack()) {
             ItemStack itemstack1 = slot.getStack();
             itemstack = itemstack1.copy();
 
-            if (index == 2)
-            {
-                if (!this.mergeItemStack(itemstack1, 3, 39, true))
-                {
+            if (index == 2) {
+                if (!this.mergeItemStack(itemstack1, 3, 39, true)) {
                     return null;
                 }
 
                 slot.onSlotChange(itemstack1, itemstack);
-            }
-            else if (index != 0 && index != 1)
-            {
-                if (index >= 3 && index < 39 && !this.mergeItemStack(itemstack1, 0, 2, false))
-                {
+            } else if (index != 0 && index != 1) {
+                if (index >= 3 && index < 39 && !this.mergeItemStack(itemstack1, 0, 2, false)) {
                     return null;
                 }
-            }
-            else if (!this.mergeItemStack(itemstack1, 3, 39, false))
-            {
+            } else if (!this.mergeItemStack(itemstack1, 3, 39, false)) {
                 return null;
             }
 
-            if (itemstack1.stackSize == 0)
-            {
-                slot.putStack((ItemStack)null);
-            }
-            else
-            {
+            if (itemstack1.stackSize == 0) {
+                slot.putStack((ItemStack) null);
+            } else {
                 slot.onSlotChanged();
             }
 
-            if (itemstack1.stackSize == itemstack.stackSize)
-            {
+            if (itemstack1.stackSize == itemstack.stackSize) {
                 return null;
             }
 
             slot.onPickupFromSlot(playerIn, itemstack1);
         }
 
         return itemstack;
     }
 
-    public void updateItemName(String newName)
-    {
+    public void updateItemName(String newName) {
         this.repairedItemName = newName;
 
-        if (this.getSlot(2).getHasStack())
-        {
+        if (this.getSlot(2).getHasStack()) {
             ItemStack itemstack = this.getSlot(2).getStack();
 
-            if (StringUtils.isBlank(newName))
-            {
+            if (StringUtils.isBlank(newName)) {
                 itemstack.clearCustomName();
-            }
-            else
-            {
+            } else {
                 itemstack.setStackDisplayName(this.repairedItemName);
             }
         }
 
         this.updateRepairOutput();
     }
+
+    // CraftBukkit start
+    @Override
+    public CraftInventoryView getBukkitView() {
+        if (bukkitEntity != null) {
+            return bukkitEntity;
+        }
+
+        CraftInventory inventory = new CraftInventoryAnvil(this.inputSlots, this.outputSlot);
+        bukkitEntity = new CraftInventoryView(this.player.player.getBukkitEntity(), inventory, this);
+        return bukkitEntity;
+    }
+    // CraftBukkit end
 }
