--- decompiled\net\minecraft\network\NetHandlerPlayServer.java
+++ src\main\java\net\minecraft\network\NetHandlerPlayServer.java
@@ -1,44 +1,46 @@
 package net.minecraft.network;
 
-import com.google.common.collect.Lists;
-import com.google.common.util.concurrent.Futures;
-import io.netty.buffer.Unpooled;
-import io.netty.util.concurrent.Future;
-import io.netty.util.concurrent.GenericFutureListener;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Date;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+
 import net.minecraft.block.material.Material;
 import net.minecraft.command.server.CommandBlockLogic;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityLiving;
 import net.minecraft.entity.EntityMinecartCommandBlock;
 import net.minecraft.entity.item.EntityItem;
 import net.minecraft.entity.item.EntityXPOrb;
 import net.minecraft.entity.passive.EntityHorse;
 import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.player.EntityPlayer.EnumChatVisibility;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.entity.player.InventoryPlayer;
 import net.minecraft.entity.projectile.EntityArrow;
+import net.minecraft.init.Blocks;
 import net.minecraft.init.Items;
 import net.minecraft.inventory.Container;
 import net.minecraft.inventory.ContainerBeacon;
 import net.minecraft.inventory.ContainerMerchant;
 import net.minecraft.inventory.ContainerRepair;
 import net.minecraft.inventory.IInventory;
 import net.minecraft.inventory.Slot;
+import net.minecraft.item.Item;
 import net.minecraft.item.ItemEditableBook;
 import net.minecraft.item.ItemStack;
 import net.minecraft.item.ItemWritableBook;
 import net.minecraft.nbt.NBTTagCompound;
-import net.minecraft.nbt.NBTTagString;
 import net.minecraft.network.play.INetHandlerPlayServer;
 import net.minecraft.network.play.client.C00PacketKeepAlive;
 import net.minecraft.network.play.client.C01PacketChatMessage;
 import net.minecraft.network.play.client.C02PacketUseEntity;
 import net.minecraft.network.play.client.C03PacketPlayer;
@@ -61,16 +63,20 @@
 import net.minecraft.network.play.client.C17PacketCustomPayload;
 import net.minecraft.network.play.client.C18PacketSpectate;
 import net.minecraft.network.play.client.C19PacketResourcePackStatus;
 import net.minecraft.network.play.server.S00PacketKeepAlive;
 import net.minecraft.network.play.server.S02PacketChat;
-import net.minecraft.network.play.server.S07PacketRespawn;
+import net.minecraft.network.play.server.S05PacketSpawnPosition;
 import net.minecraft.network.play.server.S08PacketPlayerPosLook;
+import net.minecraft.network.play.server.S09PacketHeldItemChange;
 import net.minecraft.network.play.server.S18PacketEntityTeleport;
+import net.minecraft.network.play.server.S1BPacketEntityAttach;
+import net.minecraft.network.play.server.S1CPacketEntityMetadata;
 import net.minecraft.network.play.server.S23PacketBlockChange;
 import net.minecraft.network.play.server.S2FPacketSetSlot;
 import net.minecraft.network.play.server.S32PacketConfirmTransaction;
+import net.minecraft.network.play.server.S33PacketUpdateSign;
 import net.minecraft.network.play.server.S3APacketTabComplete;
 import net.minecraft.network.play.server.S40PacketDisconnect;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.gui.IUpdatePlayerListBox;
 import net.minecraft.server.management.UserListBansEntry;
@@ -85,18 +91,71 @@
 import net.minecraft.util.ChatComponentTranslation;
 import net.minecraft.util.EnumChatFormatting;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.IChatComponent;
 import net.minecraft.util.IntHashMap;
+import net.minecraft.util.MathHelper;
+import net.minecraft.util.MovingObjectPosition;
+import net.minecraft.util.MovingObjectPosition.MovingObjectType;
 import net.minecraft.util.ReportedException;
+import net.minecraft.util.Vec3;
 import net.minecraft.world.WorldServer;
+import net.minecraft.world.WorldSettings.GameType;
+
 import org.apache.commons.lang3.StringUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.Location;
+import org.bukkit.command.CommandException;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.SpigotTimings;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.inventory.CraftInventoryView;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.bukkit.craftbukkit.util.LazyPlayerSet;
+import org.bukkit.craftbukkit.util.Waitable;
+import org.bukkit.entity.HumanEntity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.Event;
+import org.bukkit.event.block.Action;
+import org.bukkit.event.block.SignChangeEvent;
+import org.bukkit.event.inventory.ClickType;
+import org.bukkit.event.inventory.CraftItemEvent;
+import org.bukkit.event.inventory.InventoryAction;
+import org.bukkit.event.inventory.InventoryClickEvent;
+import org.bukkit.event.inventory.InventoryCreativeEvent;
+import org.bukkit.event.inventory.InventoryType.SlotType;
+import org.bukkit.event.player.AsyncPlayerChatEvent;
+import org.bukkit.event.player.PlayerAnimationEvent;
+import org.bukkit.event.player.PlayerChatEvent;
+import org.bukkit.event.player.PlayerCommandPreprocessEvent;
+import org.bukkit.event.player.PlayerInteractAtEntityEvent;
+import org.bukkit.event.player.PlayerInteractEntityEvent;
+import org.bukkit.event.player.PlayerItemHeldEvent;
+import org.bukkit.event.player.PlayerKickEvent;
+import org.bukkit.event.player.PlayerMoveEvent;
+import org.bukkit.event.player.PlayerTeleportEvent;
+import org.bukkit.event.player.PlayerToggleFlightEvent;
+import org.bukkit.event.player.PlayerToggleSneakEvent;
+import org.bukkit.event.player.PlayerToggleSprintEvent;
+import org.bukkit.inventory.CraftingInventory;
+import org.bukkit.inventory.InventoryView;
+import org.bukkit.inventory.PlayerInventory;
+import org.bukkit.util.NumberConversions;
+import org.bukkit.util.Vector;
+import org.spigotmc.SpigotConfig;
 
-public class NetHandlerPlayServer implements INetHandlerPlayServer, IUpdatePlayerListBox
-{
+import com.google.common.collect.Lists;
+
+import io.netty.buffer.Unpooled;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+
+public class NetHandlerPlayServer implements INetHandlerPlayServer, IUpdatePlayerListBox {
+
     private static final Logger logger = LogManager.getLogger();
     public final NetworkManager netManager;
     private final MinecraftServer serverController;
     public EntityPlayerMP playerEntity;
     private int networkTickCount;
@@ -104,177 +163,303 @@
     private int floatingTickCount;
     private boolean field_147366_g;
     private int field_147378_h;
     private long lastPingTime;
     private long lastSentPingPacket;
-    private int chatSpamThresholdCount;
+    // CraftBukkit start - multithreaded fields
+    private volatile int chatSpamThresholdCount;
+    private static final AtomicIntegerFieldUpdater chatSpamField = AtomicIntegerFieldUpdater.newUpdater(net.minecraft.network.NetHandlerPlayServer.class, "chatThrottle");
+    // CraftBukkit end
     private int itemDropThreshold;
     private IntHashMap field_147372_n = new IntHashMap();
+    // SpigotMCP Start -- Add Depreciated to note that there are bukkit alternatives that (used to) have the same name
+    /**
+     * @deprecated make sure you shouldn't use the bukkit field
+     */
+    @Deprecated
     private double lastPosX;
+    /**
+     * @deprecated make sure you shouldn't use the bukkit field
+     */
+    @Deprecated
     private double lastPosY;
+    /**
+     * @deprecated make sure you shouldn't use the bukkit field
+     */
+    @Deprecated
     private double lastPosZ;
+    /**
+     * @deprecated make sure you shouldn't use the bukkit field
+     */
+    @Deprecated
     private boolean hasMoved = true;
+    // SpigotMCP End
+    private boolean processedDisconnect; // CraftBukkit - added
     private static final String __OBFID = "CL_00001452";
 
-    public NetHandlerPlayServer(MinecraftServer server, NetworkManager networkManagerIn, EntityPlayerMP playerIn)
-    {
+    public NetHandlerPlayServer(MinecraftServer server, NetworkManager networkManagerIn, EntityPlayerMP playerIn) {
         this.serverController = server;
         this.netManager = networkManagerIn;
         networkManagerIn.setNetHandler(this);
         this.playerEntity = playerIn;
         playerIn.playerNetServerHandler = this;
+
+        // CraftBukkit start - add fields and methods
+        this.server = server.server;
     }
 
-    public void update()
-    {
+    private final CraftServer server;
+    private int lastTick = MinecraftServer.currentTick;
+    private int lastDropTick = MinecraftServer.currentTick;
+    private int dropCount = 0;
+    private static final int SURVIVAL_PLACE_DISTANCE_SQUARED = 6 * 6;
+    private static final int CREATIVE_PLACE_DISTANCE_SQUARED = 7 * 7;
+
+    // Get position of last block hit for BlockDamageLevel.STOPPED
+    // SpigotMCP Start -- Prefix with 'bukkit' to avoid conflicts with MCP
+    private double bukkitLastPosX = Double.MAX_VALUE;
+    private double bukkitLastPosY = Double.MAX_VALUE;
+    private double bukkitLastPosZ = Double.MAX_VALUE;
+    // SpigotMCP end
+    private float lastPitch = Float.MAX_VALUE;
+    private float lastYaw = Float.MAX_VALUE;
+    private boolean justTeleported = false;
+    private boolean bukkitHasMoved; // SpigotMCP -- Prefix with 'bukkit' to avoid conflicts with MCP
+
+    public org.bukkit.craftbukkit.entity.CraftPlayer getPlayer() {
+        return (this.playerEntity == null) ? null : (CraftPlayer) this.playerEntity.getBukkitEntity();
+    }
+
+    private final static HashSet invalidItems = new HashSet(java.util.Arrays.asList(8, 9, 10, 11, 26, 34, 36, 43, 51, 52, 55, 59, 60, 62, 63, 64, 68, 71, 74, 75, 83, 90, 92, 93, 94, 104, 105, 115, 117, 118, 119, 125, 127, 132, 140, 141, 142, 144)); // TODO: Check after every update.
+    // CraftBukkit end
+
+    public void update() {
         this.field_147366_g = false;
         ++this.networkTickCount;
         this.serverController.theProfiler.startSection("keepAlive");
 
-        if ((long)this.networkTickCount - this.lastSentPingPacket > 40L)
-        {
-            this.lastSentPingPacket = (long)this.networkTickCount;
+        if ((long) this.networkTickCount - this.lastSentPingPacket > 40L) {
+            this.lastSentPingPacket = (long) this.networkTickCount;
             this.lastPingTime = this.currentTimeMillis();
-            this.field_147378_h = (int)this.lastPingTime;
+            this.field_147378_h = (int) this.lastPingTime;
             this.sendPacket(new S00PacketKeepAlive(this.field_147378_h));
         }
 
         this.serverController.theProfiler.endSection();
 
-        if (this.chatSpamThresholdCount > 0)
-        {
+        // CraftBukkit start
+        for (int spam; (spam = this.chatSpamThresholdCount) > 0 && !chatSpamField.compareAndSet(this, spam, spam - 1); ) ;
+        /* Use thread-safe field access instead
+        if (this.chatSpamThresholdCount > 0) {
             --this.chatSpamThresholdCount;
         }
+        */
+        // CraftBukkit end
 
-        if (this.itemDropThreshold > 0)
-        {
+        if (this.itemDropThreshold > 0) {
             --this.itemDropThreshold;
         }
 
-        if (this.playerEntity.getLastActiveTime() > 0L && this.serverController.getMaxPlayerIdleMinutes() > 0 && MinecraftServer.getCurrentTimeMillis() - this.playerEntity.getLastActiveTime() > (long)(this.serverController.getMaxPlayerIdleMinutes() * 1000 * 60))
-        {
+        if (this.playerEntity.getLastActiveTime() > 0L && this.serverController.getMaxPlayerIdleMinutes() > 0 && MinecraftServer.getCurrentTimeMillis() - this.playerEntity.getLastActiveTime() > (long) (this.serverController.getMaxPlayerIdleMinutes() * 1000 * 60)) {
             this.kickPlayerFromServer("You have been idle for too long!");
         }
     }
 
-    public NetworkManager getNetworkManager()
-    {
+    public NetworkManager getNetworkManager() {
         return this.netManager;
     }
 
-    public void kickPlayerFromServer(String reason)
-    {
+    public void kickPlayerFromServer(String reason) {
+        // CraftBukkit start - fire PlayerKickEvent
+        String leaveMessage = EnumChatFormatting.YELLOW + this.playerEntity.getName() + " left the game.";
+
+        PlayerKickEvent event = new PlayerKickEvent(this.server.getPlayer(this.playerEntity), reason, leaveMessage);
+
+        if (this.server.getServer().isServerRunning()) {
+            this.server.getPluginManager().callEvent(event);
+        }
+
+        if (event.isCancelled()) {
+            // Do not kick the player
+            return;
+        }
+        // Send the possibly modified leave message
+        reason = event.getReason();
+        // CraftBukkit end
         final ChatComponentText chatcomponenttext = new ChatComponentText(reason);
-        this.netManager.sendPacket(new S40PacketDisconnect(chatcomponenttext), new GenericFutureListener()
-        {
+        this.netManager.sendPacket(new S40PacketDisconnect(chatcomponenttext), new GenericFutureListener() {
+
             private static final String __OBFID = "CL_00001453";
-            public void operationComplete(Future p_operationComplete_1_)
-            {
+
+            public void operationComplete(Future p_operationComplete_1_) {
                 NetHandlerPlayServer.this.netManager.closeChannel(chatcomponenttext);
             }
         }, new GenericFutureListener[0]);
+        this.onDisconnect(chatcomponenttext); // CraftBukkit - fire quit instantly
         this.netManager.disableAutoRead();
-        Futures.getUnchecked(this.serverController.addScheduledTask(new Runnable()
-        {
+        this.serverController.addScheduledTask(new Runnable() {
+
             private static final String __OBFID = "CL_00001454";
-            public void run()
-            {
+
+            public void run() {
                 NetHandlerPlayServer.this.netManager.checkDisconnected();
             }
-        }));
+        }); // CraftBukkit - Don't wait
     }
 
-    public void processInput(C0CPacketInput packetIn)
-    {
+    public void processInput(C0CPacketInput packetIn) {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
         this.playerEntity.setEntityActionState(packetIn.getStrafeSpeed(), packetIn.getForwardSpeed(), packetIn.isJumping(), packetIn.isSneaking());
     }
 
-    public void processPlayer(C03PacketPlayer packetIn)
-    {
+    public void processPlayer(C03PacketPlayer packetIn) {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
+        // CraftBukkit start - Check for NaN
+        if (!NumberConversions.isFinite(packetIn.x) || !NumberConversions.isFinite(packetIn.y) || !NumberConversions.isFinite(packetIn.z)) {
+            logger.warn(playerEntity.getName() + " was caught trying to crash the server with an invalid position.");
+            getPlayer().kickPlayer("NaN in position (Hacking?)"); //Spigot "Nope" -> Descriptive reason
+            return;
+        }
+        // CraftBukkit end
         WorldServer worldserver = this.serverController.worldServerForDimension(this.playerEntity.dimension);
         this.field_147366_g = true;
 
-        if (!this.playerEntity.playerConqueredTheEnd)
-        {
+        if (!this.playerEntity.playerConqueredTheEnd) {
             double d0 = this.playerEntity.posX;
             double d1 = this.playerEntity.posY;
             double d2 = this.playerEntity.posZ;
             double d3 = 0.0D;
             double d4 = packetIn.getPositionX() - this.lastPosX;
             double d5 = packetIn.getPositionY() - this.lastPosY;
             double d6 = packetIn.getPositionZ() - this.lastPosZ;
 
-            if (packetIn.isMoving())
-            {
+            if (packetIn.isMoving()) {
                 d3 = d4 * d4 + d5 * d5 + d6 * d6;
 
-                if (!this.hasMoved && d3 < 0.25D)
-                {
+                if (!this.hasMoved && d3 < 0.25D) {
                     this.hasMoved = true;
                 }
             }
+            // CraftBukkit start - fire PlayerMoveEvent
+            Player player = this.getPlayer();
+            // Spigot Start
+            if (!bukkitHasMoved) {
+                Location curPos = player.getLocation();
+                bukkitLastPosX = curPos.getX();
+                bukkitLastPosX = curPos.getY();
+                bukkitLastPosX = curPos.getZ();
+                lastYaw = curPos.getYaw();
+                lastPitch = curPos.getPitch();
+                bukkitHasMoved = true;
+            }
+            // Spigot End
+            Location from = new Location(player.getWorld(), bukkitLastPosX, bukkitLastPosX, bukkitLastPosX, lastYaw, lastPitch); // Get the Players previous Event location.
+            Location to = player.getLocation().clone(); // Start off the To location as the Players current location.
 
-            if (this.hasMoved)
-            {
+            // If the packet contains movement information then we update the To location with the correct XYZ.
+            if (packetIn.moving && !(packetIn.moving && packetIn.y == -999.0D)) {
+                to.setX(packetIn.x);
+                to.setY(packetIn.y);
+                to.setZ(packetIn.z);
+            }
+
+            // If the packet contains look information then we update the To location with the correct Yaw & Pitch.
+            if (packetIn.rotating) {
+                to.setYaw(packetIn.yaw);
+                to.setPitch(packetIn.pitch);
+            }
+
+            // Prevent 40 event-calls for less than a single pixel of movement >.>
+            double delta = Math.pow(this.bukkitLastPosX - to.getX(), 2) + Math.pow(this.bukkitLastPosY - to.getY(), 2) + Math.pow(this.bukkitLastPosZ - to.getZ(), 2);
+            float deltaAngle = Math.abs(this.lastYaw - to.getYaw()) + Math.abs(this.lastPitch - to.getPitch());
+
+            if ((delta > 1f / 256 || deltaAngle > 10f) && (this.bukkitHasMoved && !this.playerEntity.isDead)) {
+                this.bukkitLastPosX = to.getX();
+                this.bukkitLastPosY = to.getY();
+                this.bukkitLastPosZ = to.getZ();
+                this.lastYaw = to.getYaw();
+                this.lastPitch = to.getPitch();
+
+                // Skip the first time we do this
+                if (true) { // Spigot - don't skip any move events
+                    PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
+                    this.server.getPluginManager().callEvent(event);
+
+                    // If the event is cancelled we move the player back to their old location.
+                    if (event.isCancelled()) {
+                        this.playerEntity.playerNetServerHandler.sendPacket(new S08PacketPlayerPosLook(from.getX(), from.getY(), from.getZ(), from.getYaw(), from.getPitch(), Collections.emptySet()));
+                        return;
+                    }
+
+                    /* If a Plugin has changed the To destination then we teleport the Player
+                    there to avoid any 'Moved wrongly' or 'Moved too quickly' errors.
+                    We only do this if the Event was not cancelled. */
+                    if (!to.equals(event.getTo()) && !event.isCancelled()) {
+                        this.playerEntity.getBukkitEntity().teleport(event.getTo(), PlayerTeleportEvent.TeleportCause.UNKNOWN);
+                        return;
+                    }
+
+                    /* Check to see if the Players Location has some how changed during the call of the event.
+                    This can happen due to a plugin teleporting the player instead of using .setTo() */
+                    if (!from.equals(this.getPlayer().getLocation()) && this.justTeleported) {
+                        this.justTeleported = false;
+                        return;
+                    }
+                }
+            }
+
+            if (this.bukkitHasMoved && !this.playerEntity.isDead) {
+                // CraftBukkit end
                 this.field_175090_f = this.networkTickCount;
                 double d8;
                 double d9;
                 double d10;
 
-                if (this.playerEntity.ridingEntity != null)
-                {
+                if (this.playerEntity.ridingEntity != null) {
                     float f4 = this.playerEntity.rotationYaw;
                     float f = this.playerEntity.rotationPitch;
                     this.playerEntity.ridingEntity.updateRiderPosition();
                     d8 = this.playerEntity.posX;
                     d9 = this.playerEntity.posY;
                     d10 = this.playerEntity.posZ;
 
-                    if (packetIn.getRotating())
-                    {
+                    if (packetIn.getRotating()) {
                         f4 = packetIn.getYaw();
                         f = packetIn.getPitch();
                     }
 
                     this.playerEntity.onGround = packetIn.isOnGround();
                     this.playerEntity.onUpdateEntity();
                     this.playerEntity.setPositionAndRotation(d8, d9, d10, f4, f);
 
-                    if (this.playerEntity.ridingEntity != null)
-                    {
+                    if (this.playerEntity.ridingEntity != null) {
                         this.playerEntity.ridingEntity.updateRiderPosition();
                     }
 
                     this.serverController.getConfigurationManager().serverUpdateMountedMovingPlayer(this.playerEntity);
 
-                    if (this.playerEntity.ridingEntity != null)
-                    {
-                        if (d3 > 4.0D)
-                        {
+                    if (this.playerEntity.ridingEntity != null) {
+                        if (d3 > 4.0D) {
                             Entity entity = this.playerEntity.ridingEntity;
                             this.playerEntity.playerNetServerHandler.sendPacket(new S18PacketEntityTeleport(entity));
                             this.setPlayerLocation(this.playerEntity.posX, this.playerEntity.posY, this.playerEntity.posZ, this.playerEntity.rotationYaw, this.playerEntity.rotationPitch);
                         }
 
                         this.playerEntity.ridingEntity.isAirBorne = true;
                     }
 
-                    if (this.hasMoved)
-                    {
+                    if (this.hasMoved) {
                         this.lastPosX = this.playerEntity.posX;
                         this.lastPosY = this.playerEntity.posY;
                         this.lastPosZ = this.playerEntity.posZ;
                     }
 
                     worldserver.updateEntity(this.playerEntity);
                     return;
                 }
 
-                if (this.playerEntity.isPlayerSleeping())
-                {
+                if (this.playerEntity.isPlayerSleeping()) {
                     this.playerEntity.onUpdateEntity();
                     this.playerEntity.setPositionAndRotation(this.lastPosX, this.lastPosY, this.lastPosZ, this.playerEntity.rotationYaw, this.playerEntity.rotationPitch);
                     worldserver.updateEntity(this.playerEntity);
                     return;
                 }
@@ -287,362 +472,453 @@
                 d9 = this.playerEntity.posY;
                 d10 = this.playerEntity.posZ;
                 float f1 = this.playerEntity.rotationYaw;
                 float f2 = this.playerEntity.rotationPitch;
 
-                if (packetIn.isMoving() && packetIn.getPositionY() == -999.0D)
-                {
+                if (packetIn.isMoving() && packetIn.getPositionY() == -999.0D) {
                     packetIn.setMoving(false);
                 }
 
-                if (packetIn.isMoving())
-                {
+                if (packetIn.isMoving()) {
                     d8 = packetIn.getPositionX();
                     d9 = packetIn.getPositionY();
                     d10 = packetIn.getPositionZ();
 
-                    if (Math.abs(packetIn.getPositionX()) > 3.0E7D || Math.abs(packetIn.getPositionZ()) > 3.0E7D)
-                    {
+                    if (Math.abs(packetIn.getPositionX()) > 3.0E7D || Math.abs(packetIn.getPositionZ()) > 3.0E7D) {
                         this.kickPlayerFromServer("Illegal position");
                         return;
                     }
                 }
 
-                if (packetIn.getRotating())
-                {
+                if (packetIn.getRotating()) {
                     f1 = packetIn.getYaw();
                     f2 = packetIn.getPitch();
                 }
 
                 this.playerEntity.onUpdateEntity();
                 this.playerEntity.setPositionAndRotation(this.lastPosX, this.lastPosY, this.lastPosZ, f1, f2);
 
-                if (!this.hasMoved)
-                {
+                if (!this.hasMoved) {
                     return;
                 }
 
                 double d11 = d8 - this.playerEntity.posX;
                 double d12 = d9 - this.playerEntity.posY;
                 double d13 = d10 - this.playerEntity.posZ;
-                double d14 = Math.min(Math.abs(d11), Math.abs(this.playerEntity.motionX));
-                double d15 = Math.min(Math.abs(d12), Math.abs(this.playerEntity.motionY));
-                double d16 = Math.min(Math.abs(d13), Math.abs(this.playerEntity.motionZ));
+                // CraftBukkit start - min to max
+                double d14 = Math.max(Math.abs(d11), Math.abs(this.playerEntity.motionX));
+                double d15 = Math.max(Math.abs(d12), Math.abs(this.playerEntity.motionY));
+                double d16 = Math.max(Math.abs(d13), Math.abs(this.playerEntity.motionZ));
+                // CraftBukkit end
                 double d17 = d14 * d14 + d15 * d15 + d16 * d16;
 
-                if (d17 > 100.0D && (!this.serverController.isSinglePlayer() || !this.serverController.getServerOwner().equals(this.playerEntity.getName())))
-                {
+                // Spigot: make "moved too quickly" limit configurable
+                if (d17 > SpigotConfig.movedTooQuicklyThreshold && this.bukkitHasMoved && (!this.serverController.isSinglePlayer() || !this.serverController.getServerOwner().equals(this.playerEntity.getName()))) { // CraftBukkit - Added this.checkMovement condition to solve this check being triggered by teleports
                     logger.warn(this.playerEntity.getName() + " moved too quickly! " + d11 + "," + d12 + "," + d13 + " (" + d14 + ", " + d15 + ", " + d16 + ")");
                     this.setPlayerLocation(this.lastPosX, this.lastPosY, this.lastPosZ, this.playerEntity.rotationYaw, this.playerEntity.rotationPitch);
                     return;
                 }
 
                 float f3 = 0.0625F;
-                boolean flag = worldserver.getCollidingBoundingBoxes(this.playerEntity, this.playerEntity.getEntityBoundingBox().contract((double)f3, (double)f3, (double)f3)).isEmpty();
+                boolean flag = worldserver.getCollidingBoundingBoxes(this.playerEntity, this.playerEntity.getEntityBoundingBox().contract((double) f3, (double) f3, (double) f3)).isEmpty();
 
-                if (this.playerEntity.onGround && !packetIn.isOnGround() && d12 > 0.0D)
-                {
+                if (this.playerEntity.onGround && !packetIn.isOnGround() && d12 > 0.0D) {
                     this.playerEntity.jump();
                 }
 
                 this.playerEntity.moveEntity(d11, d12, d13);
                 this.playerEntity.onGround = packetIn.isOnGround();
                 double d18 = d12;
                 d11 = d8 - this.playerEntity.posX;
                 d12 = d9 - this.playerEntity.posY;
 
-                if (d12 > -0.5D || d12 < 0.5D)
-                {
+                if (d12 > -0.5D || d12 < 0.5D) {
                     d12 = 0.0D;
                 }
 
                 d13 = d10 - this.playerEntity.posZ;
                 d17 = d11 * d11 + d12 * d12 + d13 * d13;
                 boolean flag1 = false;
 
-                if (d17 > 0.0625D && !this.playerEntity.isPlayerSleeping() && !this.playerEntity.theItemInWorldManager.isCreative())
-                {
+                // Spigot: make "moved wrongly" limit configurable
+                if (d17 > SpigotConfig.movedWronglyThreshold && !this.playerEntity.isPlayerSleeping() && !this.playerEntity.theItemInWorldManager.isCreative()) {
                     flag1 = true;
                     logger.warn(this.playerEntity.getName() + " moved wrongly!");
                 }
 
                 this.playerEntity.setPositionAndRotation(d8, d9, d10, f1, f2);
                 this.playerEntity.addMovementStat(this.playerEntity.posX - d0, this.playerEntity.posY - d1, this.playerEntity.posZ - d2);
 
-                if (!this.playerEntity.noClip)
-                {
-                    boolean flag2 = worldserver.getCollidingBoundingBoxes(this.playerEntity, this.playerEntity.getEntityBoundingBox().contract((double)f3, (double)f3, (double)f3)).isEmpty();
+                if (!this.playerEntity.noClip) {
+                    boolean flag2 = worldserver.getCollidingBoundingBoxes(this.playerEntity, this.playerEntity.getEntityBoundingBox().contract((double) f3, (double) f3, (double) f3)).isEmpty();
 
-                    if (flag && (flag1 || !flag2) && !this.playerEntity.isPlayerSleeping())
-                    {
+                    if (flag && (flag1 || !flag2) && !this.playerEntity.isPlayerSleeping()) {
                         this.setPlayerLocation(this.lastPosX, this.lastPosY, this.lastPosZ, f1, f2);
                         return;
                     }
                 }
 
-                AxisAlignedBB axisalignedbb = this.playerEntity.getEntityBoundingBox().expand((double)f3, (double)f3, (double)f3).addCoord(0.0D, -0.55D, 0.0D);
+                AxisAlignedBB axisalignedbb = this.playerEntity.getEntityBoundingBox().expand((double) f3, (double) f3, (double) f3).addCoord(0.0D, -0.55D, 0.0D);
 
-                if (!this.serverController.isFlightAllowed() && !this.playerEntity.capabilities.allowFlying && !worldserver.checkBlockCollision(axisalignedbb))
-                {
-                    if (d18 >= -0.03125D)
-                    {
+                if (!this.serverController.isFlightAllowed() && !this.playerEntity.capabilities.allowFlying && !worldserver.checkBlockCollision(axisalignedbb)) {
+                    if (d18 >= -0.03125D) {
                         ++this.floatingTickCount;
 
-                        if (this.floatingTickCount > 80)
-                        {
+                        if (this.floatingTickCount > 80) {
                             logger.warn(this.playerEntity.getName() + " was kicked for floating too long!");
                             this.kickPlayerFromServer("Flying is not enabled on this server");
                             return;
                         }
                     }
-                }
-                else
-                {
+                } else {
                     this.floatingTickCount = 0;
                 }
 
                 this.playerEntity.onGround = packetIn.isOnGround();
                 this.serverController.getConfigurationManager().serverUpdateMountedMovingPlayer(this.playerEntity);
                 this.playerEntity.handleFalling(this.playerEntity.posY - d7, packetIn.isOnGround());
-            }
-            else if (this.networkTickCount - this.field_175090_f > 20)
-            {
+            } else if (this.networkTickCount - this.field_175090_f > 20) {
                 this.setPlayerLocation(this.lastPosX, this.lastPosY, this.lastPosZ, this.playerEntity.rotationYaw, this.playerEntity.rotationPitch);
             }
         }
     }
 
-    public void setPlayerLocation(double x, double y, double z, float yaw, float pitch)
-    {
+    public void setPlayerLocation(double x, double y, double z, float yaw, float pitch) {
         this.setPlayerLocation(x, y, z, yaw, pitch, Collections.emptySet());
     }
 
-    public void setPlayerLocation(double x, double y, double z, float yaw, float pitch, Set relativeSet)
-    {
+    public void setPlayerLocation(double x, double y, double z, float yaw, float pitch, Set relativeSet) {
+        // CraftBukkit start - Delegate to teleport(Location)
+        Player player = this.getPlayer();
+        Location from = player.getLocation();
+        Location to = new Location(this.getPlayer().getWorld(), x, y, z, yaw, pitch);
+        PlayerTeleportEvent event = new PlayerTeleportEvent(player, from, to, PlayerTeleportEvent.TeleportCause.UNKNOWN);
+        this.server.getPluginManager().callEvent(event);
+
+        from = event.getFrom();
+        to = event.isCancelled() ? from : event.getTo();
+
+        this.teleport(to, relativeSet);
+    }
+
+    public void teleport(Location dest) {
+        teleport(dest, Collections.emptySet());
+    }
+
+    public void teleport(Location dest, Set relativeSet) {
+        double x, y, z;
+        float yaw, pitch;
+
+        x = dest.getX();
+        y = dest.getY();
+        z = dest.getZ();
+        yaw = dest.getYaw();
+        pitch = dest.getPitch();
+
+        // TODO: make sure this is the best way to address this.
+        if (Float.isNaN(yaw)) {
+            yaw = 0;
+        }
+
+        if (Float.isNaN(pitch)) {
+            pitch = 0;
+        }
+
+        this.bukkitLastPosX = x;
+        this.bukkitLastPosY = y;
+        this.bukkitLastPosZ = z;
+        this.lastYaw = yaw;
+        this.lastPitch = pitch;
+        this.justTeleported = true;
+        // CraftBukkit end
         this.hasMoved = false;
         this.lastPosX = x;
         this.lastPosY = y;
         this.lastPosZ = z;
 
-        if (relativeSet.contains(S08PacketPlayerPosLook.EnumFlags.X))
-        {
+        if (relativeSet.contains(S08PacketPlayerPosLook.EnumFlags.X)) {
             this.lastPosX += this.playerEntity.posX;
         }
 
-        if (relativeSet.contains(S08PacketPlayerPosLook.EnumFlags.Y))
-        {
+        if (relativeSet.contains(S08PacketPlayerPosLook.EnumFlags.Y)) {
             this.lastPosY += this.playerEntity.posY;
         }
 
-        if (relativeSet.contains(S08PacketPlayerPosLook.EnumFlags.Z))
-        {
+        if (relativeSet.contains(S08PacketPlayerPosLook.EnumFlags.Z)) {
             this.lastPosZ += this.playerEntity.posZ;
         }
 
         float f2 = yaw;
         float f3 = pitch;
 
-        if (relativeSet.contains(S08PacketPlayerPosLook.EnumFlags.Y_ROT))
-        {
+        if (relativeSet.contains(S08PacketPlayerPosLook.EnumFlags.Y_ROT)) {
             f2 = yaw + this.playerEntity.rotationYaw;
         }
 
-        if (relativeSet.contains(S08PacketPlayerPosLook.EnumFlags.X_ROT))
-        {
+        if (relativeSet.contains(S08PacketPlayerPosLook.EnumFlags.X_ROT)) {
             f3 = pitch + this.playerEntity.rotationPitch;
         }
 
         this.playerEntity.setPositionAndRotation(this.lastPosX, this.lastPosY, this.lastPosZ, f2, f3);
         this.playerEntity.playerNetServerHandler.sendPacket(new S08PacketPlayerPosLook(x, y, z, yaw, pitch, relativeSet));
     }
 
-    public void processPlayerDigging(C07PacketPlayerDigging packetIn)
-    {
+    public void processPlayerDigging(C07PacketPlayerDigging packetIn) {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
+        if (this.playerEntity.isDead) return; // CraftBukkit
         WorldServer worldserver = this.serverController.worldServerForDimension(this.playerEntity.dimension);
         BlockPos blockpos = packetIn.func_179715_a();
         this.playerEntity.markPlayerActive();
-
-        switch (NetHandlerPlayServer.SwitchAction.field_180224_a[packetIn.getStatus().ordinal()])
-        {
-            case 1:
-                if (!this.playerEntity.isSpectator())
-                {
+        // SpigotMCP -- Use enum instead of ordinal
+        // CraftBukkit start
+        switch (packetIn.getStatus()) {
+            case DROP_ITEM: // DROP_ITEM
+                if (!this.playerEntity.isSpectator()) {
+                    // limit how quickly items can be dropped
+                    // If the ticks aren't the same then the count starts from 0 and we update the lastDropTick.
+                    if (this.lastDropTick != MinecraftServer.currentTick) {
+                        this.dropCount = 0;
+                        this.lastDropTick = MinecraftServer.currentTick;
+                    } else {
+                        // Else we increment the drop count and check the amount.
+                        this.dropCount++;
+                        if (this.dropCount >= 20) {
+                            this.logger.warn(this.playerEntity.getName() + " dropped their items too quickly!");
+                            this.kickPlayerFromServer("You dropped your items too quickly (Hacking?)");
+                            return;
+                        }
+                    }
+                    // CraftBukkit end
                     this.playerEntity.dropOneItem(false);
                 }
 
                 return;
-            case 2:
-                if (!this.playerEntity.isSpectator())
-                {
+            case DROP_ALL_ITEMS: // DROP_ALL_ITEMS
+                if (!this.playerEntity.isSpectator()) {
                     this.playerEntity.dropOneItem(true);
                 }
 
                 return;
-            case 3:
+            case RELEASE_USE_ITEM: // RELEASE_USE_ITEM
                 this.playerEntity.stopUsingItem();
                 return;
-            case 4:
-            case 5:
-            case 6:
-                double d0 = this.playerEntity.posX - ((double)blockpos.getX() + 0.5D);
-                double d1 = this.playerEntity.posY - ((double)blockpos.getY() + 0.5D) + 1.5D;
-                double d2 = this.playerEntity.posZ - ((double)blockpos.getZ() + 0.5D);
+            case START_DESTROY_BLOCK: // START_DESTROY_BLOCK
+            case ABORT_DESTROY_BLOCK: // ABORT_DESTROY_BLOCK
+            case STOP_DESTROY_BLOCK: // STOP_DESTROY_BLOCK
+                double d0 = this.playerEntity.posX - ((double) blockpos.getX() + 0.5D);
+                double d1 = this.playerEntity.posY - ((double) blockpos.getY() + 0.5D) + 1.5D;
+                double d2 = this.playerEntity.posZ - ((double) blockpos.getZ() + 0.5D);
                 double d3 = d0 * d0 + d1 * d1 + d2 * d2;
 
-                if (d3 > 36.0D)
-                {
+                if (d3 > 36.0D) {
                     return;
-                }
-                else if (blockpos.getY() >= this.serverController.getBuildLimit())
-                {
+                } else if (blockpos.getY() >= this.serverController.getBuildLimit()) {
                     return;
-                }
-                else
-                {
-                    if (packetIn.getStatus() == C07PacketPlayerDigging.Action.START_DESTROY_BLOCK)
-                    {
-                        if (!this.serverController.isBlockProtected(worldserver, blockpos, this.playerEntity) && worldserver.getWorldBorder().contains(blockpos))
-                        {
+                } else {
+                    if (packetIn.getStatus() == C07PacketPlayerDigging.Action.START_DESTROY_BLOCK) {
+                        if (!this.serverController.isBlockProtected(worldserver, blockpos, this.playerEntity) && worldserver.getWorldBorder().contains(blockpos)) {
                             this.playerEntity.theItemInWorldManager.onBlockClicked(blockpos, packetIn.getFacing());
-                        }
-                        else
-                        {
+                        } else {
+                            // CraftBukkit start - fire PlayerInteractEvent
+                            CraftEventFactory.callPlayerInteractEvent(this.playerEntity, Action.LEFT_CLICK_BLOCK, blockpos, packetIn.getFacing(), this.playerEntity.inventory.getCurrentItem());
                             this.playerEntity.playerNetServerHandler.sendPacket(new S23PacketBlockChange(worldserver, blockpos));
+                            // Update any tile entity data for this block
+                            TileEntity tileentity = worldserver.getTileEntity(blockpos);
+                            if (tileentity != null) {
+                                this.playerEntity.playerNetServerHandler.sendPacket(tileentity.getDescriptionPacket());
+                            }
+                            // CraftBukkit end
                         }
-                    }
-                    else
-                    {
-                        if (packetIn.getStatus() == C07PacketPlayerDigging.Action.STOP_DESTROY_BLOCK)
-                        {
+                    } else {
+                        if (packetIn.getStatus() == C07PacketPlayerDigging.Action.STOP_DESTROY_BLOCK) {
                             this.playerEntity.theItemInWorldManager.blockRemoving(blockpos);
-                        }
-                        else if (packetIn.getStatus() == C07PacketPlayerDigging.Action.ABORT_DESTROY_BLOCK)
-                        {
+                        } else if (packetIn.getStatus() == C07PacketPlayerDigging.Action.ABORT_DESTROY_BLOCK) {
                             this.playerEntity.theItemInWorldManager.cancelDestroyingBlock();
                         }
 
-                        if (worldserver.getBlockState(blockpos).getBlock().getMaterial() != Material.air)
-                        {
+                        if (worldserver.getBlockState(blockpos).getBlock().getMaterial() != Material.air) {
                             this.playerEntity.playerNetServerHandler.sendPacket(new S23PacketBlockChange(worldserver, blockpos));
                         }
                     }
 
                     return;
                 }
             default:
                 throw new IllegalArgumentException("Invalid player action");
         }
+        // CraftBukkit end
     }
 
-    public void processPlayerBlockPlacement(C08PacketPlayerBlockPlacement packetIn)
-    {
+    // Spigot start - limit place/interactions
+    private long lastPlace = -1;
+    private int packets = 0;
+
+    public void processPlayerBlockPlacement(C08PacketPlayerBlockPlacement packetIn) {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
         WorldServer worldserver = this.serverController.worldServerForDimension(this.playerEntity.dimension);
+        boolean throttled = false;
+        if (lastPlace != -1 && packetIn.timestamp - lastPlace < 30 && packets++ >= 4) {
+            throttled = true;
+        } else if (packetIn.timestamp - lastPlace >= 30 || lastPlace == -1) {
+            lastPlace = packetIn.timestamp;
+            packets = 0;
+        }
+        // Spigot end
+
+        // CraftBukkit start
+        if (this.playerEntity.isDead) return;
+
+        // CraftBukkit - if rightclick decremented the item, always send the update packet. */
+        // this is not here for CraftBukkit's own functionality; rather it is to fix
+        // a notch bug where the item doesn't update correctly.
+        boolean always = false;
+        // CraftBukkit end
+
         ItemStack itemstack = this.playerEntity.inventory.getCurrentItem();
         boolean flag = false;
         BlockPos blockpos = packetIn.getPosition();
         EnumFacing enumfacing = EnumFacing.getFront(packetIn.getPlacedBlockDirection());
         this.playerEntity.markPlayerActive();
 
-        if (packetIn.getPlacedBlockDirection() == 255)
-        {
-            if (itemstack == null)
-            {
+        if (packetIn.getPlacedBlockDirection() == 255) {
+            if (itemstack == null) {
                 return;
             }
 
-            this.playerEntity.theItemInWorldManager.tryUseItem(this.playerEntity, worldserver, itemstack);
-        }
-        else if (blockpos.getY() >= this.serverController.getBuildLimit() - 1 && (enumfacing == EnumFacing.UP || blockpos.getY() >= this.serverController.getBuildLimit()))
-        {
-            ChatComponentTranslation chatcomponenttranslation = new ChatComponentTranslation("build.tooHigh", new Object[] {Integer.valueOf(this.serverController.getBuildLimit())});
+            // CraftBukkit start
+            int itemstackAmount = itemstack.stackSize;
+            // Spigot start - skip the event if throttled
+            if (!throttled) {
+                // Raytrace to look for 'rogue armswings'
+                float f1 = this.playerEntity.rotationPitch;
+                float f2 = this.playerEntity.rotationYaw;
+                double d0 = this.playerEntity.posX;
+                double d1 = this.playerEntity.posY + (double) this.playerEntity.getEyeHeight();
+                double d2 = this.playerEntity.posZ;
+                Vec3 vec3d = new Vec3(d0, d1, d2);
+
+                float f3 = MathHelper.cos(-f2 * 0.017453292F - 3.1415927F);
+                float f4 = MathHelper.sin(-f2 * 0.017453292F - 3.1415927F);
+                float f5 = -MathHelper.cos(-f1 * 0.017453292F);
+                float f6 = MathHelper.sin(-f1 * 0.017453292F);
+                float f7 = f4 * f5;
+                float f8 = f3 * f5;
+                double d3 = playerEntity.theItemInWorldManager.getGameType() == GameType.CREATIVE ? 5.0D : 4.5D;
+                Vec3 vec3d1 = vec3d.addVector((double) f7 * d3, (double) f6 * d3, (double) f8 * d3);
+                MovingObjectPosition movingobjectposition = this.playerEntity.worldObj.rayTraceBlocks(vec3d, vec3d1, false);
+
+                boolean cancelled = false;
+                if (movingobjectposition == null || movingobjectposition.typeOfHit != MovingObjectType.BLOCK) {
+                    org.bukkit.event.player.PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(this.playerEntity, Action.RIGHT_CLICK_AIR, itemstack);
+                    cancelled = event.useItemInHand() == Event.Result.DENY;
+                } else {
+                    if (playerEntity.theItemInWorldManager.firedInteract) {
+                        playerEntity.theItemInWorldManager.firedInteract = false;
+                        cancelled = playerEntity.theItemInWorldManager.interactResult;
+                    } else {
+                        org.bukkit.event.player.PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(playerEntity, Action.RIGHT_CLICK_BLOCK, movingobjectposition.getBlockPos(), movingobjectposition.sideHit, itemstack, true);
+                        cancelled = event.useItemInHand() == Event.Result.DENY;
+                    }
+                }
+
+                if (!cancelled) {
+                    this.playerEntity.theItemInWorldManager.tryUseItem(this.playerEntity, this.playerEntity.worldObj, itemstack);
+                }
+            }
+            // Spigot end
+
+            // CraftBukkit - notch decrements the counter by 1 in the above method with food,
+            // snowballs and so forth, but he does it in a place that doesn't cause the
+            // inventory update packet to get sent
+            always = (itemstack.stackSize != itemstackAmount) || itemstack.getItem() == Item.getItemFromBlock(Blocks.waterlily);
+            // CraftBukkit end
+        } else if (blockpos.getY() >= this.serverController.getBuildLimit() - 1 && (enumfacing == EnumFacing.UP || blockpos.getY() >= this.serverController.getBuildLimit())) {
+            ChatComponentTranslation chatcomponenttranslation = new ChatComponentTranslation("build.tooHigh", new Object[]{Integer.valueOf(this.serverController.getBuildLimit())});
             chatcomponenttranslation.getChatStyle().setColor(EnumChatFormatting.RED);
             this.playerEntity.playerNetServerHandler.sendPacket(new S02PacketChat(chatcomponenttranslation));
             flag = true;
-        }
-        else
-        {
-            if (this.hasMoved && this.playerEntity.getDistanceSq((double)blockpos.getX() + 0.5D, (double)blockpos.getY() + 0.5D, (double)blockpos.getZ() + 0.5D) < 64.0D && !this.serverController.isBlockProtected(worldserver, blockpos, this.playerEntity) && worldserver.getWorldBorder().contains(blockpos))
-            {
-                this.playerEntity.theItemInWorldManager.activateBlockOrUseItem(this.playerEntity, worldserver, itemstack, blockpos, enumfacing, packetIn.getPlacedBlockOffsetX(), packetIn.getPlacedBlockOffsetY(), packetIn.getPlacedBlockOffsetZ());
+        } else {
+            // CraftBukkit start - Check if we can actually do something over this large a distance
+            Location eyeLoc = this.getPlayer().getEyeLocation();
+            double reachDistance = NumberConversions.square(eyeLoc.getX() - blockpos.getX()) + NumberConversions.square(eyeLoc.getY() - blockpos.getY()) + NumberConversions.square(eyeLoc.getZ() - blockpos.getZ());
+            if (reachDistance > (this.getPlayer().getGameMode() == org.bukkit.GameMode.CREATIVE ? CREATIVE_PLACE_DISTANCE_SQUARED : SURVIVAL_PLACE_DISTANCE_SQUARED)) {
+                return;
             }
 
+            if (!worldserver.getWorldBorder().contains(blockpos)) {
+                return;
+            }
+
+            if (this.bukkitHasMoved && this.playerEntity.getDistanceSq((double) blockpos.getX() + 0.5D, (double) blockpos.getY() + 0.5D, (double) blockpos.getZ() + 0.5D) < 64.0D && !this.serverController.isBlockProtected(worldserver, blockpos, this.playerEntity) && worldserver.getWorldBorder().contains(blockpos)) {
+                always = throttled || !this.playerEntity.theItemInWorldManager.activateBlockOrUseItem(this.playerEntity, worldserver, itemstack, blockpos, enumfacing, packetIn.getPlacedBlockOffsetX(), packetIn.getPlacedBlockOffsetY(), packetIn.getPlacedBlockOffsetZ());
+            }
+            // CraftBukkit end
+
             flag = true;
         }
 
-        if (flag)
-        {
+        if (flag) {
             this.playerEntity.playerNetServerHandler.sendPacket(new S23PacketBlockChange(worldserver, blockpos));
             this.playerEntity.playerNetServerHandler.sendPacket(new S23PacketBlockChange(worldserver, blockpos.offset(enumfacing)));
         }
 
         itemstack = this.playerEntity.inventory.getCurrentItem();
 
-        if (itemstack != null && itemstack.stackSize == 0)
-        {
+        if (itemstack != null && itemstack.stackSize == 0) {
             this.playerEntity.inventory.mainInventory[this.playerEntity.inventory.currentItem] = null;
             itemstack = null;
         }
 
-        if (itemstack == null || itemstack.getMaxItemUseDuration() == 0)
-        {
+        if (itemstack == null || itemstack.getMaxItemUseDuration() == 0) {
             this.playerEntity.isChangingQuantityOnly = true;
             this.playerEntity.inventory.mainInventory[this.playerEntity.inventory.currentItem] = ItemStack.copyItemStack(this.playerEntity.inventory.mainInventory[this.playerEntity.inventory.currentItem]);
             Slot slot = this.playerEntity.openContainer.getSlotFromInventory(this.playerEntity.inventory, this.playerEntity.inventory.currentItem);
             this.playerEntity.openContainer.detectAndSendChanges();
             this.playerEntity.isChangingQuantityOnly = false;
 
-            if (!ItemStack.areItemStacksEqual(this.playerEntity.inventory.getCurrentItem(), packetIn.getStack()))
-            {
+            // CraftBukkit - TODO CHECK IF NEEDED -- new if structure might not need 'always'. Kept it in for now, but may be able to remove in future
+            if (always || !ItemStack.areItemStacksEqual(this.playerEntity.inventory.getCurrentItem(), packetIn.getStack())) { // SpigotMCP -- 'always' first for performance
                 this.sendPacket(new S2FPacketSetSlot(this.playerEntity.openContainer.windowId, slot.slotNumber, this.playerEntity.inventory.getCurrentItem()));
             }
         }
     }
 
-    public void handleSpectate(C18PacketSpectate packetIn)
-    {
+    public void handleSpectate(C18PacketSpectate packetIn) {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
 
-        if (this.playerEntity.isSpectator())
-        {
+        if (this.playerEntity.isSpectator()) {
             Entity entity = null;
             WorldServer[] aworldserver = this.serverController.worldServers;
             int i = aworldserver.length;
 
-            for (int j = 0; j < i; ++j)
-            {
-                WorldServer worldserver = aworldserver[j];
+            // CraftBukkit - use the worlds array list
+            for (WorldServer worldserver : serverController.worlds) {
 
-                if (worldserver != null)
-                {
+                if (worldserver != null) {
                     entity = packetIn.getEntity(worldserver);
 
-                    if (entity != null)
-                    {
+                    if (entity != null) {
                         break;
                     }
                 }
             }
 
-            if (entity != null)
-            {
+            if (entity != null) {
                 this.playerEntity.setSpectatingEntity(this.playerEntity);
-                this.playerEntity.mountEntity((Entity)null);
+                this.playerEntity.mountEntity((Entity) null);
 
-                if (entity.worldObj != this.playerEntity.worldObj)
-                {
+                /* CraftBukkit start - replace with bukkit handling for multi-world
+                if (entity.worldObj != this.playerEntity.worldObj) {
                     WorldServer worldserver1 = this.playerEntity.getServerForPlayer();
-                    WorldServer worldserver2 = (WorldServer)entity.worldObj;
+                    WorldServer worldserver2 = (WorldServer) entity.worldObj;
                     this.playerEntity.dimension = entity.dimension;
                     this.sendPacket(new S07PacketRespawn(this.playerEntity.dimension, worldserver1.getDifficulty(), worldserver1.getWorldInfo().getTerrainType(), this.playerEntity.theItemInWorldManager.getGameType()));
                     worldserver1.removePlayerEntityDangerously(this.playerEntity);
                     this.playerEntity.isDead = false;
                     this.playerEntity.setLocationAndAngles(entity.posX, entity.posY, entity.posZ, entity.rotationYaw, entity.rotationPitch);
 
-                    if (this.playerEntity.isEntityAlive())
-                    {
+                    if (this.playerEntity.isEntityAlive()) {
                         worldserver1.updateEntityWithOptionalForce(this.playerEntity, false);
                         worldserver2.spawnEntityInWorld(this.playerEntity);
                         worldserver2.updateEntityWithOptionalForce(this.playerEntity, false);
                     }
 
@@ -650,154 +926,405 @@
                     this.serverController.getConfigurationManager().func_72375_a(this.playerEntity, worldserver1);
                     this.playerEntity.setPositionAndUpdate(entity.posX, entity.posY, entity.posZ);
                     this.playerEntity.theItemInWorldManager.setWorld(worldserver2);
                     this.serverController.getConfigurationManager().updateTimeAndWeatherForPlayer(this.playerEntity, worldserver2);
                     this.serverController.getConfigurationManager().syncPlayerInventory(this.playerEntity);
-                }
-                else
-                {
+                } else {
                     this.playerEntity.setPositionAndUpdate(entity.posX, entity.posY, entity.posZ);
                 }
+                */
+                this.playerEntity.getBukkitEntity().teleport(entity.getBukkitEntity(), PlayerTeleportEvent.TeleportCause.SPECTATE);
+                // CraftBukkit end
             }
         }
     }
 
-    public void handleResourcePackStatus(C19PacketResourcePackStatus packetIn) {}
+    public void handleResourcePackStatus(C19PacketResourcePackStatus packetIn) {
+    }
 
-    public void onDisconnect(IChatComponent reason)
-    {
-        logger.info(this.playerEntity.getName() + " lost connection: " + reason);
+    public void onDisconnect(IChatComponent reason) {
+        // CraftBukkit start - Rarely it would send a disconnect line twice
+        if (this.processedDisconnect) {
+            return;
+        } else {
+            this.processedDisconnect = true;
+        }
+        // CraftBukkit end
+        logger.info(this.playerEntity.getName() + " lost connection: " + reason.getUnformattedText()); // CraftBukkit - Don't toString the component
         this.serverController.refreshStatusNextTick();
-        ChatComponentTranslation chatcomponenttranslation = new ChatComponentTranslation("multiplayer.player.left", new Object[] {this.playerEntity.getDisplayName()});
+        // CraftBukkit start - Replace vanilla quit message handling with our own.
+        /*
+        ChatComponentTranslation chatcomponenttranslation = new ChatComponentTranslation("multiplayer.player.left", new Object[]{this.playerEntity.getDisplayName()});
         chatcomponenttranslation.getChatStyle().setColor(EnumChatFormatting.YELLOW);
         this.serverController.getConfigurationManager().sendChatMsg(chatcomponenttranslation);
+        */
+
         this.playerEntity.mountEntityAndWakeUp();
-        this.serverController.getConfigurationManager().playerLoggedOut(this.playerEntity);
+        String quitMessage = this.serverController.getConfigurationManager().playerLoggedOut(this.playerEntity);
+        if ((quitMessage != null) && (quitMessage.length() > 0)) {
+            this.serverController.getConfigurationManager().sendMessage(CraftChatMessage.fromString(quitMessage));
+        }
+        // CraftBukkit end
 
-        if (this.serverController.isSinglePlayer() && this.playerEntity.getName().equals(this.serverController.getServerOwner()))
-        {
+        if (this.serverController.isSinglePlayer() && this.playerEntity.getName().equals(this.serverController.getServerOwner())) {
             logger.info("Stopping singleplayer server as player logged out");
             this.serverController.initiateShutdown();
         }
     }
 
-    public void sendPacket(final Packet packetIn)
-    {
-        if (packetIn instanceof S02PacketChat)
-        {
-            S02PacketChat s02packetchat = (S02PacketChat)packetIn;
+    public void sendPacket(final Packet packetIn) {
+        if (packetIn instanceof S02PacketChat) {
+            S02PacketChat s02packetchat = (S02PacketChat) packetIn;
             EntityPlayer.EnumChatVisibility enumchatvisibility = this.playerEntity.getChatVisibility();
 
-            if (enumchatvisibility == EntityPlayer.EnumChatVisibility.HIDDEN)
-            {
+            if (enumchatvisibility == EntityPlayer.EnumChatVisibility.HIDDEN) {
                 return;
             }
 
-            if (enumchatvisibility == EntityPlayer.EnumChatVisibility.SYSTEM && !s02packetchat.isChat())
-            {
+            if (enumchatvisibility == EntityPlayer.EnumChatVisibility.SYSTEM && !s02packetchat.isChat()) {
                 return;
             }
         }
 
-        try
-        {
-            this.netManager.sendPacket(packetIn);
+        // CraftBukkit start
+        if (packetIn == null) {
+            return;
+        } else if (packetIn instanceof S05PacketSpawnPosition) {
+            S05PacketSpawnPosition packet6 = (S05PacketSpawnPosition) packetIn;
+            this.playerEntity.compassTarget = new Location(this.getPlayer().getWorld(), packet6.field_179801_a.getX(), packet6.field_179801_a.getY(), packet6.field_179801_a.getZ());
         }
-        catch (Throwable throwable)
-        {
+        // CraftBukkit end
+
+        try {
+            this.netManager.sendPacket(packetIn);
+        } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Sending packet");
             CrashReportCategory crashreportcategory = crashreport.makeCategory("Packet being sent");
-            crashreportcategory.addCrashSectionCallable("Packet class", new Callable()
-            {
+            crashreportcategory.addCrashSectionCallable("Packet class", new Callable() {
+
                 private static final String __OBFID = "CL_00002270";
-                public String call()
-                {
+
+                public String call() {
                     return packetIn.getClass().getCanonicalName();
                 }
             });
             throw new ReportedException(crashreport);
         }
     }
 
-    public void processHeldItemChange(C09PacketHeldItemChange packetIn)
-    {
+    public void processHeldItemChange(C09PacketHeldItemChange packetIn) {
+        // CraftBukkit start
+        if (this.playerEntity.isDead) return;
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
-
-        if (packetIn.getSlotId() >= 0 && packetIn.getSlotId() < InventoryPlayer.getHotbarSize())
-        {
+        if (packetIn.getSlotId() >= 0 && packetIn.getSlotId() < InventoryPlayer .getHotbarSize()) {
+            PlayerItemHeldEvent event = new PlayerItemHeldEvent(this.getPlayer(), this.playerEntity.inventory.currentItem, packetIn.getSlotId());
+            this.server.getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                this.sendPacket(new S09PacketHeldItemChange(this.playerEntity.inventory.currentItem));
+                this.playerEntity.markPlayerActive(); // RENAME
+                return;
+            }
+            // CraftBukkit end
             this.playerEntity.inventory.currentItem = packetIn.getSlotId();
             this.playerEntity.markPlayerActive();
-        }
-        else
-        {
+        } else {
             logger.warn(this.playerEntity.getName() + " tried to set an invalid carried item");
+            this.kickPlayerFromServer("Invalid hotbar selection (Hacking?)"); // CraftBukkit //Spigot "Nope" -> Descriptive reason
         }
     }
 
-    public void processChatMessage(C01PacketChatMessage packetIn)
-    {
-        PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
+    public void processChatMessage(C01PacketChatMessage packetIn) {
+        // CraftBukkit start - async chat
+        boolean isSync = packetIn.getMessage().startsWith("/");
+        if (packetIn.getMessage().startsWith("/")) {
+            PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
+        }
+        // CraftBukkit end
 
-        if (this.playerEntity.getChatVisibility() == EntityPlayer.EnumChatVisibility.HIDDEN)
-        {
+        if (this.playerEntity.isDead || this.playerEntity.getChatVisibility() == EntityPlayer.EnumChatVisibility.HIDDEN) { // CraftBukkit - dead men tell no tales
             ChatComponentTranslation chatcomponenttranslation = new ChatComponentTranslation("chat.cannotSend", new Object[0]);
             chatcomponenttranslation.getChatStyle().setColor(EnumChatFormatting.RED);
             this.sendPacket(new S02PacketChat(chatcomponenttranslation));
-        }
-        else
-        {
+        } else {
             this.playerEntity.markPlayerActive();
             String s = packetIn.getMessage();
             s = StringUtils.normalizeSpace(s);
 
-            for (int i = 0; i < s.length(); ++i)
-            {
-                if (!ChatAllowedCharacters.isAllowedCharacter(s.charAt(i)))
-                {
-                    this.kickPlayerFromServer("Illegal characters in chat");
+            for (int i = 0; i < s.length(); ++i) {
+                if (!ChatAllowedCharacters.isAllowedCharacter(s.charAt(i))) {
+                    // CraftBukkit start - threadsafety
+                    if (!isSync) {
+                        Waitable waitable = new Waitable() {
+
+                            @Override
+                            protected java.lang.Object evaluate() {
+                                NetHandlerPlayServer.this.kickPlayerFromServer("Illegal characters in chat");
+                                return null;
+                            }
+                        };
+
+                        this.serverController.processQueue.add(waitable);
+
+                        try {
+                            waitable.get();
+                        } catch (InterruptedException e) {
+                            Thread.currentThread().interrupt();
+                        } catch (ExecutionException e) {
+                            throw new RuntimeException(e);
+                        }
+                    } else {
+                        this.kickPlayerFromServer("Illegal characters in chat");
+                    }
+                    // CraftBukkit end
                     return;
                 }
             }
 
-            if (s.startsWith("/"))
-            {
-                this.handleSlashCommand(s);
-            }
-            else
-            {
-                ChatComponentTranslation chatcomponenttranslation1 = new ChatComponentTranslation("chat.type.text", new Object[] {this.playerEntity.getDisplayName(), s});
+            // CraftBukkit start
+            if (isSync) {
+                try {
+                    this.serverController.server.playerCommandState = true;
+                    this.handleSlashCommand(s);
+                } finally {
+                    this.serverController.server.playerCommandState = false;
+                }
+            } else if (s.isEmpty()) {
+                logger.warn(this.playerEntity.getName() + " tried to send an empty message");
+            } else if (getPlayer().isConversing()) {
+                // Spigot start
+                final String message = s;
+                this.serverController.processQueue.add(new Waitable() {
+
+                    @Override
+                    protected java.lang.Object evaluate() {
+                        getPlayer().acceptConversationInput(message);
+                        return null;
+                    }
+                });
+                // Spigot end
+            } else if (this.playerEntity.getChatVisibility() == EnumChatVisibility.SYSTEM) { // Re-add "Command Only" flag check
+                ChatComponentTranslation chatmessage = new ChatComponentTranslation("chat.cannotSend", new Object[0]);
+
+                chatmessage.getChatStyle().setColor(EnumChatFormatting.RED);
+                this.sendPacket(new S02PacketChat(chatmessage));
+            } else if (true) {
+                this.chat(s, true);
+                // CraftBukkit end - the below is for reference. :) else {
+                ChatComponentTranslation chatcomponenttranslation1 = new ChatComponentTranslation("chat.type.text", new Object[]{this.playerEntity.getDisplayName(), s});
                 this.serverController.getConfigurationManager().sendChatMsgImpl(chatcomponenttranslation1, false);
             }
 
-            this.chatSpamThresholdCount += 20;
+            // Spigot start - spam exclusions
+            boolean counted = true;
+            for (String exclude : org.spigotmc.SpigotConfig.spamExclusions) {
+                if (exclude != null && s.startsWith(exclude)) {
+                    counted = false;
+                    break;
+                }
+            }
+            // CraftBukkit start - replaced with thread safe throttle
+            // this.chatSpamThresholdCount += 20;
+            if (counted && chatSpamField.addAndGet(this, 20) > 200 && !this.serverController.getConfigurationManager().canSendCommands(this.playerEntity.getGameProfile())) { // Spigot
+                if (!isSync) {
+                    Waitable waitable = new Waitable() {
 
-            if (this.chatSpamThresholdCount > 200 && !this.serverController.getConfigurationManager().canSendCommands(this.playerEntity.getGameProfile()))
-            {
-                this.kickPlayerFromServer("disconnect.spam");
+                        @Override
+                        protected java.lang.Object evaluate() {
+                            NetHandlerPlayServer.this.kickPlayerFromServer("disconnect.spam");
+                            return null;
+                        }
+                    };
+
+                    this.serverController.processQueue.add(waitable);
+
+                    try {
+                        waitable.get();
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                    } catch (ExecutionException e) {
+                        throw new RuntimeException(e);
+                    }
+                } else {
+                    this.kickPlayerFromServer("disconnect.spam");
+                }
+                // CraftBukkit end
             }
         }
     }
 
-    private void handleSlashCommand(String command)
-    {
-        this.serverController.getCommandManager().executeCommand(this.playerEntity, command);
+    // CraftBukkit start - add method
+    public void chat(String s, boolean async) {
+        if (s.isEmpty() || this.playerEntity.getChatVisibility() == EnumChatVisibility.HIDDEN) {
+            return;
+        }
+
+        if (!async && s.startsWith("/")) {
+            this.handleSlashCommand(s);
+        } else if (this.playerEntity.getChatVisibility() == EnumChatVisibility.SYSTEM) {
+            // Do nothing, this is coming from a plugin
+        } else {
+            Player player = this.getPlayer();
+            AsyncPlayerChatEvent event = new AsyncPlayerChatEvent(async, player, s, new LazyPlayerSet());
+            this.server.getPluginManager().callEvent(event);
+
+            if (PlayerChatEvent.getHandlerList().getRegisteredListeners().length != 0) {
+                // Evil plugins still listening to deprecated event
+                final PlayerChatEvent queueEvent = new PlayerChatEvent(player, event.getMessage(), event.getFormat(), event.getRecipients());
+                queueEvent.setCancelled(event.isCancelled());
+                Waitable waitable = new Waitable() {
+
+                    @Override
+                    protected java.lang.Object evaluate() {
+                        org.bukkit.Bukkit.getPluginManager().callEvent(queueEvent);
+
+                        if (queueEvent.isCancelled()) {
+                            return null;
+                        }
+
+                        String message = String.format(queueEvent.getFormat(), queueEvent.getPlayer().getDisplayName(), queueEvent.getMessage());
+                        NetHandlerPlayServer.this.serverController.console.sendMessage(message);
+                        if (((LazyPlayerSet) queueEvent.getRecipients()).isLazy()) {
+                            for (Object player : NetHandlerPlayServer.this.serverController.getConfigurationManager().playerEntityList) {
+                                ((EntityPlayerMP) player).sendMessage(CraftChatMessage.fromString(message));
+                            }
+                        } else {
+                            for (Player player : queueEvent.getRecipients()) {
+                                player.sendMessage(message);
+                            }
+                        }
+                        return null;
+                    }
+                };
+                if (async) {
+                    serverController.processQueue.add(waitable);
+                } else {
+                    waitable.run();
+                }
+                try {
+                    waitable.get();
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt(); // This is proper habit for java. If we aren't handling it, pass it on!
+                } catch (ExecutionException e) {
+                    throw new RuntimeException("Exception processing chat event", e.getCause());
+                }
+            } else {
+                if (event.isCancelled()) {
+                    return;
+                }
+
+                s = String.format(event.getFormat(), event.getPlayer().getDisplayName(), event.getMessage());
+                serverController.console.sendMessage(s);
+                if (((LazyPlayerSet) event.getRecipients()).isLazy()) {
+                    for (Object recipient : serverController.getConfigurationManager().playerEntityList) {
+                        ((EntityPlayerMP) recipient).sendMessage(CraftChatMessage.fromString(s));
+                    }
+                } else {
+                    for (Player recipient : event.getRecipients()) {
+                        recipient.sendMessage(s);
+                    }
+                }
+            }
+        }
     }
+    // CraftBukkit end
 
-    public void handleAnimation(C0APacketAnimation packetIn)
-    {
+    private void handleSlashCommand(String command) {
+        SpigotTimings.playerCommandTimer.startTiming(); // Spigot
+
+        // CraftBukkit start - whole method
+        if (org.spigotmc.SpigotConfig.logCommands) // Spigot
+            this.logger.info(this.playerEntity.getName() + " issued server command: " + command);
+
+        CraftPlayer player = this.getPlayer();
+
+        PlayerCommandPreprocessEvent event = new PlayerCommandPreprocessEvent(player, command, new LazyPlayerSet());
+        this.server.getPluginManager().callEvent(event);
+
+        if (event.isCancelled()) {
+            SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
+            return;
+        }
+
+        try {
+            if (this.server.dispatchCommand(event.getPlayer(), event.getMessage().substring(1))) {
+                SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
+                return;
+            }
+        } catch (CommandException ex) {
+            player.sendMessage(org.bukkit.ChatColor.RED + "An internal error occurred while attempting to perform this command");
+            java.util.logging.Logger.getLogger(net.minecraft.network.NetHandlerPlayServer.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
+            org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
+            return;
+        }
+        org.bukkit.craftbukkit.SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
+        // this.minecraftServer.getCommandHandler().a(this.player, s);
+        // CraftBukkit end
+    }
+
+    public void handleAnimation(C0APacketAnimation packetIn) {
+        if (this.playerEntity.isDead) return; // CraftBukkit
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
         this.playerEntity.markPlayerActive();
+        // CraftBukkit start - Raytrace to look for 'rogue armswings'
+        float f1 = this.playerEntity.rotationPitch;
+        float f2 = this.playerEntity.rotationYaw;
+        double d0 = this.playerEntity.posX;
+        double d1 = this.playerEntity.posY + (double) this.playerEntity.getEyeHeight();
+        double d2 = this.playerEntity.posZ;
+        Vec3 vec3d = new Vec3(d0, d1, d2);
+
+        float f3 = MathHelper.cos(-f2 * 0.017453292F - 3.1415927F);
+        float f4 = MathHelper.sin(-f2 * 0.017453292F - 3.1415927F);
+        float f5 = -MathHelper.cos(-f1 * 0.017453292F);
+        float f6 = MathHelper.sin(-f1 * 0.017453292F);
+        float f7 = f4 * f5;
+        float f8 = f3 * f5;
+        double d3 = playerEntity.theItemInWorldManager.getGameType() == GameType.CREATIVE ? 5.0D : 4.5D;
+        Vec3 vec3d1 = vec3d.addVector((double) f7 * d3, (double) f6 * d3, (double) f8 * d3);
+        MovingObjectPosition movingobjectposition = this.playerEntity.worldObj.rayTraceBlocks(vec3d, vec3d1, false);
+
+        if (movingobjectposition == null || movingobjectposition.typeOfHit != MovingObjectType.BLOCK) {
+            CraftEventFactory.callPlayerInteractEvent(this.playerEntity, Action.LEFT_CLICK_AIR, this.playerEntity.inventory.getCurrentItem());
+        }
+
+        // Arm swing animation
+        PlayerAnimationEvent event = new PlayerAnimationEvent(this.getPlayer());
+        this.server.getPluginManager().callEvent(event);
+
+        if (event.isCancelled()) return;
+        // CraftBukkit end
         this.playerEntity.swingItem();
     }
 
-    public void processEntityAction(C0BPacketEntityAction packetIn)
-    {
+    public void processEntityAction(C0BPacketEntityAction packetIn) {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
+        // CraftBukkit start
+        if (this.playerEntity.isDead) return;
+        switch (packetIn.getAction()) {
+            case START_SNEAKING:
+            case STOP_SNEAKING:
+                PlayerToggleSneakEvent event = new PlayerToggleSneakEvent(this.getPlayer(), packetIn.getAction() == C0BPacketEntityAction.Action.START_SNEAKING);
+                this.server.getPluginManager().callEvent(event);
+
+                if (event.isCancelled()) {
+                    return;
+                }
+                break;
+            case START_SPRINTING:
+            case STOP_SPRINTING:
+                PlayerToggleSprintEvent e2 = new PlayerToggleSprintEvent(this.getPlayer(), packetIn.getAction() == C0BPacketEntityAction.Action.START_SPRINTING);
+                this.server.getPluginManager().callEvent(e2);
+
+                if (e2.isCancelled()) {
+                    return;
+                }
+                break;
+        }
+        // CraftBukkit end
         this.playerEntity.markPlayerActive();
 
-        switch (NetHandlerPlayServer.SwitchAction.field_180222_b[packetIn.getAction().ordinal()])
-        {
+        switch (NetHandlerPlayServer.SwitchAction.field_180222_b[packetIn.getAction().ordinal()]) {
             case 1:
                 this.playerEntity.setSneaking(true);
                 break;
             case 2:
                 this.playerEntity.setSneaking(false);
@@ -808,104 +1335,145 @@
             case 4:
                 this.playerEntity.setSprinting(false);
                 break;
             case 5:
                 this.playerEntity.wakeUpPlayer(false, true, true);
-                this.hasMoved = false;
+                // this.hasMoved = false; // CraftBukkit - this is handled in teleport
                 break;
             case 6:
-                if (this.playerEntity.ridingEntity instanceof EntityHorse)
-                {
-                    ((EntityHorse)this.playerEntity.ridingEntity).setJumpPower(packetIn.getAuxData());
+                if (this.playerEntity.ridingEntity instanceof EntityHorse) {
+                    ((EntityHorse) this.playerEntity.ridingEntity).setJumpPower(packetIn.getAuxData());
                 }
 
                 break;
             case 7:
-                if (this.playerEntity.ridingEntity instanceof EntityHorse)
-                {
-                    ((EntityHorse)this.playerEntity.ridingEntity).openGUI(this.playerEntity);
+                if (this.playerEntity.ridingEntity instanceof EntityHorse) {
+                    ((EntityHorse) this.playerEntity.ridingEntity).openGUI(this.playerEntity);
                 }
 
                 break;
             default:
                 throw new IllegalArgumentException("Invalid client command!");
         }
     }
 
-    public void processUseEntity(C02PacketUseEntity packetIn)
-    {
+    public void processUseEntity(C02PacketUseEntity packetIn) {
+        if (this.playerEntity.isDead) return; // CraftBukkit
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
         WorldServer worldserver = this.serverController.worldServerForDimension(this.playerEntity.dimension);
         Entity entity = packetIn.getEntityFromWorld(worldserver);
+        // Spigot Start
+        if (entity == playerEntity && !playerEntity.isSpectator()) // RENAME
+        {
+            kickPlayerFromServer("Cannot interact with self!");
+            return;
+        }
+        // Spigot End
+
         this.playerEntity.markPlayerActive();
 
-        if (entity != null)
-        {
+        if (entity != null) {
             boolean flag = this.playerEntity.canEntityBeSeen(entity);
             double d0 = 36.0D;
 
-            if (!flag)
-            {
+            if (!flag) {
                 d0 = 9.0D;
             }
 
-            if (this.playerEntity.getDistanceSqToEntity(entity) < d0)
-            {
-                if (packetIn.getAction() == C02PacketUseEntity.Action.INTERACT)
-                {
-                    this.playerEntity.interactWith(entity);
+            if (this.playerEntity.getDistanceSqToEntity(entity) < d0) {
+                // CraftBukkit start
+                ItemStack itemInHand = this.playerEntity.inventory.getCurrentItem();
+                if (packetIn.getAction() == C02PacketUseEntity.Action.INTERACT || packetIn.getAction() == C02PacketUseEntity.Action.INTERACT_AT) {
+                    boolean triggerTagUpdate = itemInHand != null && itemInHand.getItem() == Items.name_tag && entity instanceof EntityLiving;
+                    boolean triggerChestUpdate = itemInHand != null && itemInHand.getItem() == Item.getItemFromBlock(Blocks.chest) && entity instanceof EntityHorse;
+                    boolean triggerLeashUpdate = itemInHand != null && itemInHand.getItem() == Items.lead && entity instanceof EntityLiving;
+                    PlayerInteractEntityEvent event;
+                    if (packetIn.getAction() == C02PacketUseEntity.Action.INTERACT) {
+                        event = new PlayerInteractEntityEvent((Player) this.getPlayer(), entity.getBukkitEntity());
+                    } else {
+                        Vec3 target = packetIn.getHitVec();
+                        event = new PlayerInteractAtEntityEvent((Player) this.getPlayer(), entity.getBukkitEntity(), new Vector(target.xCoord, target.yCoord, target.zCoord));
+                    }
+                    this.server.getPluginManager().callEvent(event);
+
+                    if (triggerLeashUpdate && (event.isCancelled() || this.playerEntity.inventory.getCurrentItem() == null || this.playerEntity.inventory.getCurrentItem().getItem() != Items.lead)) {
+                        // Refresh the current leash state
+                        this.sendPacket(new S1BPacketEntityAttach(1, entity, ((EntityLiving) entity).getLeashedToEntity()));
+                    }
+
+                    if (triggerTagUpdate && (event.isCancelled() || this.playerEntity.inventory.getCurrentItem() == null || this.playerEntity.inventory.getCurrentItem().getItem() != Items.name_tag)) {
+                        // Refresh the current entity metadata
+                        this.sendPacket(new S1CPacketEntityMetadata(entity.getEntityId(), entity.dataWatcher, true));
+                    }
+                    if (triggerChestUpdate && (event.isCancelled() || this.playerEntity.inventory.getCurrentItem() == null || this.playerEntity.inventory.getCurrentItem().getItem() != Item.getItemFromBlock(Blocks.chest))) {
+                        this.sendPacket(new S1CPacketEntityMetadata(entity.getEntityId(), entity.dataWatcher, true));
+                    }
+
+                    if (event.isCancelled()) {
+                        return;
+                    }
                 }
-                else if (packetIn.getAction() == C02PacketUseEntity.Action.INTERACT_AT)
-                {
+                // CraftBukkit end
+
+                if (packetIn.getAction() == C02PacketUseEntity.Action.INTERACT) {
+                    this.playerEntity.interactWith(entity);
+
+                    // CraftBukkit start
+                    if (itemInHand != null && itemInHand.stackSize <= -1) {
+                        this.playerEntity.sendContainerToPlayer(this.playerEntity.openContainer);
+                    }
+                    // CraftBukkit end
+                } else if (packetIn.getAction() == C02PacketUseEntity.Action.INTERACT_AT) {
                     entity.func_174825_a(this.playerEntity, packetIn.getHitVec());
-                }
-                else if (packetIn.getAction() == C02PacketUseEntity.Action.ATTACK)
-                {
-                    if (entity instanceof EntityItem || entity instanceof EntityXPOrb || entity instanceof EntityArrow || entity == this.playerEntity)
-                    {
+
+                    // CraftBukkit start
+                    if (itemInHand != null && itemInHand.stackSize <= -1) {
+                        this.playerEntity.sendContainerToPlayer(this.playerEntity.openContainer);
+                    }
+                    // CraftBukkit end
+                } else if (packetIn.getAction() == C02PacketUseEntity.Action.ATTACK) {
+                    if (entity instanceof EntityItem || entity instanceof EntityXPOrb || entity instanceof EntityArrow || entity == this.playerEntity) {
                         this.kickPlayerFromServer("Attempting to attack an invalid entity");
                         this.serverController.logWarning("Player " + this.playerEntity.getName() + " tried to attack an invalid entity");
                         return;
                     }
 
                     this.playerEntity.attackTargetEntityWithCurrentItem(entity);
+
+                    // CraftBukkit start
+                    if (itemInHand != null && itemInHand.stackSize <= -1) {
+                        this.playerEntity.sendContainerToPlayer(this.playerEntity.openContainer);
+                    }
+                    // CraftBukkit end
                 }
             }
         }
     }
 
-    public void processClientStatus(C16PacketClientStatus packetIn)
-    {
+    public void processClientStatus(C16PacketClientStatus packetIn) {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
         this.playerEntity.markPlayerActive();
         C16PacketClientStatus.EnumState enumstate = packetIn.getStatus();
 
-        switch (NetHandlerPlayServer.SwitchAction.field_180223_c[enumstate.ordinal()])
-        {
+        switch (NetHandlerPlayServer.SwitchAction.field_180223_c[enumstate.ordinal()]) {
             case 1:
-                if (this.playerEntity.playerConqueredTheEnd)
-                {
-                    this.playerEntity = this.serverController.getConfigurationManager().recreatePlayerEntity(this.playerEntity, 0, true);
-                }
-                else if (this.playerEntity.getServerForPlayer().getWorldInfo().isHardcoreModeEnabled())
-                {
-                    if (this.serverController.isSinglePlayer() && this.playerEntity.getName().equals(this.serverController.getServerOwner()))
-                    {
+                if (this.playerEntity.playerConqueredTheEnd) {
+                    // CraftBukkit Start - reroute logic through custom portal management
+                    // this.player = this.minecraftServer.getPlayerList().moveToWorld(this.player, 0, true);
+                    this.serverController.getConfigurationManager().changeDimension(this.playerEntity, 0, PlayerTeleportEvent.TeleportCause.END_PORTAL);
+                    // CraftBukkit end
+                } else if (this.playerEntity.getServerForPlayer().getWorldInfo().isHardcoreModeEnabled()) {
+                    if (this.serverController.isSinglePlayer() && this.playerEntity.getName().equals(this.serverController.getServerOwner())) {
                         this.playerEntity.playerNetServerHandler.kickPlayerFromServer("You have died. Game over, man, it\'s game over!");
                         this.serverController.deleteWorldAndStopServer();
-                    }
-                    else
-                    {
-                        UserListBansEntry userlistbansentry = new UserListBansEntry(this.playerEntity.getGameProfile(), (Date)null, "(You just lost the game)", (Date)null, "Death in Hardcore");
+                    } else {
+                        UserListBansEntry userlistbansentry = new UserListBansEntry(this.playerEntity.getGameProfile(), (Date) null, "(You just lost the game)", (Date) null, "Death in Hardcore");
                         this.serverController.getConfigurationManager().getBannedPlayers().addEntry(userlistbansentry);
                         this.playerEntity.playerNetServerHandler.kickPlayerFromServer("You have died. Game over, man, it\'s game over!");
                     }
-                }
-                else
-                {
-                    if (this.playerEntity.getHealth() > 0.0F)
-                    {
+                } else {
+                    if (this.playerEntity.getHealth() > 0.0F) {
                         return;
                     }
 
                     this.playerEntity = this.serverController.getConfigurationManager().recreatePlayerEntity(this.playerEntity, 0, false);
                 }
@@ -917,96 +1485,348 @@
             case 3:
                 this.playerEntity.triggerAchievement(AchievementList.openInventory);
         }
     }
 
-    public void processCloseWindow(C0DPacketCloseWindow packetIn)
-    {
+    public void processCloseWindow(C0DPacketCloseWindow packetIn) {
+        if (this.playerEntity.isDead) return; // CraftBukkit
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
+
+        CraftEventFactory.handleInventoryCloseEvent(this.playerEntity); // CraftBukkit
+
         this.playerEntity.closeContainer();
     }
 
-    public void processClickWindow(C0EPacketClickWindow packetIn)
-    {
+    public void processClickWindow(C0EPacketClickWindow packetIn) {
+        if (this.playerEntity.isDead) return; // CraftBukkit
+
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
         this.playerEntity.markPlayerActive();
 
-        if (this.playerEntity.openContainer.windowId == packetIn.getWindowId() && this.playerEntity.openContainer.isPlayerNotUsingContainer(this.playerEntity))
-        {
-            if (this.playerEntity.isSpectator())
-            {
+        if (this.playerEntity.openContainer.windowId == packetIn.getWindowId() && this.playerEntity.openContainer.isPlayerNotUsingContainer(this.playerEntity)) {
+            boolean cancelled = this.playerEntity.isSpectator(); // CraftBukkit - see below if
+            if (false) { // CraftBukkit this.player.v()) {
                 ArrayList arraylist = Lists.newArrayList();
 
-                for (int i = 0; i < this.playerEntity.openContainer.inventorySlots.size(); ++i)
-                {
-                    arraylist.add(((Slot)this.playerEntity.openContainer.inventorySlots.get(i)).getStack());
+                for (int i = 0; i < this.playerEntity.openContainer.inventorySlots.size(); ++i) {
+                    arraylist.add(((Slot) this.playerEntity.openContainer.inventorySlots.get(i)).getStack());
                 }
 
                 this.playerEntity.sendContainerAndContentsToPlayer(this.playerEntity.openContainer, arraylist);
-            }
-            else
-            {
-                ItemStack itemstack = this.playerEntity.openContainer.slotClick(packetIn.getSlotId(), packetIn.getUsedButton(), packetIn.getMode(), this.playerEntity);
+            } else {
+                // CraftBukkit start - Call InventoryClickEvent
+                // ItemStack itemstack = this.playerEntity.openContainer.slotClick(packetIn.getSlotId(), packetIn.getUsedButton(), packetIn.getMode(), this.playerEntity);
+                if (packetIn.getSlotId() < -1 && packetIn.getSlotId() != -999) {
+                    return;
+                }
 
-                if (ItemStack.areItemStacksEqual(packetIn.getClickedItem(), itemstack))
-                {
+                InventoryView inventory = this.playerEntity.openContainer.getBukkitView();
+                SlotType type = CraftInventoryView.getSlotType(inventory, packetIn.getSlotId());
+
+                InventoryClickEvent event = null;
+                ClickType click = ClickType.UNKNOWN;
+                InventoryAction action = InventoryAction.UNKNOWN;
+
+                ItemStack itemstack = null;
+
+                if (packetIn.getSlotId() == -1) {
+                    type = SlotType.OUTSIDE; // override
+                    click = packetIn.getUsedButton() == 0 ? ClickType.WINDOW_BORDER_LEFT : ClickType.WINDOW_BORDER_RIGHT;
+                    action = InventoryAction.NOTHING;
+                } else if (packetIn.getMode() == 0) {
+                    if (packetIn.getUsedButton() == 0) {
+                        click = ClickType.LEFT;
+                    } else if (packetIn.getUsedButton() == 1) {
+                        click = ClickType.RIGHT;
+                    }
+                    if (packetIn.getUsedButton() == 0 || packetIn.getUsedButton() == 1) {
+                        action = InventoryAction.NOTHING; // Don't want to repeat ourselves
+                        if (packetIn.getSlotId() == -999) {
+                            if (playerEntity.inventory.getItemStack() != null) {
+                                action = packetIn.getUsedButton() == 0 ? InventoryAction.DROP_ALL_CURSOR : InventoryAction.DROP_ONE_CURSOR;
+                            }
+                        } else {
+                            Slot slot = this.playerEntity.openContainer.getSlot(packetIn.getSlotId());
+                            if (slot != null) {
+                                ItemStack clickedItem = slot.getStack();
+                                ItemStack cursor = playerEntity.inventory.getItemStack();
+                                if (clickedItem == null) {
+                                    if (cursor != null) {
+                                        action = packetIn.getUsedButton() == 0 ? InventoryAction.PLACE_ALL : InventoryAction.PLACE_ONE;
+                                    }
+                                } else if (slot.canTakeStack(playerEntity)) {
+                                    if (cursor == null) {
+                                        action = packetIn.getUsedButton() == 0 ? InventoryAction.PICKUP_ALL : InventoryAction.PICKUP_HALF;
+                                    } else if (slot.isItemValid(cursor)) {
+                                        if (clickedItem.isItemEqual(cursor) && ItemStack.areItemStackTagsEqual(clickedItem, cursor)) {
+                                            int toPlace = packetIn.getUsedButton() == 0 ? cursor.stackSize : 1;
+                                            toPlace = Math.min(toPlace, clickedItem.getMaxStackSize() - clickedItem.stackSize);
+                                            toPlace = Math.min(toPlace, slot.inventory.getInventoryStackLimit() - clickedItem.stackSize);
+                                            if (toPlace == 1) {
+                                                action = InventoryAction.PLACE_ONE;
+                                            } else if (toPlace == cursor.stackSize) {
+                                                action = InventoryAction.PLACE_ALL;
+                                            } else if (toPlace < 0) {
+                                                action = toPlace != -1 ? InventoryAction.PICKUP_SOME : InventoryAction.PICKUP_ONE; // this happens with oversized stacks
+                                            } else if (toPlace != 0) {
+                                                action = InventoryAction.PLACE_SOME;
+                                            }
+                                        } else if (cursor.stackSize <= slot.getSlotStackLimit()) {
+                                            action = InventoryAction.SWAP_WITH_CURSOR;
+                                        }
+                                    } else if (cursor.getItem() == clickedItem.getItem() && (!cursor.getHasSubtypes() || cursor.getMetadata() == clickedItem.getMetadata()) && ItemStack.areItemStackTagsEqual(cursor, clickedItem)) {
+                                        if (clickedItem.stackSize >= 0) {
+                                            if (clickedItem.stackSize + cursor.stackSize <= cursor.getMaxStackSize()) {
+                                                // As of 1.5, this is result slots only
+                                                action = InventoryAction.PICKUP_ALL;
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                } else if (packetIn.getMode() == 1) {
+                    if (packetIn.getUsedButton() == 0) {
+                        click = ClickType.SHIFT_LEFT;
+                    } else if (packetIn.getUsedButton() == 1) {
+                        click = ClickType.SHIFT_RIGHT;
+                    }
+                    if (packetIn.getUsedButton() == 0 || packetIn.getUsedButton() == 1) {
+                        if (packetIn.getSlotId() < 0) {
+                            action = InventoryAction.NOTHING;
+                        } else {
+                            Slot slot = this.playerEntity.openContainer.getSlot(packetIn.getSlotId());
+                            if (slot != null && slot.canTakeStack(this.playerEntity) && slot.getHasStack()) {
+                                action = InventoryAction.MOVE_TO_OTHER_INVENTORY;
+                            } else {
+                                action = InventoryAction.NOTHING;
+                            }
+                        }
+                    }
+                } else if (packetIn.getMode() == 2) {
+                    if (packetIn.getUsedButton() >= 0 && packetIn.getUsedButton() < 9) {
+                        click = ClickType.NUMBER_KEY;
+                        Slot clickedSlot = this.playerEntity.openContainer.getSlot(packetIn.getSlotId());
+                        if (clickedSlot.canTakeStack(playerEntity)) {
+                            ItemStack hotbar = this.playerEntity.inventory.getStackInSlot(packetIn.getUsedButton());
+                            boolean canCleanSwap = hotbar == null || (clickedSlot.inventory == playerEntity.inventory && clickedSlot.isItemValid(hotbar)); // the slot will accept the hotbar item
+                            if (clickedSlot.getHasStack()) {
+                                if (canCleanSwap) {
+                                    action = InventoryAction.HOTBAR_SWAP;
+                                } else {
+                                    int firstEmptySlot = playerEntity.inventory.getFirstEmptyStack();
+                                    if (firstEmptySlot > -1) {
+                                        action = InventoryAction.HOTBAR_MOVE_AND_READD;
+                                    } else {
+                                        action = InventoryAction.NOTHING; // This is not sane! Mojang: You should test for other slots of same type
+                                    }
+                                }
+                            } else if (!clickedSlot.getHasStack() && hotbar != null && clickedSlot.isItemValid(hotbar)) {
+                                action = InventoryAction.HOTBAR_SWAP;
+                            } else {
+                                action = InventoryAction.NOTHING;
+                            }
+                        } else {
+                            action = InventoryAction.NOTHING;
+                        }
+                        // Special constructor for number key
+                        event = new InventoryClickEvent(inventory, type, packetIn.getSlotId(), click, action, packetIn.getUsedButton());
+                    }
+                } else if (packetIn.getMode() == 3) {
+                    if (packetIn.getUsedButton() == 2) {
+                        click = ClickType.MIDDLE;
+                        if (packetIn.getSlotId() == -999) {
+                            action = InventoryAction.NOTHING;
+                        } else {
+                            Slot slot = this.playerEntity.openContainer.getSlot(packetIn.getSlotId());
+                            if (slot != null && slot.getHasStack() && playerEntity.capabilities.isCreativeMode && playerEntity.inventory.getItemStack() == null) {
+                                action = InventoryAction.CLONE_STACK;
+                            } else {
+                                action = InventoryAction.NOTHING;
+                            }
+                        }
+                    } else {
+                        click = ClickType.UNKNOWN;
+                        action = InventoryAction.UNKNOWN;
+                    }
+                } else if (packetIn.getMode() == 4) {
+                    if (packetIn.getSlotId() >= 0) {
+                        if (packetIn.getUsedButton() == 0) {
+                            click = ClickType.DROP;
+                            Slot slot = this.playerEntity.openContainer.getSlot(packetIn.getSlotId());
+                            if (slot != null && slot.getHasStack() && slot.canTakeStack(playerEntity) && slot.getStack() != null && slot.getStack().getItem() != Item.getItemFromBlock(Blocks.air)) {
+                                action = InventoryAction.DROP_ONE_SLOT;
+                            } else {
+                                action = InventoryAction.NOTHING;
+                            }
+                        } else if (packetIn.getUsedButton() == 1) {
+                            click = ClickType.CONTROL_DROP;
+                            Slot slot = this.playerEntity.openContainer.getSlot(packetIn.getSlotId());
+                            if (slot != null && slot.getHasStack() && slot.canTakeStack(playerEntity) && slot.getStack() != null && slot.getStack().getItem() != Item.getItemFromBlock(Blocks.air)) {
+                                action = InventoryAction.DROP_ALL_SLOT;
+                            } else {
+                                action = InventoryAction.NOTHING;
+                            }
+                        }
+                    } else {
+                        // Sane default (because this happens when they are holding nothing. Don't ask why.)
+                        click = ClickType.LEFT;
+                        if (packetIn.getUsedButton() == 1) {
+                            click = ClickType.RIGHT;
+                        }
+                        action = InventoryAction.NOTHING;
+                    }
+                } else if (packetIn.getMode() == 5) {
+                    itemstack = this.playerEntity.openContainer.slotClick(packetIn.getSlotId(), packetIn.getUsedButton(), 5, this.playerEntity);
+                } else if (packetIn.getMode() == 6) {
+                    click = ClickType.DOUBLE_CLICK;
+                    action = InventoryAction.NOTHING;
+                    if (packetIn.getSlotId() >= 0 && this.playerEntity.inventory.getItemStack() != null) {
+                        ItemStack cursor = this.playerEntity.inventory.getItemStack();
+                        action = InventoryAction.NOTHING;
+                        // Quick check for if we have any of the item
+                        if (inventory.getTopInventory().contains(org.bukkit.Material.getMaterial(Item.getIdFromItem(cursor.getItem()))) || inventory.getBottomInventory().contains(org.bukkit.Material.getMaterial(Item.getIdFromItem(cursor.getItem())))) {
+                            action = InventoryAction.COLLECT_TO_CURSOR;
+                        }
+                    }
+                }
+                // TODO check on updates
+
+                if (packetIn.getMode() != 5) {
+                    if (click == ClickType.NUMBER_KEY) {
+                        event = new InventoryClickEvent(inventory, type, packetIn.getSlotId(), click, action, packetIn.getUsedButton());
+                    } else {
+                        event = new InventoryClickEvent(inventory, type, packetIn.getSlotId(), click, action);
+                    }
+
+                    org.bukkit.inventory.Inventory top = inventory.getTopInventory();
+                    if (packetIn.getSlotId() == 0 && top instanceof CraftingInventory) {
+                        org.bukkit.inventory.Recipe recipe = ((CraftingInventory) top).getRecipe();
+                        if (recipe != null) {
+                            if (click == ClickType.NUMBER_KEY) {
+                                event = new CraftItemEvent(recipe, inventory, type, packetIn.getSlotId(), click, action, packetIn.getUsedButton());
+                            } else {
+                                event = new CraftItemEvent(recipe, inventory, type, packetIn.getSlotId(), click, action);
+                            }
+                        }
+                    }
+
+                    event.setCancelled(cancelled);
+                    server.getPluginManager().callEvent(event);
+
+                    switch (event.getResult()) {
+                        case ALLOW:
+                        case DEFAULT:
+                            itemstack = this.playerEntity.openContainer.slotClick(packetIn.getSlotId(), packetIn.getUsedButton(), packetIn.getMode(), this.playerEntity);
+                            break;
+                        case DENY:
+                            /* Needs enum constructor in InventoryAction
+                            if (action.modifiesOtherSlots()) {
+
+                            } else {
+                                if (action.modifiesCursor()) {
+                                    this.player.playerConnection.sendPacket(new Packet103SetSlot(-1, -1, this.player.inventory.getCarried()));
+                                }
+                                if (action.modifiesClicked()) {
+                                    this.player.playerConnection.sendPacket(new Packet103SetSlot(this.player.activeContainer.windowId, packet102windowclick.slot, this.player.activeContainer.getSlot(packet102windowclick.slot).getItem()));
+                                }
+                            }*/
+                            switch (action) {
+                                // Modified other slots
+                                case PICKUP_ALL:
+                                case MOVE_TO_OTHER_INVENTORY:
+                                case HOTBAR_MOVE_AND_READD:
+                                case HOTBAR_SWAP:
+                                case COLLECT_TO_CURSOR:
+                                case UNKNOWN:
+                                    this.playerEntity.sendContainerToPlayer(this.playerEntity.openContainer);
+                                    break;
+                                // Modified cursor and clicked
+                                case PICKUP_SOME:
+                                case PICKUP_HALF:
+                                case PICKUP_ONE:
+                                case PLACE_ALL:
+                                case PLACE_SOME:
+                                case PLACE_ONE:
+                                case SWAP_WITH_CURSOR:
+                                    this.playerEntity.playerNetServerHandler.sendPacket(new S2FPacketSetSlot(-1, -1, this.playerEntity.inventory.getItemStack()));
+                                    this.playerEntity.playerNetServerHandler.sendPacket(new S2FPacketSetSlot(this.playerEntity.openContainer.windowId, packetIn.getSlotId(), this.playerEntity.openContainer.getSlot(packetIn.getSlotId()).getStack()));
+                                    break;
+                                // Modified clicked only
+                                case DROP_ALL_SLOT:
+                                case DROP_ONE_SLOT:
+                                    this.playerEntity.playerNetServerHandler.sendPacket(new S2FPacketSetSlot(this.playerEntity.openContainer.windowId, packetIn.getSlotId(), this.playerEntity.openContainer.getSlot(packetIn.getSlotId()).getStack()));
+                                    break;
+                                // Modified cursor only
+                                case DROP_ALL_CURSOR:
+                                case DROP_ONE_CURSOR:
+                                case CLONE_STACK:
+                                    this.playerEntity.playerNetServerHandler.sendPacket(new S2FPacketSetSlot(-1, -1, this.playerEntity.inventory.getItemStack()));
+                                    break;
+                                // Nothing
+                                case NOTHING:
+                                    break;
+                            }
+                            return;
+                    }
+
+                    if (event instanceof CraftItemEvent) {
+                        // Need to update the inventory on crafting to
+                        // correctly support custom recipes
+                        playerEntity.sendContainerToPlayer(playerEntity.openContainer);
+                    }
+                }
+                // CraftBukkit end
+
+                if (ItemStack.areItemStacksEqual(packetIn.getClickedItem(), itemstack)) {
                     this.playerEntity.playerNetServerHandler.sendPacket(new S32PacketConfirmTransaction(packetIn.getWindowId(), packetIn.getActionNumber(), true));
                     this.playerEntity.isChangingQuantityOnly = true;
                     this.playerEntity.openContainer.detectAndSendChanges();
                     this.playerEntity.updateHeldItem();
                     this.playerEntity.isChangingQuantityOnly = false;
-                }
-                else
-                {
+                } else {
                     this.field_147372_n.addKey(this.playerEntity.openContainer.windowId, Short.valueOf(packetIn.getActionNumber()));
                     this.playerEntity.playerNetServerHandler.sendPacket(new S32PacketConfirmTransaction(packetIn.getWindowId(), packetIn.getActionNumber(), false));
                     this.playerEntity.openContainer.setPlayerIsPresent(this.playerEntity, false);
                     ArrayList arraylist1 = Lists.newArrayList();
 
-                    for (int j = 0; j < this.playerEntity.openContainer.inventorySlots.size(); ++j)
-                    {
-                        arraylist1.add(((Slot)this.playerEntity.openContainer.inventorySlots.get(j)).getStack());
+                    for (int j = 0; j < this.playerEntity.openContainer.inventorySlots.size(); ++j) {
+                        arraylist1.add(((Slot) this.playerEntity.openContainer.inventorySlots.get(j)).getStack());
                     }
 
                     this.playerEntity.sendContainerAndContentsToPlayer(this.playerEntity.openContainer, arraylist1);
                 }
             }
         }
     }
 
-    public void processEnchantItem(C11PacketEnchantItem packetIn)
-    {
+    public void processEnchantItem(C11PacketEnchantItem packetIn) {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
         this.playerEntity.markPlayerActive();
 
-        if (this.playerEntity.openContainer.windowId == packetIn.getWindowId() && this.playerEntity.openContainer.isPlayerNotUsingContainer(this.playerEntity) && !this.playerEntity.isSpectator())
-        {
+        if (this.playerEntity.openContainer.windowId == packetIn.getWindowId() && this.playerEntity.openContainer.isPlayerNotUsingContainer(this.playerEntity) && !this.playerEntity.isSpectator()) {
             this.playerEntity.openContainer.enchantItem(this.playerEntity, packetIn.getButton());
             this.playerEntity.openContainer.detectAndSendChanges();
         }
     }
 
-    public void processCreativeInventoryAction(C10PacketCreativeInventoryAction packetIn)
-    {
+    public void processCreativeInventoryAction(C10PacketCreativeInventoryAction packetIn) {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
 
-        if (this.playerEntity.theItemInWorldManager.isCreative())
-        {
+        if (this.playerEntity.theItemInWorldManager.isCreative()) {
             boolean flag = packetIn.getSlotId() < 0;
             ItemStack itemstack = packetIn.getStack();
 
-            if (itemstack != null && itemstack.hasTagCompound() && itemstack.getTagCompound().hasKey("BlockEntityTag", 10))
-            {
+            if (itemstack != null && itemstack.hasTagCompound() && itemstack.getTagCompound().hasKey("BlockEntityTag", 10)) {
                 NBTTagCompound nbttagcompound = itemstack.getTagCompound().getCompoundTag("BlockEntityTag");
 
-                if (nbttagcompound.hasKey("x") && nbttagcompound.hasKey("y") && nbttagcompound.hasKey("z"))
-                {
+                if (nbttagcompound.hasKey("x") && nbttagcompound.hasKey("y") && nbttagcompound.hasKey("z")) {
                     BlockPos blockpos = new BlockPos(nbttagcompound.getInteger("x"), nbttagcompound.getInteger("y"), nbttagcompound.getInteger("z"));
                     TileEntity tileentity = this.playerEntity.worldObj.getTileEntity(blockpos);
 
-                    if (tileentity != null)
-                    {
+                    if (tileentity != null) {
                         NBTTagCompound nbttagcompound1 = new NBTTagCompound();
                         tileentity.writeToNBT(nbttagcompound1);
                         nbttagcompound1.removeTag("x");
                         nbttagcompound1.removeTag("y");
                         nbttagcompound1.removeTag("z");
@@ -1014,500 +1834,479 @@
                     }
                 }
             }
 
             boolean flag1 = packetIn.getSlotId() >= 1 && packetIn.getSlotId() < 36 + InventoryPlayer.getHotbarSize();
-            boolean flag2 = itemstack == null || itemstack.getItem() != null;
+            // CraftBukkit - Add invalidItems check
+            boolean flag2 = itemstack == null || itemstack.getItem() != null && (!invalidItems.contains(Item.getIdFromItem(itemstack.getItem())) || !SpigotConfig.filterCreativeItems); // Spigot
             boolean flag3 = itemstack == null || itemstack.getMetadata() >= 0 && itemstack.stackSize <= 64 && itemstack.stackSize > 0;
 
-            if (flag1 && flag2 && flag3)
-            {
-                if (itemstack == null)
-                {
-                    this.playerEntity.inventoryContainer.putStackInSlot(packetIn.getSlotId(), (ItemStack)null);
+            // CraftBukkit start - Call click event
+            if (flag || (flag1 && !ItemStack.areItemStacksEqual(this.playerEntity.inventoryContainer.getSlot(packetIn.getSlotId()).getStack(), packetIn.getStack()))) { // Insist on valid slot
+
+                HumanEntity player = this.playerEntity.getBukkitEntity();
+                InventoryView inventory = new CraftInventoryView(player, player.getInventory(), this.playerEntity.inventoryContainer);
+                org.bukkit.inventory.ItemStack item = CraftItemStack.asBukkitCopy(packetIn.getStack());
+
+                SlotType type = SlotType.QUICKBAR;
+                if (flag) {
+                    type = SlotType.OUTSIDE;
+                } else if (packetIn.getSlotId() < 36) {
+                    if (packetIn.getSlotId() >= 5 && packetIn.getSlotId() < 9) {
+                        type = SlotType.ARMOR;
+                    } else {
+                        type = SlotType.CONTAINER;
+                    }
                 }
-                else
-                {
+                InventoryCreativeEvent event = new InventoryCreativeEvent(inventory, type, flag ? -999 : packetIn.getSlotId(), item);
+                server.getPluginManager().callEvent(event);
+
+                itemstack = CraftItemStack.asNMSCopy(event.getCursor());
+
+                switch (event.getResult()) {
+                    case ALLOW:
+                        // Plugin cleared the id / stacksize checks
+                        flag2 = flag3 = true;
+                        break;
+                    case DEFAULT:
+                        break;
+                    case DENY:
+                        // Reset the slot
+                        if (packetIn.getSlotId() >= 0) {
+                            this.playerEntity.playerNetServerHandler.sendPacket(new S2FPacketSetSlot(this.playerEntity.inventoryContainer.windowId, packetIn.getSlotId(), this.playerEntity.inventoryContainer.getSlot(packetIn.getSlotId()).getStack()));
+                            this.playerEntity.playerNetServerHandler.sendPacket(new S2FPacketSetSlot(-1, -1, null));
+                        }
+                        return;
+                }
+            }
+            // CraftBukkit end
+
+            if (flag1 && flag2 && flag3) {
+                if (itemstack == null) {
+                    this.playerEntity.inventoryContainer.putStackInSlot(packetIn.getSlotId(), (ItemStack) null);
+                } else {
                     this.playerEntity.inventoryContainer.putStackInSlot(packetIn.getSlotId(), itemstack);
                 }
 
                 this.playerEntity.inventoryContainer.setPlayerIsPresent(this.playerEntity, true);
-            }
-            else if (flag && flag2 && flag3 && this.itemDropThreshold < 200)
-            {
+            } else if (flag && flag2 && flag3 && this.itemDropThreshold < 200) {
                 this.itemDropThreshold += 20;
                 EntityItem entityitem = this.playerEntity.dropPlayerItemWithRandomChoice(itemstack, true);
 
-                if (entityitem != null)
-                {
+                if (entityitem != null) {
                     entityitem.setAgeToCreativeDespawnTime();
                 }
             }
         }
     }
 
-    public void processConfirmTransaction(C0FPacketConfirmTransaction packetIn)
-    {
+    public void processConfirmTransaction(C0FPacketConfirmTransaction packetIn) {
+        if (this.playerEntity.isDead) return; // CraftBukkit
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
-        Short oshort = (Short)this.field_147372_n.lookup(this.playerEntity.openContainer.windowId);
+        Short oshort = (Short) this.field_147372_n.lookup(this.playerEntity.openContainer.windowId);
 
-        if (oshort != null && packetIn.getUid() == oshort.shortValue() && this.playerEntity.openContainer.windowId == packetIn.getWindowId() && !this.playerEntity.openContainer.isPlayerNotUsingContainer(this.playerEntity) && !this.playerEntity.isSpectator())
-        {
+        if (oshort != null && packetIn.getUid() == oshort.shortValue() && this.playerEntity.openContainer.windowId == packetIn.getWindowId() && !this.playerEntity.openContainer.isPlayerNotUsingContainer(this.playerEntity) && !this.playerEntity.isSpectator()) {
             this.playerEntity.openContainer.setPlayerIsPresent(this.playerEntity, true);
         }
     }
 
-    public void processUpdateSign(C12PacketUpdateSign packetIn)
-    {
+    public void processUpdateSign(C12PacketUpdateSign packetIn) {
+        if (this.playerEntity.isDead) return; // CraftBukkit
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
         this.playerEntity.markPlayerActive();
         WorldServer worldserver = this.serverController.worldServerForDimension(this.playerEntity.dimension);
         BlockPos blockpos = packetIn.getPosition();
 
-        if (worldserver.isBlockLoaded(blockpos))
-        {
+        if (worldserver.isBlockLoaded(blockpos)) {
             TileEntity tileentity = worldserver.getTileEntity(blockpos);
 
-            if (!(tileentity instanceof TileEntitySign))
-            {
+            if (!(tileentity instanceof TileEntitySign)) {
                 return;
             }
 
-            TileEntitySign tileentitysign = (TileEntitySign)tileentity;
+            TileEntitySign tileentitysign = (TileEntitySign) tileentity;
 
-            if (!tileentitysign.getIsEditable() || tileentitysign.getPlayer() != this.playerEntity)
-            {
+            if (!tileentitysign.getIsEditable() || tileentitysign.getPlayer() != this.playerEntity) {
                 this.serverController.logWarning("Player " + this.playerEntity.getName() + " just tried to change non-editable sign");
+                this.sendPacket(new S33PacketUpdateSign(tileentity.worldObj, packetIn.getPosition(), tileentitysign.signText)); // CraftBukkit
                 return;
             }
 
-            System.arraycopy(packetIn.getLines(), 0, tileentitysign.signText, 0, 4);
+            // CraftBukkit start
+            Player player = this.server.getPlayer(this.playerEntity);
+            int x = packetIn.getPosition().getX();
+            int y = packetIn.getPosition().getY();
+            int z = packetIn.getPosition().getZ();
+            SignChangeEvent event = new SignChangeEvent(player.getWorld().getBlockAt(x, y, z), this.server.getPlayer(this.playerEntity), org.bukkit.craftbukkit.block.CraftSign.revertComponents(packetIn.getLines()));
+            this.server.getPluginManager().callEvent(event);
+
+            if (!event.isCancelled()) {
+                System.arraycopy(org.bukkit.craftbukkit.block.CraftSign.sanitizeLines(event.getLines()), 0, tileentitysign.signText, 0, 4);
+                tileentitysign.isEditable = false;
+            }
+            // System.arraycopy(packetIn.getLines(), 0, tileentitysign.signText, 0, 4);
+            // CraftBukkit end
             tileentitysign.markDirty();
             worldserver.markBlockForUpdate(blockpos);
         }
     }
 
-    public void processKeepAlive(C00PacketKeepAlive packetIn)
-    {
-        if (packetIn.getKey() == this.field_147378_h)
-        {
-            int i = (int)(this.currentTimeMillis() - this.lastPingTime);
+    public void processKeepAlive(C00PacketKeepAlive packetIn) {
+        if (packetIn.getKey() == this.field_147378_h) {
+            int i = (int) (this.currentTimeMillis() - this.lastPingTime);
             this.playerEntity.ping = (this.playerEntity.ping * 3 + i) / 4;
         }
     }
 
-    private long currentTimeMillis()
-    {
+    private long currentTimeMillis() {
         return System.nanoTime() / 1000000L;
     }
 
-    public void processPlayerAbilities(C13PacketPlayerAbilities packetIn)
-    {
+    public void processPlayerAbilities(C13PacketPlayerAbilities packetIn) {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
-        this.playerEntity.capabilities.isFlying = packetIn.isFlying() && this.playerEntity.capabilities.allowFlying;
+        // CraftBukkit start
+        if (this.playerEntity.capabilities.allowFlying && this.playerEntity.capabilities.isFlying != packetIn.isFlying()) {
+            PlayerToggleFlightEvent event = new PlayerToggleFlightEvent(this.server.getPlayer(this.playerEntity), packetIn.isFlying());
+            this.server.getPluginManager().callEvent(event);
+            if (!event.isCancelled()) {
+                this.playerEntity.capabilities.isFlying = packetIn.isFlying(); // Actually set the player's flying status
+            } else {
+                this.playerEntity.sendPlayerAbilities(); // Tell the player their ability was reverted
+            }
+        }
+        // CraftBukkit end
     }
 
-    public void processTabComplete(C14PacketTabComplete packetIn)
-    {
+    public void processTabComplete(C14PacketTabComplete packetIn) {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
+        // CraftBukkit start
+        if (chatSpamField.addAndGet(this, 10) > 500 && !this.serverController.getConfigurationManager().canSendCommands(this.playerEntity.getGameProfile())) {
+            this.kickPlayerFromServer("disconnect.spam");
+            return;
+        }
+        // CraftBukkit end
+
         ArrayList arraylist = Lists.newArrayList();
         Iterator iterator = this.serverController.getTabCompletions(this.playerEntity, packetIn.getMessage(), packetIn.getTargetBlock()).iterator();
 
-        while (iterator.hasNext())
-        {
-            String s = (String)iterator.next();
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
             arraylist.add(s);
         }
 
-        this.playerEntity.playerNetServerHandler.sendPacket(new S3APacketTabComplete((String[])arraylist.toArray(new String[arraylist.size()])));
+        this.playerEntity.playerNetServerHandler.sendPacket(new S3APacketTabComplete((String[]) arraylist.toArray(new String[arraylist.size()])));
     }
 
-    public void processClientSettings(C15PacketClientSettings packetIn)
-    {
+    public void processClientSettings(C15PacketClientSettings packetIn) {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
         this.playerEntity.handleClientSettings(packetIn);
     }
 
-    public void processVanilla250Packet(C17PacketCustomPayload packetIn)
-    {
+    public void processVanilla250Packet(C17PacketCustomPayload packetIn) {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.playerEntity.getServerForPlayer());
         PacketBuffer packetbuffer;
         ItemStack itemstack;
         ItemStack itemstack1;
 
-        if ("MC|BEdit".equals(packetIn.getChannelName()))
-        {
+        if ("MC|BEdit".equals(packetIn.getChannelName())) {
             packetbuffer = new PacketBuffer(Unpooled.wrappedBuffer(packetIn.getBufferData()));
 
-            try
-            {
+            try {
                 itemstack = packetbuffer.readItemStackFromBuffer();
 
-                if (itemstack == null)
-                {
-                    return;
-                }
+                if (itemstack != null) {
+                    if (!ItemWritableBook.isNBTValid(itemstack.getTagCompound())) {
+                        throw new IOException("Invalid book tag!");
+                    }
 
-                if (!ItemWritableBook.isNBTValid(itemstack.getTagCompound()))
-                {
-                    throw new IOException("Invalid book tag!");
-                }
+                    itemstack1 = this.playerEntity.inventory.getCurrentItem();
 
-                itemstack1 = this.playerEntity.inventory.getCurrentItem();
+                    if (itemstack1 == null) {
+                        return;
+                    }
 
-                if (itemstack1 != null)
-                {
-                    if (itemstack.getItem() == Items.writable_book && itemstack.getItem() == itemstack1.getItem())
-                    {
-                        itemstack1.setTagInfo("pages", itemstack.getTagCompound().getTagList("pages", 8));
+                    if (itemstack.getItem() == Items.writable_book && itemstack.getItem() == itemstack1.getItem()) {
+                        // CraftBukkit Start
+                        // itemstack1.setTagInfo("pages", itemstack.getTagCompound().getTagList("pages", 8));
+                        CraftEventFactory.handleEditBookEvent(playerEntity, itemstack);
+                        // CraftBukkit end
                     }
 
                     return;
                 }
-            }
-            catch (Exception exception4)
-            {
+            } catch (Exception exception4) {
                 logger.error("Couldn\'t handle book info", exception4);
+                this.kickPlayerFromServer("Invalid book data!"); // CraftBukkit
                 return;
-            }
-            finally
-            {
+            } finally {
                 packetbuffer.release();
             }
 
             return;
-        }
-        else if ("MC|BSign".equals(packetIn.getChannelName()))
-        {
+        } else if ("MC|BSign".equals(packetIn.getChannelName())) {
             packetbuffer = new PacketBuffer(Unpooled.wrappedBuffer(packetIn.getBufferData()));
 
-            try
-            {
+            try {
                 itemstack = packetbuffer.readItemStackFromBuffer();
 
-                if (itemstack != null)
-                {
-                    if (!ItemEditableBook.validBookTagContents(itemstack.getTagCompound()))
-                    {
+                if (itemstack != null) {
+                    if (!ItemEditableBook.validBookTagContents(itemstack.getTagCompound())) {
                         throw new IOException("Invalid book tag!");
                     }
 
                     itemstack1 = this.playerEntity.inventory.getCurrentItem();
 
-                    if (itemstack1 == null)
-                    {
+                    if (itemstack1 == null) {
                         return;
                     }
 
-                    if (itemstack.getItem() == Items.written_book && itemstack1.getItem() == Items.writable_book)
-                    {
-                        itemstack1.setTagInfo("author", new NBTTagString(this.playerEntity.getName()));
-                        itemstack1.setTagInfo("title", new NBTTagString(itemstack.getTagCompound().getString("title")));
-                        itemstack1.setTagInfo("pages", itemstack.getTagCompound().getTagList("pages", 8));
-                        itemstack1.setItem(Items.written_book);
+                    if (itemstack.getItem() == Items.written_book && itemstack1.getItem() == Items.writable_book) {
+                        // CraftBukkit start
+                        // itemstack1.setTagInfo("author", new NBTTagString(this.playerEntity.getName()));
+                        // itemstack1.setTagInfo("title", new NBTTagString(itemstack.getTagCompound().getString("title")));
+                        // itemstack1.setTagInfo("pages", itemstack.getTagCompound().getTagList("pages", 8));
+                        // itemstack1.setItem(Items.written_book);
+                        CraftEventFactory.handleEditBookEvent(playerEntity, itemstack);
+                        // CraftBukkit end
                     }
 
                     return;
                 }
-            }
-            catch (Exception exception3)
-            {
+            } catch (Exception exception3) {
                 logger.error("Couldn\'t sign book", exception3);
+                this.kickPlayerFromServer("Invalid book data!"); // CraftBukkit
                 return;
-            }
-            finally
-            {
+            } finally {
                 packetbuffer.release();
             }
 
             return;
-        }
-        else if ("MC|TrSel".equals(packetIn.getChannelName()))
-        {
-            try
-            {
+        } else if ("MC|TrSel".equals(packetIn.getChannelName())) {
+            try {
                 int i = packetIn.getBufferData().readInt();
                 Container container = this.playerEntity.openContainer;
 
-                if (container instanceof ContainerMerchant)
-                {
-                    ((ContainerMerchant)container).setCurrentRecipeIndex(i);
+                if (container instanceof ContainerMerchant) {
+                    ((ContainerMerchant) container).setCurrentRecipeIndex(i);
                 }
-            }
-            catch (Exception exception2)
-            {
+            } catch (Exception exception2) {
                 logger.error("Couldn\'t select trade", exception2);
+                this.kickPlayerFromServer("Invalid trade data!"); // CraftBukkit
             }
-        }
-        else if ("MC|AdvCdm".equals(packetIn.getChannelName()))
-        {
-            if (!this.serverController.isCommandBlockEnabled())
-            {
+        } else if ("MC|AdvCdm".equals(packetIn.getChannelName())) {
+            if (!this.serverController.isCommandBlockEnabled()) {
                 this.playerEntity.addChatMessage(new ChatComponentTranslation("advMode.notEnabled", new Object[0]));
-            }
-            else if (this.playerEntity.canUseCommand(2, "") && this.playerEntity.capabilities.isCreativeMode)
-            {
+            } else if (this.playerEntity.getBukkitEntity().isOp() && this.playerEntity.capabilities.isCreativeMode) { // CraftBukkit - Change to Bukkit OP versus Vanilla OP
                 packetbuffer = packetIn.getBufferData();
 
-                try
-                {
+                try {
                     byte b0 = packetbuffer.readByte();
                     CommandBlockLogic commandblocklogic = null;
 
-                    if (b0 == 0)
-                    {
+                    if (b0 == 0) {
                         TileEntity tileentity = this.playerEntity.worldObj.getTileEntity(new BlockPos(packetbuffer.readInt(), packetbuffer.readInt(), packetbuffer.readInt()));
 
-                        if (tileentity instanceof TileEntityCommandBlock)
-                        {
-                            commandblocklogic = ((TileEntityCommandBlock)tileentity).getCommandBlockLogic();
+                        if (tileentity instanceof TileEntityCommandBlock) {
+                            commandblocklogic = ((TileEntityCommandBlock) tileentity).getCommandBlockLogic();
                         }
-                    }
-                    else if (b0 == 1)
-                    {
+                    } else if (b0 == 1) {
                         Entity entity = this.playerEntity.worldObj.getEntityByID(packetbuffer.readInt());
 
-                        if (entity instanceof EntityMinecartCommandBlock)
-                        {
-                            commandblocklogic = ((EntityMinecartCommandBlock)entity).getCommandBlockLogic();
+                        if (entity instanceof EntityMinecartCommandBlock) {
+                            commandblocklogic = ((EntityMinecartCommandBlock) entity).getCommandBlockLogic();
                         }
                     }
 
                     String s1 = packetbuffer.readStringFromBuffer(packetbuffer.readableBytes());
                     boolean flag = packetbuffer.readBoolean();
 
-                    if (commandblocklogic != null)
-                    {
+                    if (commandblocklogic != null) {
                         commandblocklogic.setCommand(s1);
                         commandblocklogic.setTrackOutput(flag);
 
-                        if (!flag)
-                        {
-                            commandblocklogic.setLastOutput((IChatComponent)null);
+                        if (!flag) {
+                            commandblocklogic.setLastOutput((IChatComponent) null);
                         }
 
                         commandblocklogic.func_145756_e();
-                        this.playerEntity.addChatMessage(new ChatComponentTranslation("advMode.setCommand.success", new Object[] {s1}));
+                        this.playerEntity.addChatMessage(new ChatComponentTranslation("advMode.setCommand.success", new Object[]{s1}));
                     }
-                }
-                catch (Exception exception1)
-                {
+                } catch (Exception exception1) {
                     logger.error("Couldn\'t set command block", exception1);
-                }
-                finally
-                {
+                    this.kickPlayerFromServer("Invalid CommandBlock data!"); // CraftBukkit
+                } finally {
                     packetbuffer.release();
                 }
-            }
-            else
-            {
+            } else {
                 this.playerEntity.addChatMessage(new ChatComponentTranslation("advMode.notAllowed", new Object[0]));
             }
-        }
-        else if ("MC|Beacon".equals(packetIn.getChannelName()))
-        {
-            if (this.playerEntity.openContainer instanceof ContainerBeacon)
-            {
-                try
-                {
+        } else if ("MC|Beacon".equals(packetIn.getChannelName())) {
+            if (this.playerEntity.openContainer instanceof ContainerBeacon) {
+                try {
                     packetbuffer = packetIn.getBufferData();
                     int j = packetbuffer.readInt();
                     int k = packetbuffer.readInt();
-                    ContainerBeacon containerbeacon = (ContainerBeacon)this.playerEntity.openContainer;
+                    ContainerBeacon containerbeacon = (ContainerBeacon) this.playerEntity.openContainer;
                     Slot slot = containerbeacon.getSlot(0);
 
-                    if (slot.getHasStack())
-                    {
+                    if (slot.getHasStack()) {
                         slot.decrStackSize(1);
                         IInventory iinventory = containerbeacon.func_180611_e();
                         iinventory.setField(1, j);
                         iinventory.setField(2, k);
                         iinventory.markDirty();
                     }
-                }
-                catch (Exception exception)
-                {
+                } catch (Exception exception) {
                     logger.error("Couldn\'t set beacon", exception);
+                    this.kickPlayerFromServer("Invalid beacon data!"); // CraftBukkit
                 }
             }
-        }
-        else if ("MC|ItemName".equals(packetIn.getChannelName()) && this.playerEntity.openContainer instanceof ContainerRepair)
-        {
-            ContainerRepair containerrepair = (ContainerRepair)this.playerEntity.openContainer;
+        } else if ("MC|ItemName".equals(packetIn.getChannelName()) && this.playerEntity.openContainer instanceof ContainerRepair) {
+            ContainerRepair containerrepair = (ContainerRepair) this.playerEntity.openContainer;
 
-            if (packetIn.getBufferData() != null && packetIn.getBufferData().readableBytes() >= 1)
-            {
+            if (packetIn.getBufferData() != null && packetIn.getBufferData().readableBytes() >= 1) {
                 String s = ChatAllowedCharacters.filterAllowedCharacters(packetIn.getBufferData().readStringFromBuffer(32767));
 
-                if (s.length() <= 30)
-                {
+                if (s.length() <= 30) {
                     containerrepair.updateItemName(s);
                 }
-            }
-            else
-            {
+            } else {
                 containerrepair.updateItemName("");
             }
         }
+
+        // CraftBukkit start
+        else if (packetIn.getChannelName().equals("REGISTER")) {
+            String channels = packetIn.getBufferData().toString(com.google.common.base.Charsets.UTF_8);
+            for (String channel : channels.split("\0")) {
+                getPlayer().addChannel(channel);
+            }
+        } else if (packetIn.getChannelName().equals("UNREGISTER")) {
+            String channels = packetIn.getBufferData().toString(com.google.common.base.Charsets.UTF_8);
+            for (String channel : channels.split("\0")) {
+                getPlayer().removeChannel(channel);
+            }
+        } else {
+            byte[] data = new byte[packetIn.getBufferData().readableBytes()];
+            packetIn.getBufferData().readBytes(data);
+            server.getMessenger().dispatchIncomingMessage(playerEntity.getBukkitEntity(), packetIn.getChannelName(), data);
+        }
+        // CraftBukkit end
     }
 
-    static final class SwitchAction
-        {
-            static final int[] field_180224_a;
+    // CraftBukkit start - Add "isDisconnected" method
+    public boolean isDisconnected() {
+        return !this.playerEntity.joining && !this.netManager.channel.config().isAutoRead();
+    }
 
-            static final int[] field_180222_b;
+    static final class SwitchAction {
 
-            static final int[] field_180223_c = new int[C16PacketClientStatus.EnumState.values().length];
-            private static final String __OBFID = "CL_00002269";
+        static final int[] field_180224_a;
 
-            static
-            {
-                try
-                {
-                    field_180223_c[C16PacketClientStatus.EnumState.PERFORM_RESPAWN.ordinal()] = 1;
-                }
-                catch (NoSuchFieldError var16)
-                {
-                    ;
-                }
+        static final int[] field_180222_b;
 
-                try
-                {
-                    field_180223_c[C16PacketClientStatus.EnumState.REQUEST_STATS.ordinal()] = 2;
-                }
-                catch (NoSuchFieldError var15)
-                {
-                    ;
-                }
+        static final int[] field_180223_c = new int[C16PacketClientStatus.EnumState.values().length];
+        private static final String __OBFID = "CL_00002269";
 
-                try
-                {
-                    field_180223_c[C16PacketClientStatus.EnumState.OPEN_INVENTORY_ACHIEVEMENT.ordinal()] = 3;
-                }
-                catch (NoSuchFieldError var14)
-                {
-                    ;
-                }
+        static {
+            try {
+                field_180223_c[C16PacketClientStatus.EnumState.PERFORM_RESPAWN.ordinal()] = 1;
+            } catch (NoSuchFieldError var16) {
+                ;
+            }
 
-                field_180222_b = new int[C0BPacketEntityAction.Action.values().length];
+            try {
+                field_180223_c[C16PacketClientStatus.EnumState.REQUEST_STATS.ordinal()] = 2;
+            } catch (NoSuchFieldError var15) {
+                ;
+            }
 
-                try
-                {
-                    field_180222_b[C0BPacketEntityAction.Action.START_SNEAKING.ordinal()] = 1;
-                }
-                catch (NoSuchFieldError var13)
-                {
-                    ;
-                }
+            try {
+                field_180223_c[C16PacketClientStatus.EnumState.OPEN_INVENTORY_ACHIEVEMENT.ordinal()] = 3;
+            } catch (NoSuchFieldError var14) {
+                ;
+            }
 
-                try
-                {
-                    field_180222_b[C0BPacketEntityAction.Action.STOP_SNEAKING.ordinal()] = 2;
-                }
-                catch (NoSuchFieldError var12)
-                {
-                    ;
-                }
+            field_180222_b = new int[C0BPacketEntityAction.Action.values().length];
 
-                try
-                {
-                    field_180222_b[C0BPacketEntityAction.Action.START_SPRINTING.ordinal()] = 3;
-                }
-                catch (NoSuchFieldError var11)
-                {
-                    ;
-                }
+            try {
+                field_180222_b[C0BPacketEntityAction.Action.START_SNEAKING.ordinal()] = 1;
+            } catch (NoSuchFieldError var13) {
+                ;
+            }
 
-                try
-                {
-                    field_180222_b[C0BPacketEntityAction.Action.STOP_SPRINTING.ordinal()] = 4;
-                }
-                catch (NoSuchFieldError var10)
-                {
-                    ;
-                }
+            try {
+                field_180222_b[C0BPacketEntityAction.Action.STOP_SNEAKING.ordinal()] = 2;
+            } catch (NoSuchFieldError var12) {
+                ;
+            }
 
-                try
-                {
-                    field_180222_b[C0BPacketEntityAction.Action.STOP_SLEEPING.ordinal()] = 5;
-                }
-                catch (NoSuchFieldError var9)
-                {
-                    ;
-                }
+            try {
+                field_180222_b[C0BPacketEntityAction.Action.START_SPRINTING.ordinal()] = 3;
+            } catch (NoSuchFieldError var11) {
+                ;
+            }
 
-                try
-                {
-                    field_180222_b[C0BPacketEntityAction.Action.RIDING_JUMP.ordinal()] = 6;
-                }
-                catch (NoSuchFieldError var8)
-                {
-                    ;
-                }
+            try {
+                field_180222_b[C0BPacketEntityAction.Action.STOP_SPRINTING.ordinal()] = 4;
+            } catch (NoSuchFieldError var10) {
+                ;
+            }
 
-                try
-                {
-                    field_180222_b[C0BPacketEntityAction.Action.OPEN_INVENTORY.ordinal()] = 7;
-                }
-                catch (NoSuchFieldError var7)
-                {
-                    ;
-                }
+            try {
+                field_180222_b[C0BPacketEntityAction.Action.STOP_SLEEPING.ordinal()] = 5;
+            } catch (NoSuchFieldError var9) {
+                ;
+            }
 
-                field_180224_a = new int[C07PacketPlayerDigging.Action.values().length];
+            try {
+                field_180222_b[C0BPacketEntityAction.Action.RIDING_JUMP.ordinal()] = 6;
+            } catch (NoSuchFieldError var8) {
+                ;
+            }
 
-                try
-                {
-                    field_180224_a[C07PacketPlayerDigging.Action.DROP_ITEM.ordinal()] = 1;
-                }
-                catch (NoSuchFieldError var6)
-                {
-                    ;
-                }
+            try {
+                field_180222_b[C0BPacketEntityAction.Action.OPEN_INVENTORY.ordinal()] = 7;
+            } catch (NoSuchFieldError var7) {
+                ;
+            }
 
-                try
-                {
-                    field_180224_a[C07PacketPlayerDigging.Action.DROP_ALL_ITEMS.ordinal()] = 2;
-                }
-                catch (NoSuchFieldError var5)
-                {
-                    ;
-                }
+            field_180224_a = new int[C07PacketPlayerDigging.Action.values().length];
 
-                try
-                {
-                    field_180224_a[C07PacketPlayerDigging.Action.RELEASE_USE_ITEM.ordinal()] = 3;
-                }
-                catch (NoSuchFieldError var4)
-                {
-                    ;
-                }
+            try {
+                field_180224_a[C07PacketPlayerDigging.Action.DROP_ITEM.ordinal()] = 1;
+            } catch (NoSuchFieldError var6) {
+                ;
+            }
 
-                try
-                {
-                    field_180224_a[C07PacketPlayerDigging.Action.START_DESTROY_BLOCK.ordinal()] = 4;
-                }
-                catch (NoSuchFieldError var3)
-                {
-                    ;
-                }
+            try {
+                field_180224_a[C07PacketPlayerDigging.Action.DROP_ALL_ITEMS.ordinal()] = 2;
+            } catch (NoSuchFieldError var5) {
+                ;
+            }
 
-                try
-                {
-                    field_180224_a[C07PacketPlayerDigging.Action.ABORT_DESTROY_BLOCK.ordinal()] = 5;
-                }
-                catch (NoSuchFieldError var2)
-                {
-                    ;
-                }
+            try {
+                field_180224_a[C07PacketPlayerDigging.Action.RELEASE_USE_ITEM.ordinal()] = 3;
+            } catch (NoSuchFieldError var4) {
+                ;
+            }
 
-                try
-                {
-                    field_180224_a[C07PacketPlayerDigging.Action.STOP_DESTROY_BLOCK.ordinal()] = 6;
-                }
-                catch (NoSuchFieldError var1)
-                {
-                    ;
-                }
+            try {
+                field_180224_a[C07PacketPlayerDigging.Action.START_DESTROY_BLOCK.ordinal()] = 4;
+            } catch (NoSuchFieldError var3) {
+                ;
             }
+
+            try {
+                field_180224_a[C07PacketPlayerDigging.Action.ABORT_DESTROY_BLOCK.ordinal()] = 5;
+            } catch (NoSuchFieldError var2) {
+                ;
+            }
+
+            try {
+                field_180224_a[C07PacketPlayerDigging.Action.STOP_DESTROY_BLOCK.ordinal()] = 6;
+            } catch (NoSuchFieldError var1) {
+                ;
+            }
         }
+    }
 }
