--- decompiled\net\minecraft\network\rcon\RConThreadQuery.java
+++ src\main\java\net\minecraft\network\rcon\RConThreadQuery.java
@@ -1,8 +1,7 @@
 package net.minecraft.network.rcon;
 
-import com.google.common.collect.Maps;
 import java.io.IOException;
 import java.net.DatagramPacket;
 import java.net.DatagramSocket;
 import java.net.InetAddress;
 import java.net.PortUnreachableException;
@@ -11,19 +10,19 @@
 import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.Map;
-import java.util.Random;
 import java.util.Map.Entry;
+import java.util.Random;
+
 import net.minecraft.server.MinecraftServer;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
 
-@SideOnly(Side.SERVER)
-public class RConThreadQuery extends RConThreadBase
-{
+import com.google.common.collect.Maps;
+
+public class RConThreadQuery extends RConThreadBase {
+
     private long lastAuthCheckTime;
     private int queryPort;
     private int serverPort;
     private int maxPlayers;
     private String serverMotd;
@@ -38,43 +37,35 @@
     private long time;
     private RConOutputStream output;
     private long lastQueryResponseTime;
     private static final String __OBFID = "CL_00001802";
 
-    public RConThreadQuery(IServer p_i1536_1_)
-    {
+    public RConThreadQuery(IServer p_i1536_1_) {
         super(p_i1536_1_, "Query Listener");
         this.queryPort = p_i1536_1_.getIntProperty("query.port", 0);
         this.serverHostname = p_i1536_1_.getHostname();
         this.serverPort = p_i1536_1_.getPort();
         this.serverMotd = p_i1536_1_.getMotd();
         this.maxPlayers = p_i1536_1_.getMaxPlayers();
         this.worldName = p_i1536_1_.getFolderName();
         this.lastQueryResponseTime = 0L;
         this.queryHostname = "0.0.0.0";
 
-        if (0 != this.serverHostname.length() && !this.queryHostname.equals(this.serverHostname))
-        {
+        if (0 != this.serverHostname.length() && !this.queryHostname.equals(this.serverHostname)) {
             this.queryHostname = this.serverHostname;
-        }
-        else
-        {
+        } else {
             this.serverHostname = "0.0.0.0";
 
-            try
-            {
+            try {
                 InetAddress inetaddress = InetAddress.getLocalHost();
                 this.queryHostname = inetaddress.getHostAddress();
-            }
-            catch (UnknownHostException unknownhostexception)
-            {
+            } catch (UnknownHostException unknownhostexception) {
                 this.logWarning("Unable to determine local host IP, please set server-ip in \'" + p_i1536_1_.getSettingsFilename() + "\' : " + unknownhostexception.getMessage());
             }
         }
 
-        if (0 == this.queryPort)
-        {
+        if (0 == this.queryPort) {
             this.queryPort = this.serverPort;
             this.logInfo("Setting default query port to " + this.queryPort);
             p_i1536_1_.setProperty("query.port", Integer.valueOf(this.queryPort));
             p_i1536_1_.setProperty("debug", Boolean.valueOf(false));
             p_i1536_1_.saveProperties();
@@ -84,50 +75,41 @@
         this.output = new RConOutputStream(1460);
         this.queryClients = Maps.newHashMap();
         this.time = (new Date()).getTime();
     }
 
-    private void sendResponsePacket(byte[] data, DatagramPacket requestPacket) throws IOException
-    {
+    private void sendResponsePacket(byte[] data, DatagramPacket requestPacket) throws IOException {
         this.querySocket.send(new DatagramPacket(data, data.length, requestPacket.getSocketAddress()));
     }
 
-    private boolean parseIncomingPacket(DatagramPacket requestPacket) throws IOException
-    {
+    private boolean parseIncomingPacket(DatagramPacket requestPacket) throws IOException {
         byte[] abyte = requestPacket.getData();
         int i = requestPacket.getLength();
         SocketAddress socketaddress = requestPacket.getSocketAddress();
         this.logDebug("Packet len " + i + " [" + socketaddress + "]");
 
-        if (3 <= i && -2 == abyte[0] && -3 == abyte[1])
-        {
+        if (3 <= i && -2 == abyte[0] && -3 == abyte[1]) {
             this.logDebug("Packet \'" + RConUtils.getByteAsHexString(abyte[2]) + "\' [" + socketaddress + "]");
 
-            switch (abyte[2])
-            {
+            switch (abyte[2]) {
                 case 0:
-                    if (!this.verifyClientAuth(requestPacket).booleanValue())
-                    {
+                    if (!this.verifyClientAuth(requestPacket).booleanValue()) {
                         this.logDebug("Invalid challenge [" + socketaddress + "]");
                         return false;
-                    }
-                    else if (15 == i)
-                    {
+                    } else if (15 == i) {
                         this.sendResponsePacket(this.createQueryResponse(requestPacket), requestPacket);
                         this.logDebug("Rules [" + socketaddress + "]");
-                    }
-                    else
-                    {
+                    } else {
                         RConOutputStream rconoutputstream = new RConOutputStream(1460);
                         rconoutputstream.writeInt(0);
                         rconoutputstream.writeByteArray(this.getRequestID(requestPacket.getSocketAddress()));
                         rconoutputstream.writeString(this.serverMotd);
                         rconoutputstream.writeString("SMP");
                         rconoutputstream.writeString(this.worldName);
                         rconoutputstream.writeString(Integer.toString(this.getNumberOfPlayers()));
                         rconoutputstream.writeString(Integer.toString(this.maxPlayers));
-                        rconoutputstream.writeShort((short)this.serverPort);
+                        rconoutputstream.writeShort((short) this.serverPort);
                         rconoutputstream.writeString(this.queryHostname);
                         this.sendResponsePacket(rconoutputstream.toByteArray(), requestPacket);
                         this.logDebug("Status [" + socketaddress + "]");
                     }
                 case 9:
@@ -135,34 +117,28 @@
                     this.logDebug("Challenge [" + socketaddress + "]");
                     return true;
                 default:
                     return true;
             }
-        }
-        else
-        {
+        } else {
             this.logDebug("Invalid packet [" + socketaddress + "]");
             return false;
         }
     }
 
-    private byte[] createQueryResponse(DatagramPacket requestPacket) throws IOException
-    {
+    private byte[] createQueryResponse(DatagramPacket requestPacket) throws IOException {
         long i = MinecraftServer.getCurrentTimeMillis();
 
-        if (i < this.lastQueryResponseTime + 5000L)
-        {
+        if (i < this.lastQueryResponseTime + 5000L) {
             byte[] abyte = this.output.toByteArray();
             byte[] abyte1 = this.getRequestID(requestPacket.getSocketAddress());
             abyte[1] = abyte1[0];
             abyte[2] = abyte1[1];
             abyte[3] = abyte1[2];
             abyte[4] = abyte1[3];
             return abyte;
-        }
-        else
-        {
+        } else {
             this.lastQueryResponseTime = i;
             this.output.reset();
             this.output.writeInt(0);
             this.output.writeByteArray(this.getRequestID(requestPacket.getSocketAddress()));
             this.output.writeString("splitnum");
@@ -194,204 +170,157 @@
             this.output.writeInt(0);
             String[] astring = this.server.getAllUsernames();
             String[] astring1 = astring;
             int j = astring.length;
 
-            for (int k = 0; k < j; ++k)
-            {
+            for (int k = 0; k < j; ++k) {
                 String s = astring1[k];
                 this.output.writeString(s);
             }
 
             this.output.writeInt(0);
             return this.output.toByteArray();
         }
     }
 
-    private byte[] getRequestID(SocketAddress address)
-    {
-        return ((RConThreadQuery.Auth)this.queryClients.get(address)).getRequestId();
+    private byte[] getRequestID(SocketAddress address) {
+        return ((RConThreadQuery.Auth) this.queryClients.get(address)).getRequestId();
     }
 
-    private Boolean verifyClientAuth(DatagramPacket requestPacket)
-    {
+    private Boolean verifyClientAuth(DatagramPacket requestPacket) {
         SocketAddress socketaddress = requestPacket.getSocketAddress();
 
-        if (!this.queryClients.containsKey(socketaddress))
-        {
+        if (!this.queryClients.containsKey(socketaddress)) {
             return Boolean.valueOf(false);
-        }
-        else
-        {
+        } else {
             byte[] abyte = requestPacket.getData();
-            return ((RConThreadQuery.Auth)this.queryClients.get(socketaddress)).getRandomChallenge() != RConUtils.getBytesAsBEint(abyte, 7, requestPacket.getLength()) ? Boolean.valueOf(false) : Boolean.valueOf(true);
+            return ((RConThreadQuery.Auth) this.queryClients.get(socketaddress)).getRandomChallenge() != RConUtils.getBytesAsBEint(abyte, 7, requestPacket.getLength()) ? Boolean.valueOf(false) : Boolean.valueOf(true);
         }
     }
 
-    private void sendAuthChallenge(DatagramPacket requestPacket) throws IOException
-    {
+    private void sendAuthChallenge(DatagramPacket requestPacket) throws IOException {
         RConThreadQuery.Auth auth = new RConThreadQuery.Auth(requestPacket);
         this.queryClients.put(requestPacket.getSocketAddress(), auth);
         this.sendResponsePacket(auth.getChallengeValue(), requestPacket);
     }
 
-    private void cleanQueryClientsMap()
-    {
-        if (this.running)
-        {
+    private void cleanQueryClientsMap() {
+        if (this.running) {
             long i = MinecraftServer.getCurrentTimeMillis();
 
-            if (i >= this.lastAuthCheckTime + 30000L)
-            {
+            if (i >= this.lastAuthCheckTime + 30000L) {
                 this.lastAuthCheckTime = i;
                 Iterator iterator = this.queryClients.entrySet().iterator();
 
-                while (iterator.hasNext())
-                {
-                    Entry entry = (Entry)iterator.next();
+                while (iterator.hasNext()) {
+                    Entry entry = (Entry) iterator.next();
 
-                    if (((RConThreadQuery.Auth)entry.getValue()).hasExpired(i).booleanValue())
-                    {
+                    if (((RConThreadQuery.Auth) entry.getValue()).hasExpired(i).booleanValue()) {
                         iterator.remove();
                     }
                 }
             }
         }
     }
 
-    public void run()
-    {
+    public void run() {
         this.logInfo("Query running on " + this.serverHostname + ":" + this.queryPort);
         this.lastAuthCheckTime = MinecraftServer.getCurrentTimeMillis();
         this.incomingPacket = new DatagramPacket(this.buffer, this.buffer.length);
 
-        try
-        {
-            while (this.running)
-            {
-                try
-                {
+        try {
+            while (this.running) {
+                try {
                     this.querySocket.receive(this.incomingPacket);
                     this.cleanQueryClientsMap();
                     this.parseIncomingPacket(this.incomingPacket);
-                }
-                catch (SocketTimeoutException sockettimeoutexception)
-                {
+                } catch (SocketTimeoutException sockettimeoutexception) {
                     this.cleanQueryClientsMap();
-                }
-                catch (PortUnreachableException portunreachableexception)
-                {
+                } catch (PortUnreachableException portunreachableexception) {
                     ;
-                }
-                catch (IOException ioexception)
-                {
+                } catch (IOException ioexception) {
                     this.stopWithException(ioexception);
                 }
             }
-        }
-        finally
-        {
+        } finally {
             this.closeAllSockets();
         }
     }
 
-    public void startThread()
-    {
-        if (!this.running)
-        {
-            if (0 < this.queryPort && 65535 >= this.queryPort)
-            {
-                if (this.initQuerySystem())
-                {
+    public void startThread() {
+        if (!this.running) {
+            if (0 < this.queryPort && 65535 >= this.queryPort) {
+                if (this.initQuerySystem()) {
                     super.startThread();
                 }
-            }
-            else
-            {
+            } else {
                 this.logWarning("Invalid query port " + this.queryPort + " found in \'" + this.server.getSettingsFilename() + "\' (queries disabled)");
             }
         }
     }
 
-    private void stopWithException(Exception exception)
-    {
-        if (this.running)
-        {
+    private void stopWithException(Exception exception) {
+        if (this.running) {
             this.logWarning("Unexpected exception, buggy JRE? (" + exception.toString() + ")");
 
-            if (!this.initQuerySystem())
-            {
+            if (!this.initQuerySystem()) {
                 this.logSevere("Failed to recover from buggy JRE, shutting down!");
                 this.running = false;
             }
         }
     }
 
-    private boolean initQuerySystem()
-    {
-        try
-        {
+    private boolean initQuerySystem() {
+        try {
             this.querySocket = new DatagramSocket(this.queryPort, InetAddress.getByName(this.serverHostname));
             this.registerSocket(this.querySocket);
             this.querySocket.setSoTimeout(500);
             return true;
-        }
-        catch (SocketException socketexception)
-        {
+        } catch (SocketException socketexception) {
             this.logWarning("Unable to initialise query system on " + this.serverHostname + ":" + this.queryPort + " (Socket): " + socketexception.getMessage());
-        }
-        catch (UnknownHostException unknownhostexception)
-        {
+        } catch (UnknownHostException unknownhostexception) {
             this.logWarning("Unable to initialise query system on " + this.serverHostname + ":" + this.queryPort + " (Unknown Host): " + unknownhostexception.getMessage());
-        }
-        catch (Exception exception)
-        {
+        } catch (Exception exception) {
             this.logWarning("Unable to initialise query system on " + this.serverHostname + ":" + this.queryPort + " (E): " + exception.getMessage());
         }
 
         return false;
     }
 
-    @SideOnly(Side.SERVER)
-    class Auth
-    {
+    class Auth {
+
         private long timestamp = (new Date()).getTime();
         private int randomChallenge;
         private byte[] requestId;
         private byte[] challengeValue;
         private String requestIdAsString;
         private static final String __OBFID = "CL_00001803";
 
-        public Auth(DatagramPacket requestPacket)
-        {
+        public Auth(DatagramPacket requestPacket) {
             byte[] abyte = requestPacket.getData();
             this.requestId = new byte[4];
             this.requestId[0] = abyte[3];
             this.requestId[1] = abyte[4];
             this.requestId[2] = abyte[5];
             this.requestId[3] = abyte[6];
             this.requestIdAsString = new String(this.requestId);
             this.randomChallenge = (new Random()).nextInt(16777216);
-            this.challengeValue = String.format("\t%s%d\u0000", new Object[] {this.requestIdAsString, Integer.valueOf(this.randomChallenge)}).getBytes();
+            this.challengeValue = String.format("\t%s%d\u0000", new Object[]{this.requestIdAsString, Integer.valueOf(this.randomChallenge)}).getBytes();
         }
 
-        public Boolean hasExpired(long currentTime)
-        {
+        public Boolean hasExpired(long currentTime) {
             return Boolean.valueOf(this.timestamp < currentTime);
         }
 
-        public int getRandomChallenge()
-        {
+        public int getRandomChallenge() {
             return this.randomChallenge;
         }
 
-        public byte[] getChallengeValue()
-        {
+        public byte[] getChallengeValue() {
             return this.challengeValue;
         }
 
-        public byte[] getRequestId()
-        {
+        public byte[] getRequestId() {
             return this.requestId;
         }
     }
 }
