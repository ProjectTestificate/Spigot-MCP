--- decompiled\net\minecraft\world\World.java
+++ src\main\java\net\minecraft\world\World.java
@@ -1,20 +1,19 @@
 package net.minecraft.world;
 
-import com.google.common.base.Predicate;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collection;
+import java.util.ConcurrentModificationException;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
-import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.Callable;
+
 import net.minecraft.block.Block;
+import net.minecraft.block.BlockChest;
 import net.minecraft.block.BlockHopper;
 import net.minecraft.block.BlockLiquid;
 import net.minecraft.block.BlockSlab;
 import net.minecraft.block.BlockSnow;
 import net.minecraft.block.BlockStairs;
@@ -23,19 +22,30 @@
 import net.minecraft.command.IEntitySelector;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityLiving;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.item.EntityItem;
+import net.minecraft.entity.item.EntityXPOrb;
+import net.minecraft.entity.monster.EntityGhast;
+import net.minecraft.entity.monster.EntityGolem;
+import net.minecraft.entity.monster.EntityMob;
+import net.minecraft.entity.monster.EntitySlime;
+import net.minecraft.entity.passive.EntityAnimal;
+import net.minecraft.entity.passive.EntityWaterMob;
 import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.init.Blocks;
 import net.minecraft.item.ItemStack;
-import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.profiler.Profiler;
 import net.minecraft.scoreboard.Scoreboard;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.gui.IUpdatePlayerListBox;
 import net.minecraft.tileentity.TileEntity;
+import net.minecraft.tileentity.TileEntityChest;
+import net.minecraft.tileentity.TileEntityHopper;
 import net.minecraft.util.AxisAlignedBB;
 import net.minecraft.util.BlockPos;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.EnumParticleTypes;
 import net.minecraft.util.IntHashMap;
@@ -47,21 +57,72 @@
 import net.minecraft.world.biome.BiomeGenBase;
 import net.minecraft.world.biome.WorldChunkManager;
 import net.minecraft.world.border.WorldBorder;
 import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.IChunkProvider;
+import net.minecraft.world.gen.ChunkProviderServer;
 import net.minecraft.world.gen.structure.StructureBoundingBox;
 import net.minecraft.world.storage.ISaveHandler;
+import net.minecraft.world.storage.MapData;
+import net.minecraft.world.storage.MapData.MapInfo;
 import net.minecraft.world.storage.MapStorage;
 import net.minecraft.world.storage.WorldInfo;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
 
+import org.bukkit.Bukkit;
+import org.bukkit.World.Environment;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.SpigotTimings;
+import org.bukkit.craftbukkit.SpigotTimings.WorldTimingsHandler;
+import org.bukkit.craftbukkit.block.CraftBlockState;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.entity.Projectile;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.block.BlockCanBuildEvent;
+import org.bukkit.event.block.BlockPhysicsEvent;
+import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
+import org.bukkit.generator.ChunkGenerator;
+import org.spigotmc.ActivationRange;
+import org.spigotmc.AsyncCatcher;
+import org.spigotmc.SpigotWorldConfig;
+import org.spigotmc.TickLimiter;
+
+import com.google.common.base.Predicate;
+import com.google.common.collect.Lists;
+
+import gnu.trove.map.hash.TLongShortHashMap;
+
 public abstract class World implements IBlockAccess
 {
+
     protected boolean scheduledUpdatesAreImmediate;
-    public final List loadedEntityList = Lists.newArrayList();
+    // Spigot start - guard entity list from removals
+    public final List loadedEntityList = new ArrayList()
+    {
+        @Override
+        public java.lang.Object remove(int index)
+        {
+            guard();
+            return super.remove(index);
+        }
+        @Override
+        public boolean remove(Object o)
+        {
+            guard();
+            return super.remove(o);
+        }
+        private void guard()
+        {
+            if (guardEntityList)
+            {
+                throw new ConcurrentModificationException();
+            }
+        }
+    };
+    // Spigot end
     protected final List unloadedEntityList = Lists.newArrayList();
     public final List loadedTileEntityList = Lists.newArrayList();
     public final List tickableTileEntities = Lists.newArrayList();
     private final List addedTileEntityList = Lists.newArrayList();
     private final List tileEntitiesToBeRemoved = Lists.newArrayList();
@@ -70,49 +131,207 @@
     protected final IntHashMap entitiesById = new IntHashMap();
     private long cloudColour = 16777215L;
     private int skylightSubtracted;
     protected int updateLCG = (new Random()).nextInt();
     protected final int DIST_HASH_MAGIC = 1013904223;
-    protected float prevRainingStrength;
-    protected float rainingStrength;
-    protected float prevThunderingStrength;
-    protected float thunderingStrength;
+    public float prevRainingStrength;
+    public float rainingStrength;
+    public float prevThunderingStrength;
+    public float thunderingStrength;
     private int lastLightningBolt;
     public final Random rand = new Random();
-    public final WorldProvider provider;
+    public WorldProvider provider; // SpigotMCP -- Apply access transformation (remove final)
     protected List worldAccesses = Lists.newArrayList();
-    protected IChunkProvider chunkProvider;
+    public IChunkProvider chunkProvider; // SpigotMCP -- Make public as bukkit assumes in same package
     protected final ISaveHandler saveHandler;
-    protected WorldInfo worldInfo;
+    public WorldInfo worldInfo; // SpigotMCP -- Make public as bukkit assumes in same package
     protected boolean findingSpawnPoint;
-    protected MapStorage mapStorage;
-    protected VillageCollection villageCollectionObj;
+    public MapStorage mapStorage; // SpigotMCP -- Apply access transformation
+    public VillageCollection villageCollectionObj;
     public final Profiler theProfiler;
     private final Calendar theCalendar = Calendar.getInstance();
-    protected Scoreboard worldScoreboard = new Scoreboard();
+    public Scoreboard worldScoreboard = new Scoreboard(); // SpigotMCP -- Apply access transformation
     public final boolean isRemote;
-    protected Set activeChunkSet = Sets.newHashSet();
+    // CraftBukkit - longhashset
+    // protected LongHashSet activeChunkSet = new LongHashSet(); // Spigot
     private int ambientTickCountdown;
-    protected boolean spawnHostileMobs;
-    protected boolean spawnPeacefulMobs;
+    public boolean spawnHostileMobs; // SpigotMCP -- Apply access transformation
+    public boolean spawnPeacefulMobs; // SpigotMCP -- Apply access transformation
     private boolean processingLoadedTiles;
     private final WorldBorder worldBorder;
     int[] lightUpdateBlockList;
     private static final String __OBFID = "CL_00000140";
 
-    protected World(ISaveHandler saveHandlerIn, WorldInfo info, WorldProvider providerIn, Profiler profilerIn, boolean client)
+    // CraftBukkit start Added the following
+    private final CraftWorld world;
+    public boolean pvpMode;
+    public boolean keepSpawnInMemory = true;
+    public ChunkGenerator generator;
+
+    public boolean captureBlockStates = false;
+    public boolean captureTreeGeneration = false;
+    public ArrayList<BlockState> capturedBlockStates = new ArrayList<BlockState>()
     {
+        @Override
+        public boolean add(BlockState blockState)
+        {
+            Iterator<BlockState> blockStateIterator = this.iterator();
+
+            while (blockStateIterator.hasNext())
+            {
+                BlockState blockState1 = blockStateIterator.next();
+
+                if (blockState1.getLocation().equals(blockState.getLocation()))
+                {
+                    return false;
+                }
+            }
+
+            return super.add(blockState);
+        }
+    };
+    public long ticksPerAnimalSpawns;
+    public long ticksPerMonsterSpawns;
+    public boolean populating;
+    private int tickPosition;
+
+    // Spigot start
+    private boolean guardEntityList;
+    protected final TLongShortHashMap activeChunkSet;
+    public float growthOdds = 100; // SpigotMCP -- Make public as spigot assumes in same package
+    protected float modifiedOdds = 100;
+    private final byte chunkTickRadius;
+    public static boolean haveWeSilencedAPhysicsCrash;
+    public static String blockLocation;
+    public List<TileEntity> triggerHoppersList = new ArrayList<TileEntity>(); // Spigot, When altHopperTicking, tile entities being added go through here.
+    private TickLimiter entityLimiter;
+    private TickLimiter tileLimiter;
+    private int tileTickPosition;
+
+    public static long chunkToKey(int x, int z)
+    {
+        long k = ((((long)x) & 0xFFFF0000L) << 16) | ((((long)x) & 0x0000FFFFL) << 0);
+        k |= ((((long)z) & 0xFFFF0000L) << 32) | ((((long)z) & 0x0000FFFFL) << 16);
+        return k;
+    }
+
+    public static int keyToX(long k)
+    {
+        return (int)(((k >> 16) & 0xFFFF0000) | (k & 0x0000FFFF));
+    }
+
+    public static int keyToZ(long k)
+    {
+        return (int)(((k >> 32) & 0xFFFF0000L) | ((k >> 16) & 0x0000FFFF));
+    }
+
+    // Spigot Start - Hoppers need to be born ticking.
+    private void initializeHoppers()
+    {
+        if (this.spigotConfig.altHopperTicking)
+        {
+            for (TileEntity o : this.triggerHoppersList)
+            {
+                o.scheduleTicks();
+
+                if (o instanceof TileEntityHopper)
+                {
+                    ((TileEntityHopper)o).convertToScheduling();
+                    ((TileEntityHopper)o).scheduleHopperTick();
+                }
+            }
+        }
+
+        triggerHoppersList.clear();
+    }
+
+    // Helper method for altHopperTicking. Updates chests at the specified location,
+    // accounting for double chests. Updating the chest will update adjacent hoppers.
+    public void updateChestAndHoppers(BlockPos blockposition)
+    {
+        Block block = this.getBlockState(blockposition).getBlock();
+
+        if (block instanceof BlockChest)
+        {
+            TileEntity tile = this.getTileEntity(blockposition);
+
+            if (tile instanceof TileEntityChest)
+            {
+                tile.scheduleTicks();
+            }
+
+            for (int i = 2; i < 6; i++)
+            {
+                // Facing class provides arrays for direction offset.
+                BlockPos pos = blockposition.offset(EnumFacing.getFront(i));
+
+                if (this.getBlockState(pos) == block)
+                {
+                    tile = this.getTileEntity(pos);
+
+                    if (tile instanceof TileEntityChest)
+                    {
+                        tile.scheduleTicks();
+                    }
+
+                    break;
+                }
+            }
+        }
+    }
+    // Spigot end
+
+    public final SpigotWorldConfig spigotConfig; // Spigot
+
+    public final WorldTimingsHandler timings; // Spigot
+
+    public org.bukkit.craftbukkit.CraftWorld getWorld()
+    {
+        return this.world;
+    }
+
+    public CraftServer getServer()
+    {
+        return (CraftServer)Bukkit.getServer();
+    }
+
+    public Chunk getChunkIfLoaded(int x, int z)
+    {
+        return ((ChunkProviderServer)this.chunkProvider).getChunkIfLoaded(x, z);
+    }
+
+    protected World(ISaveHandler saveHandlerIn, WorldInfo info, WorldProvider providerIn, Profiler profilerIn, boolean client, ChunkGenerator gen, Environment env)
+    {
+        this.spigotConfig = new SpigotWorldConfig(info.getWorldName()); // Spigot
+        this.generator = gen;
+        this.world = new CraftWorld((WorldServer)this, gen, env);
+        this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
+        this.ticksPerMonsterSpawns = this.getServer().getTicksPerMonsterSpawns(); // CraftBukkit
+        // CraftBukkit end
+        // Spigot start
+        this.chunkTickRadius = (byte)((this.getServer().getViewDistance() < 7) ? this.getServer().getViewDistance() : 7);
+        this.activeChunkSet = new TLongShortHashMap(spigotConfig.chunksPerTick * 5, 0.7f, Long.MIN_VALUE, Short.MIN_VALUE);
+        this.activeChunkSet.setAutoCompactionFactor(0);
+        // Spigot end
         this.ambientTickCountdown = this.rand.nextInt(12000);
         this.spawnHostileMobs = true;
         this.spawnPeacefulMobs = true;
         this.lightUpdateBlockList = new int[32768];
         this.saveHandler = saveHandlerIn;
         this.theProfiler = profilerIn;
         this.worldInfo = info;
         this.provider = providerIn;
         this.isRemote = client;
         this.worldBorder = providerIn.getWorldBorder();
+        this.worldBorder.world = (WorldServer)this; // CraftBukkit
+        this.worldBorder.addListener(this.getServer().getHandle().new WorldBorderListener()); // CraftBukkit // SpigotMCP -- Use regular inner class
+        this.getServer().addWorld(this.world); // CraftBukkit
+        // Spigot Start - code below can generate new world and access timings
+        timings = new WorldTimingsHandler(this);
+        this.entityLimiter = new TickLimiter(spigotConfig.entityMaxTickTime);
+        this.tileLimiter = new TickLimiter(spigotConfig.tileMaxTickTime);
+        // Spigot End
     }
 
     public World init()
     {
         return this;
@@ -159,16 +378,10 @@
     public void initialize(WorldSettings settings)
     {
         this.worldInfo.setServerInitialized(true);
     }
 
-    @SideOnly(Side.CLIENT)
-    public void setInitialSpawnLocation()
-    {
-        this.setSpawnPoint(new BlockPos(8, 64, 8));
-    }
-
     public Block getGroundAboveSeaLevel(BlockPos pos)
     {
         BlockPos blockpos1;
 
         for (blockpos1 = new BlockPos(pos.getX(), 63, pos.getZ()); !this.isAirBlock(blockpos1.up()); blockpos1 = blockpos1.up())
@@ -255,11 +468,11 @@
         {
             return false;
         }
     }
 
-    protected boolean isChunkLoaded(int x, int z, boolean allowEmpty)
+    public boolean isChunkLoaded(int x, int z, boolean allowEmpty)   // SpigotMCP -- Make public as bukkit assumes in same package
     {
         return this.chunkProvider.chunkExists(x, z) && (allowEmpty || !this.chunkProvider.provideChunk(x, z).isEmpty());
     }
 
     public Chunk getChunkFromBlockCoords(BlockPos pos)
@@ -272,10 +485,40 @@
         return this.chunkProvider.provideChunk(chunkX, chunkZ);
     }
 
     public boolean setBlockState(BlockPos pos, IBlockState newState, int flags)
     {
+        // CraftBukkit start - tree generation
+        if (this.captureTreeGeneration)
+        {
+            BlockState blockstate = null;
+            Iterator<BlockState> it = capturedBlockStates.iterator();
+
+            while (it.hasNext())
+            {
+                BlockState previous = it.next();
+
+                if (previous.getX() == pos.getX() && previous.getY() == pos.getY() && previous.getZ() == pos.getZ())
+                {
+                    blockstate = previous;
+                    it.remove();
+                    break;
+                }
+            }
+
+            if (blockstate == null)
+            {
+                blockstate = CraftBlockState.getBlockState(this, pos.getX(), pos.getY(), pos.getZ(), flags);
+            }
+
+            blockstate.setTypeId(CraftMagicNumbers.getId(newState.getBlock()));
+            blockstate.setRawData((byte)newState.getBlock().getMetaFromState(newState));
+            this.capturedBlockStates.add(blockstate);
+            return true;
+        }
+
+        // CraftBukkit end
         if (!this.isValid(pos))
         {
             return false;
         }
         else if (!this.isRemote && this.worldInfo.getTerrainType() == WorldType.DEBUG_WORLD)
@@ -284,10 +527,20 @@
         }
         else
         {
             Chunk chunk = this.getChunkFromBlockCoords(pos);
             Block block = newState.getBlock();
+            // CraftBukkit start - capture blockstates
+            BlockState blockstate = null;
+
+            if (this.captureBlockStates)
+            {
+                blockstate = CraftBlockState.getBlockState(this, pos.getX(), pos.getY(), pos.getZ(), flags);
+                this.capturedBlockStates.add(blockstate);
+            }
+
+            // CraftBukkit end
             IBlockState iblockstate1 = chunk.setBlockState(pos, newState);
 
             if (iblockstate1 == null)
             {
                 return false;
@@ -301,30 +554,69 @@
                     this.theProfiler.startSection("checkLight");
                     this.checkLight(pos);
                     this.theProfiler.endSection();
                 }
 
-                if ((flags & 2) != 0 && (!this.isRemote || (flags & 4) == 0) && chunk.isPopulated())
-                {
+                // CraftBukkit start
+                /*
+                if ((flags & 2) != 0 && (!this.isRemote || (flags & 4) == 0) && chunk.isPopulated()) {
                     this.markBlockForUpdate(pos);
                 }
 
-                if (!this.isRemote && (flags & 1) != 0)
-                {
+                if (!this.isRemote && (flags & 1) != 0) {
                     this.notifyNeighborsRespectDebug(pos, iblockstate1.getBlock());
 
-                    if (block.hasComparatorInputOverride())
-                    {
+                    if (block.hasComparatorInputOverride()) {
                         this.updateComparatorOutputLevel(pos, block);
                     }
                 }
+                */
+                // CraftBukkit end
 
+                // CraftBukkit start
+                if (!this.captureBlockStates)   // Don't notify clients or update physics while capturing blockstates
+                {
+                    // Modularize client and physic updates
+                    notifyAndUpdatePhysics(pos, chunk, block1, block, flags);
+                }
+
+                // Spigot start - If this block is changing to that which a chest beneath it
+                // becomes able to be opened, then the chest must be updated.
+                // block1 is the old block. block is the new block. r returns true if the block type
+                // prevents access to a chest.
+                if (this.spigotConfig.altHopperTicking && block1 != null && block1.isNormalCube() && !block.isNormalCube())
+                {
+                    this.updateChestAndHoppers(pos.down());
+                }
+
+                // Spigot end
+                // CraftBukkit end
                 return true;
             }
         }
     }
 
+    // CraftBukkit start - Split off from original setTypeAndData(int i, int j, int k, Block block, int l, int i1) method in order to directly send client and physic updates
+    public void notifyAndUpdatePhysics(BlockPos blockposition, Chunk chunk, Block oldBlock, Block newBLock, int flag)
+    {
+        if ((flag & 2) != 0 && (chunk == null || chunk.isPopulated()))    // allow chunk to be null here as chunk.isReady() is false when we send our notification during block placement
+        {
+            this.markBlockForUpdate(blockposition);
+        }
+
+        if (!this.isRemote && (flag & 1) != 0)
+        {
+            this.notifyNeighborsRespectDebug(blockposition, oldBlock);
+
+            if (newBLock.hasComparatorInputOverride())
+            {
+                this.updateComparatorOutputLevel(blockposition, newBLock);
+            }
+        }
+    }
+    // CraftBukkit end
+
     public boolean setBlockToAir(BlockPos pos)
     {
         return this.setBlockState(pos, Blocks.air.getDefaultState(), 3);
     }
 
@@ -365,10 +657,17 @@
 
     public void notifyNeighborsRespectDebug(BlockPos pos, Block blockType)
     {
         if (this.worldInfo.getTerrainType() != WorldType.DEBUG_WORLD)
         {
+            // CraftBukkit start
+            if (populating)
+            {
+                return;
+            }
+
+            // CraftBukkit end
             this.notifyNeighborsOfStateChange(pos, blockType);
         }
     }
 
     public void markBlocksDirtyVertical(int x1, int z1, int x2, int z2)
@@ -412,10 +711,11 @@
         this.notifyBlockOfStateChange(pos.east(), blockType);
         this.notifyBlockOfStateChange(pos.down(), blockType);
         this.notifyBlockOfStateChange(pos.up(), blockType);
         this.notifyBlockOfStateChange(pos.north(), blockType);
         this.notifyBlockOfStateChange(pos.south(), blockType);
+        spigotConfig.antiXrayInstance.updateNearbyBlocks(this, pos); // Spigot
     }
 
     public void notifyNeighborsOfStateExcept(BlockPos pos, Block blockType, EnumFacing skipSide)
     {
         if (skipSide != EnumFacing.WEST)
@@ -455,14 +755,36 @@
         {
             IBlockState iblockstate = this.getBlockState(pos);
 
             try
             {
+                // CraftBukkit start
+                CraftWorld world = ((WorldServer)this).getWorld();
+
+                if (world != null)
+                {
+                    BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(pos.getX(), pos.getY(), pos.getZ()), CraftMagicNumbers.getId(blockIn));
+                    this.getServer().getPluginManager().callEvent(event);
+
+                    if (event.isCancelled())
+                    {
+                        return;
+                    }
+                }
+
+                // CraftBukkit end
                 iblockstate.getBlock().onNeighborBlockChange(this, pos, iblockstate, blockIn);
+                // Spigot Start
             }
+            catch (StackOverflowError stackoverflowerror)
+            {
+                haveWeSilencedAPhysicsCrash = true;
+                blockLocation = pos.getX() + ", " + pos.getY() + ", " + pos.getZ(); // Spigot End
+            }
             catch (Throwable throwable)
             {
+                // Spigot End
                 CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Exception while updating neighbours");
                 CrashReportCategory crashreportcategory = crashreport.makeCategory("Block being updated");
                 crashreportcategory.addCrashSectionCallable("Source block type", new Callable()
                 {
                     private static final String __OBFID = "CL_00000142";
@@ -665,70 +987,10 @@
             Chunk chunk = this.getChunkFromBlockCoords(pos);
             return chunk.getLightFor(type, pos);
         }
     }
 
-    @SideOnly(Side.CLIENT)
-    public int getLightFromNeighborsFor(EnumSkyBlock type, BlockPos p_175705_2_)
-    {
-        if (this.provider.getHasNoSky() && type == EnumSkyBlock.SKY)
-        {
-            return 0;
-        }
-        else
-        {
-            if (p_175705_2_.getY() < 0)
-            {
-                p_175705_2_ = new BlockPos(p_175705_2_.getX(), 0, p_175705_2_.getZ());
-            }
-
-            if (!this.isValid(p_175705_2_))
-            {
-                return type.defaultLightValue;
-            }
-            else if (!this.isBlockLoaded(p_175705_2_))
-            {
-                return type.defaultLightValue;
-            }
-            else if (this.getBlockState(p_175705_2_).getBlock().getUseNeighborBrightness())
-            {
-                int i1 = this.getLightFor(type, p_175705_2_.up());
-                int i = this.getLightFor(type, p_175705_2_.east());
-                int j = this.getLightFor(type, p_175705_2_.west());
-                int k = this.getLightFor(type, p_175705_2_.south());
-                int l = this.getLightFor(type, p_175705_2_.north());
-
-                if (i > i1)
-                {
-                    i1 = i;
-                }
-
-                if (j > i1)
-                {
-                    i1 = j;
-                }
-
-                if (k > i1)
-                {
-                    i1 = k;
-                }
-
-                if (l > i1)
-                {
-                    i1 = l;
-                }
-
-                return i1;
-            }
-            else
-            {
-                Chunk chunk = this.getChunkFromBlockCoords(p_175705_2_);
-                return chunk.getLightFor(type, p_175705_2_);
-            }
-        }
-    }
-
     public void setLightFor(EnumSkyBlock type, BlockPos pos, int lightValue)
     {
         if (this.isValid(pos))
         {
             if (this.isBlockLoaded(pos))
@@ -746,31 +1008,41 @@
         {
             ((IWorldAccess)this.worldAccesses.get(i)).notifyLightSet(pos);
         }
     }
 
-    @SideOnly(Side.CLIENT)
-    public int getCombinedLight(BlockPos pos, int p_175626_2_)
-    {
-        int j = this.getLightFromNeighborsFor(EnumSkyBlock.SKY, pos);
-        int k = this.getLightFromNeighborsFor(EnumSkyBlock.BLOCK, pos);
-
-        if (k < p_175626_2_)
-        {
-            k = p_175626_2_;
-        }
-
-        return j << 20 | k << 4;
-    }
-
     public float getLightBrightness(BlockPos pos)
     {
         return this.provider.getLightBrightnessTable()[this.getLightFromNeighbors(pos)];
     }
 
+    // Spigot Start
     public IBlockState getBlockState(BlockPos pos)
     {
+        return getType(pos, true);
+    }
+
+    public IBlockState getType(BlockPos pos, boolean useCaptured)
+    {
+        // CraftBukkit start - tree generation
+        if (captureTreeGeneration && useCaptured)
+        {
+            // Spigot end
+            Iterator<BlockState> it = capturedBlockStates.iterator();
+
+            while (it.hasNext())
+            {
+                BlockState previous = it.next();
+
+                if (previous.getX() == pos.getX() && previous.getY() == pos.getY() && previous.getZ() == pos.getZ())
+                {
+                    return CraftMagicNumbers.getBlock(previous.getTypeId()).getStateFromMeta(previous.getRawData());
+                }
+            }
+        }
+
+        // CraftBukkit end
         if (!this.isValid(pos))
         {
             return Blocks.air.getDefaultState();
         }
         else
@@ -998,33 +1270,29 @@
         {
             ((IWorldAccess)this.worldAccesses.get(i)).playSound(soundName, x, y, z, volume, pitch);
         }
     }
 
-    public void playSound(double x, double y, double z, String soundName, float volume, float pitch, boolean distanceDelay) {}
+    public void playSound(double x, double y, double z, String soundName, float volume, float pitch, boolean distanceDelay)
+    {
+    }
 
     public void playRecord(BlockPos p_175717_1_, String p_175717_2_)
     {
         for (int i = 0; i < this.worldAccesses.size(); ++i)
         {
             ((IWorldAccess)this.worldAccesses.get(i)).playRecord(p_175717_2_, p_175717_1_);
         }
     }
 
-    public void spawnParticle(EnumParticleTypes particleType, double xCoord, double yCoord, double zCoord, double xOffset, double yOffset, double zOffset, int ... p_175688_14_)
+    public void spawnParticle(EnumParticleTypes particleType, double xCoord, double yCoord, double zCoord, double xOffset, double yOffset, double zOffset, int... p_175688_14_)
     {
         this.spawnParticle(particleType.getParticleID(), particleType.func_179344_e(), xCoord, yCoord, zCoord, xOffset, yOffset, zOffset, p_175688_14_);
     }
 
-    @SideOnly(Side.CLIENT)
-    public void spawnParticle(EnumParticleTypes particleType, boolean p_175682_2_, double p_175682_3_, double p_175682_5_, double p_175682_7_, double p_175682_9_, double p_175682_11_, double p_175682_13_, int ... p_175682_15_)
+    private void spawnParticle(int p_175720_1_, boolean p_175720_2_, double xCood, double yCoord, double zCoord, double xOffset, double yOffset, double zOffset, int... p_175720_15_)
     {
-        this.spawnParticle(particleType.getParticleID(), particleType.func_179344_e() | p_175682_2_, p_175682_3_, p_175682_5_, p_175682_7_, p_175682_9_, p_175682_11_, p_175682_13_, p_175682_15_);
-    }
-
-    private void spawnParticle(int p_175720_1_, boolean p_175720_2_, double xCood, double yCoord, double zCoord, double xOffset, double yOffset, double zOffset, int ... p_175720_15_)
-    {
         for (int k = 0; k < this.worldAccesses.size(); ++k)
         {
             ((IWorldAccess)this.worldAccesses.get(k)).spawnParticle(p_175720_1_, p_175720_2_, xCood, yCoord, zCoord, xOffset, yOffset, zOffset, p_175720_15_);
         }
     }
@@ -1035,19 +1303,94 @@
         return true;
     }
 
     public boolean spawnEntityInWorld(Entity p_72838_1_)
     {
+        // CraftBukkit start - Used for entities other than creatures
+        return addEntity(p_72838_1_, SpawnReason.DEFAULT);
+    }
+
+    public boolean addEntity(Entity p_72838_1_, SpawnReason spawnReason)   // Changed signature, added SpawnReason // SpigotMCP -- use mcp name
+    {
+        AsyncCatcher.catchOp("entity add"); // Spigot
+
+        if (p_72838_1_ == null) return false;
+
+        // CraftBukkit end
         int i = MathHelper.floor_double(p_72838_1_.posX / 16.0D);
         int j = MathHelper.floor_double(p_72838_1_.posZ / 16.0D);
         boolean flag = p_72838_1_.forceSpawn;
 
         if (p_72838_1_ instanceof EntityPlayer)
         {
             flag = true;
         }
 
+        // CraftBukkit start
+        Cancellable event = null;
+
+        if (p_72838_1_ instanceof EntityLivingBase && !(p_72838_1_ instanceof EntityPlayerMP))
+        {
+            boolean isAnimal = p_72838_1_ instanceof EntityAnimal || p_72838_1_ instanceof EntityWaterMob || p_72838_1_ instanceof EntityGolem;
+            boolean isMonster = p_72838_1_ instanceof EntityMob || p_72838_1_ instanceof EntityGhast || p_72838_1_ instanceof EntitySlime;
+
+            if (spawnReason != SpawnReason.CUSTOM)
+            {
+                if (isAnimal && !spawnPeacefulMobs || isMonster && !spawnHostileMobs)
+                {
+                    p_72838_1_.isDead = true;
+                    return false;
+                }
+            }
+
+            event = CraftEventFactory.callCreatureSpawnEvent((EntityLiving)p_72838_1_, spawnReason);
+        }
+        else if (p_72838_1_ instanceof EntityItem)
+        {
+            event = CraftEventFactory.callItemSpawnEvent((EntityItem)p_72838_1_);
+        }
+        else if (p_72838_1_.getBukkitEntity() instanceof Projectile)
+        {
+            // Not all projectiles extend EntityProjectile, so check for Bukkit interface instead
+            event = CraftEventFactory.callProjectileLaunchEvent(p_72838_1_);
+        }
+        // Spigot start
+        else if (p_72838_1_ instanceof EntityXPOrb)
+        {
+            EntityXPOrb xp = (EntityXPOrb)p_72838_1_;
+            double radius = spigotConfig.expMerge;
+
+            if (radius > 0)
+            {
+                List<Entity> entities = this.getEntitiesWithinAABBExcludingEntity(p_72838_1_, p_72838_1_.getEntityBoundingBox().expand(radius, radius, radius));
+
+                for (Entity e : entities)
+                {
+                    if (e instanceof EntityXPOrb)
+                    {
+                        EntityXPOrb loopItem = (EntityXPOrb)e;
+
+                        if (!loopItem.isDead)
+                        {
+                            xp.xpValue += loopItem.xpValue;
+                            loopItem.setDead();
+                        }
+                    }
+                }
+            }
+        }
+
+        // Spigot end
+
+        if (event != null && (event.isCancelled() || p_72838_1_.isDead))
+        {
+            p_72838_1_.isDead = true;
+            return false;
+        }
+
+        // CraftBukkit end
+
         if (!flag && !this.isChunkLoaded(i, j, true))
         {
             return false;
         }
         else
@@ -1064,24 +1407,28 @@
             this.onEntityAdded(p_72838_1_);
             return true;
         }
     }
 
-    protected void onEntityAdded(Entity p_72923_1_)
+    public void onEntityAdded(Entity p_72923_1_)
     {
         for (int i = 0; i < this.worldAccesses.size(); ++i)
         {
             ((IWorldAccess)this.worldAccesses.get(i)).onEntityAdded(p_72923_1_);
         }
+
+        p_72923_1_.valid = true; // CraftBukkit
     }
 
-    protected void onEntityRemoved(Entity p_72847_1_)
+    public void onEntityRemoved(Entity p_72847_1_)
     {
         for (int i = 0; i < this.worldAccesses.size(); ++i)
         {
             ((IWorldAccess)this.worldAccesses.get(i)).onEntityRemoved(p_72847_1_);
         }
+
+        p_72847_1_.valid = false; // CraftBukkit
     }
 
     public void removeEntity(Entity p_72900_1_)
     {
         if (p_72900_1_.riddenByEntity != null)
@@ -1097,34 +1444,72 @@
         p_72900_1_.setDead();
 
         if (p_72900_1_ instanceof EntityPlayer)
         {
             this.playerEntities.remove(p_72900_1_);
+
+            // Spigot start
+            for (Object o : mapStorage.loadedDataList)
+            {
+                if (o instanceof MapData)
+                {
+                    MapData map = (MapData)o;
+                    map.playersHashMap.remove(p_72900_1_);
+
+                    for (Iterator<MapInfo> iter = (Iterator<MapInfo>)map.playersArrayList.iterator(); iter.hasNext();)
+                    {
+                        if (iter.next().entityplayerObj == p_72900_1_)
+                        {
+                            iter.remove();
+                        }
+                    }
+                }
+            }
+
+            // Spigot end
             this.updateAllPlayersSleepingFlag();
             this.onEntityRemoved(p_72900_1_);
         }
     }
 
     public void removePlayerEntityDangerously(Entity p_72973_1_)
     {
+        AsyncCatcher.catchOp("entity remove"); // Spigot
         p_72973_1_.setDead();
 
         if (p_72973_1_ instanceof EntityPlayer)
         {
             this.playerEntities.remove(p_72973_1_);
             this.updateAllPlayersSleepingFlag();
         }
 
-        int i = p_72973_1_.chunkCoordX;
-        int j = p_72973_1_.chunkCoordZ;
-
-        if (p_72973_1_.addedToChunk && this.isChunkLoaded(i, j, true))
+        if (!guardEntityList)   // Spigot - It will get removed after the tick if we are ticking
         {
-            this.getChunkFromChunkCoords(i, j).removeEntity(p_72973_1_);
-        }
+            int i = p_72973_1_.chunkCoordX;
+            int j = p_72973_1_.chunkCoordZ;
 
-        this.loadedEntityList.remove(p_72973_1_);
+            if (p_72973_1_.addedToChunk && this.isChunkLoaded(i, j, true))
+            {
+                this.getChunkFromChunkCoords(i, j).removeEntity(p_72973_1_);
+            }
+
+            // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
+            int index = this.loadedEntityList.indexOf(p_72973_1_);
+
+            if (index != -1)
+            {
+                if (index <= this.tickPosition)
+                {
+                    this.tickPosition--;
+                }
+
+                this.loadedEntityList.remove(index);
+            }
+
+            // CraftBukkit end
+        } // Spigot
+
         this.onEntityRemoved(p_72973_1_);
     }
 
     public void addWorldAccess(IWorldAccess p_72954_1_)
     {
@@ -1138,49 +1523,75 @@
         int j = MathHelper.floor_double(p_72945_2_.maxX + 1.0D);
         int k = MathHelper.floor_double(p_72945_2_.minY);
         int l = MathHelper.floor_double(p_72945_2_.maxY + 1.0D);
         int i1 = MathHelper.floor_double(p_72945_2_.minZ);
         int j1 = MathHelper.floor_double(p_72945_2_.maxZ + 1.0D);
+        // Spigot start
+        int ystart = ((k - 1) < 0) ? 0 : (k - 1);
 
-        for (int k1 = i; k1 < j; ++k1)
+        for (int chunkx = (i >> 4); chunkx <= ((j - 1) >> 4); chunkx++)
         {
-            for (int l1 = i1; l1 < j1; ++l1)
+            int cx = chunkx << 4;
+
+            for (int chunkz = (i1 >> 4); chunkz <= ((j1 - 1) >> 4); chunkz++)
             {
-                if (this.isBlockLoaded(new BlockPos(k1, 64, l1)))
+                if (!this.isChunkLoaded(chunkx, chunkz, true))
                 {
-                    for (int i2 = k - 1; i2 < l; ++i2)
-                    {
-                        BlockPos blockpos = new BlockPos(k1, i2, l1);
-                        boolean flag = p_72945_1_.isOutsideBorder();
-                        boolean flag1 = this.isInsideBorder(this.getWorldBorder(), p_72945_1_);
+                    continue;
+                }
 
-                        if (flag && flag1)
+                int cz = chunkz << 4;
+                Chunk chunk = this.getChunkFromChunkCoords(chunkx, chunkz);
+                // Compute ranges within chunk
+                int xstart = (i < cx) ? cx : i;
+                int xend = (j < (cx + 16)) ? j : (cx + 16);
+                int zstart = (i1 < cz) ? cz : i1;
+                int zend = (j1 < (cz + 16)) ? j1 : (cz + 16);
+
+                // Loop through blocks within chunk
+                for (int x = xstart; x < xend; x++)
+                {
+                    for (int z = zstart; z < zend; z++)
+                    {
+                        for (int y = ystart; y < l; y++)
                         {
-                            p_72945_1_.setOutsideBorder(false);
-                        }
-                        else if (!flag && !flag1)
-                        {
-                            p_72945_1_.setOutsideBorder(true);
-                        }
+                            BlockPos blockposition = new BlockPos(x, y, z);
+                            boolean flag = p_72945_1_.isOutsideBorder();
+                            boolean flag1 = this.isInsideBorder(this.getWorldBorder(), p_72945_1_);
 
-                        IBlockState iblockstate;
+                            if (flag && flag1)
+                            {
+                                p_72945_1_.setOutsideBorder(false);
+                            }
+                            else if (!flag && !flag1)
+                            {
+                                p_72945_1_.setOutsideBorder(true);
+                            }
 
-                        if (!this.getWorldBorder().contains(blockpos) && flag1)
-                        {
-                            iblockstate = Blocks.stone.getDefaultState();
-                        }
-                        else
-                        {
-                            iblockstate = this.getBlockState(blockpos);
-                        }
+                            IBlockState iblockdata;
+                            IBlockState block;
 
-                        iblockstate.getBlock().addCollisionBoxesToList(this, blockpos, iblockstate, p_72945_2_, arraylist, p_72945_1_);
+                            if (!this.getWorldBorder().contains(blockposition) && flag1)
+                            {
+                                block = Blocks.stone.getDefaultState();
+                            }
+                            else
+                            {
+                                block = chunk.getBlockState(blockposition);
+                            }
+
+                            if (block != null)
+                            {
+                                block.getBlock().addCollisionBoxesToList(this, blockposition, block, p_72945_2_, arraylist, p_72945_1_);
+                            }
+                        }
                     }
                 }
             }
         }
 
+        // Spigot end
         double d0 = 0.25D;
         List list = this.getEntitiesWithinAABBExcludingEntity(p_72945_1_, p_72945_2_.expand(d0, d0, d0));
 
         for (int j2 = 0; j2 < list.size(); ++j2)
         {
@@ -1279,100 +1690,15 @@
         f2 = (float)((double)f2 * (1.0D - (double)(this.getThunderStrength(p_72967_1_) * 5.0F) / 16.0D));
         f2 = 1.0F - f2;
         return (int)(f2 * 11.0F);
     }
 
-    @SideOnly(Side.CLIENT)
-    public void removeWorldAccess(IWorldAccess p_72848_1_)
-    {
-        this.worldAccesses.remove(p_72848_1_);
-    }
-
-    @SideOnly(Side.CLIENT)
-    public float getSunBrightness(float p_72971_1_)
-    {
-        float f1 = this.getCelestialAngle(p_72971_1_);
-        float f2 = 1.0F - (MathHelper.cos(f1 * (float)Math.PI * 2.0F) * 2.0F + 0.2F);
-        f2 = MathHelper.clamp_float(f2, 0.0F, 1.0F);
-        f2 = 1.0F - f2;
-        f2 = (float)((double)f2 * (1.0D - (double)(this.getRainStrength(p_72971_1_) * 5.0F) / 16.0D));
-        f2 = (float)((double)f2 * (1.0D - (double)(this.getThunderStrength(p_72971_1_) * 5.0F) / 16.0D));
-        return f2 * 0.8F + 0.2F;
-    }
-
-    @SideOnly(Side.CLIENT)
-    public Vec3 getSkyColor(Entity p_72833_1_, float p_72833_2_)
-    {
-        float f1 = this.getCelestialAngle(p_72833_2_);
-        float f2 = MathHelper.cos(f1 * (float)Math.PI * 2.0F) * 2.0F + 0.5F;
-        f2 = MathHelper.clamp_float(f2, 0.0F, 1.0F);
-        int i = MathHelper.floor_double(p_72833_1_.posX);
-        int j = MathHelper.floor_double(p_72833_1_.posY);
-        int k = MathHelper.floor_double(p_72833_1_.posZ);
-        BlockPos blockpos = new BlockPos(i, j, k);
-        BiomeGenBase biomegenbase = this.getBiomeGenForCoords(blockpos);
-        float f3 = biomegenbase.getFloatTemperature(blockpos);
-        int l = biomegenbase.getSkyColorByTemp(f3);
-        float f4 = (float)(l >> 16 & 255) / 255.0F;
-        float f5 = (float)(l >> 8 & 255) / 255.0F;
-        float f6 = (float)(l & 255) / 255.0F;
-        f4 *= f2;
-        f5 *= f2;
-        f6 *= f2;
-        float f7 = this.getRainStrength(p_72833_2_);
-        float f8;
-        float f9;
-
-        if (f7 > 0.0F)
-        {
-            f8 = (f4 * 0.3F + f5 * 0.59F + f6 * 0.11F) * 0.6F;
-            f9 = 1.0F - f7 * 0.75F;
-            f4 = f4 * f9 + f8 * (1.0F - f9);
-            f5 = f5 * f9 + f8 * (1.0F - f9);
-            f6 = f6 * f9 + f8 * (1.0F - f9);
-        }
-
-        f8 = this.getThunderStrength(p_72833_2_);
-
-        if (f8 > 0.0F)
-        {
-            f9 = (f4 * 0.3F + f5 * 0.59F + f6 * 0.11F) * 0.2F;
-            float f10 = 1.0F - f8 * 0.75F;
-            f4 = f4 * f10 + f9 * (1.0F - f10);
-            f5 = f5 * f10 + f9 * (1.0F - f10);
-            f6 = f6 * f10 + f9 * (1.0F - f10);
-        }
-
-        if (this.lastLightningBolt > 0)
-        {
-            f9 = (float)this.lastLightningBolt - p_72833_2_;
-
-            if (f9 > 1.0F)
-            {
-                f9 = 1.0F;
-            }
-
-            f9 *= 0.45F;
-            f4 = f4 * (1.0F - f9) + 0.8F * f9;
-            f5 = f5 * (1.0F - f9) + 0.8F * f9;
-            f6 = f6 * (1.0F - f9) + 1.0F * f9;
-        }
-
-        return new Vec3((double)f4, (double)f5, (double)f6);
-    }
-
     public float getCelestialAngle(float p_72826_1_)
     {
         return this.provider.calculateCelestialAngle(this.worldInfo.getWorldTime(), p_72826_1_);
     }
 
-    @SideOnly(Side.CLIENT)
-    public int getMoonPhase()
-    {
-        return this.provider.getMoonPhase(this.worldInfo.getWorldTime());
-    }
-
     public float getCurrentMoonPhaseFactor()
     {
         return WorldProvider.moonPhaseFactors[this.provider.getMoonPhase(this.worldInfo.getWorldTime())];
     }
 
@@ -1380,56 +1706,10 @@
     {
         float f1 = this.getCelestialAngle(p_72929_1_);
         return f1 * (float)Math.PI * 2.0F;
     }
 
-    @SideOnly(Side.CLIENT)
-    public Vec3 getCloudColour(float p_72824_1_)
-    {
-        float f1 = this.getCelestialAngle(p_72824_1_);
-        float f2 = MathHelper.cos(f1 * (float)Math.PI * 2.0F) * 2.0F + 0.5F;
-        f2 = MathHelper.clamp_float(f2, 0.0F, 1.0F);
-        float f3 = (float)(this.cloudColour >> 16 & 255L) / 255.0F;
-        float f4 = (float)(this.cloudColour >> 8 & 255L) / 255.0F;
-        float f5 = (float)(this.cloudColour & 255L) / 255.0F;
-        float f6 = this.getRainStrength(p_72824_1_);
-        float f7;
-        float f8;
-
-        if (f6 > 0.0F)
-        {
-            f7 = (f3 * 0.3F + f4 * 0.59F + f5 * 0.11F) * 0.6F;
-            f8 = 1.0F - f6 * 0.95F;
-            f3 = f3 * f8 + f7 * (1.0F - f8);
-            f4 = f4 * f8 + f7 * (1.0F - f8);
-            f5 = f5 * f8 + f7 * (1.0F - f8);
-        }
-
-        f3 *= f2 * 0.9F + 0.1F;
-        f4 *= f2 * 0.9F + 0.1F;
-        f5 *= f2 * 0.85F + 0.15F;
-        f7 = this.getThunderStrength(p_72824_1_);
-
-        if (f7 > 0.0F)
-        {
-            f8 = (f3 * 0.3F + f4 * 0.59F + f5 * 0.11F) * 0.2F;
-            float f9 = 1.0F - f7 * 0.95F;
-            f3 = f3 * f9 + f8 * (1.0F - f9);
-            f4 = f4 * f9 + f8 * (1.0F - f9);
-            f5 = f5 * f9 + f8 * (1.0F - f9);
-        }
-
-        return new Vec3((double)f3, (double)f4, (double)f5);
-    }
-
-    @SideOnly(Side.CLIENT)
-    public Vec3 getFogColor(float p_72948_1_)
-    {
-        float f1 = this.getCelestialAngle(p_72948_1_);
-        return this.provider.getFogColor(f1, p_72948_1_);
-    }
-
     public BlockPos getPrecipitationHeight(BlockPos p_175725_1_)
     {
         return this.getChunkFromBlockCoords(p_175725_1_).getPrecipitationHeight(p_175725_1_);
     }
 
@@ -1451,25 +1731,22 @@
         }
 
         return blockpos1;
     }
 
-    @SideOnly(Side.CLIENT)
-    public float getStarBrightness(float p_72880_1_)
+    public void scheduleUpdate(BlockPos pos, Block blockIn, int delay)
     {
-        float f1 = this.getCelestialAngle(p_72880_1_);
-        float f2 = 1.0F - (MathHelper.cos(f1 * (float)Math.PI * 2.0F) * 2.0F + 0.25F);
-        f2 = MathHelper.clamp_float(f2, 0.0F, 1.0F);
-        return f2 * f2 * 0.5F;
     }
 
-    public void scheduleUpdate(BlockPos pos, Block blockIn, int delay) {}
+    public void updateBlockTick(BlockPos p_175654_1_, Block p_175654_2_, int p_175654_3_, int p_175654_4_)
+    {
+    }
 
-    public void updateBlockTick(BlockPos p_175654_1_, Block p_175654_2_, int p_175654_3_, int p_175654_4_) {}
+    public void func_180497_b(BlockPos pos, Block p_180497_2_, int p_180497_3_, int p_180497_4_)
+    {
+    }
 
-    public void func_180497_b(BlockPos pos, Block p_180497_2_, int p_180497_3_, int p_180497_4_) {}
-
     public void updateEntities()
     {
         this.theProfiler.startSection("entities");
         this.theProfiler.startSection("global");
         int i;
@@ -1479,10 +1756,18 @@
 
         for (i = 0; i < this.weatherEffects.size(); ++i)
         {
             entity = (Entity)this.weatherEffects.get(i);
 
+            // CraftBukkit start - Fixed an NPE
+            if (entity == null)
+            {
+                continue;
+            }
+
+            // CraftBukkit end
+
             try
             {
                 ++entity.ticksExisted;
                 entity.onUpdate();
             }
@@ -1531,14 +1816,23 @@
             this.onEntityRemoved((Entity)this.unloadedEntityList.get(i));
         }
 
         this.unloadedEntityList.clear();
         this.theProfiler.endStartSection("regular");
+        ActivationRange.activateEntities(this); // Spigot
+        timings.entityTick.startTiming(); // Spigot
+        guardEntityList = true; // Spigot
+        // CraftBukkit start - Use field for loop variable
+        int entitiesThisCycle = 0;
 
-        for (i = 0; i < this.loadedEntityList.size(); ++i)
+        if (tickPosition < 0) tickPosition = 0;
+
+        for (entityLimiter.initTick(); entitiesThisCycle < loadedEntityList.size() && (entitiesThisCycle % 10 == 0 || entityLimiter.shouldContinue()); tickPosition++, entitiesThisCycle++)
         {
-            entity = (Entity)this.loadedEntityList.get(i);
+            tickPosition = (tickPosition < loadedEntityList.size()) ? tickPosition : 0;
+            entity = (Entity)this.loadedEntityList.get(tickPosition);
+            // CraftBukkit end
 
             if (entity.ridingEntity != null)
             {
                 if (!entity.ridingEntity.isDead && entity.ridingEntity.riddenByEntity == entity)
                 {
@@ -1553,11 +1847,13 @@
 
             if (!entity.isDead)
             {
                 try
                 {
+                    SpigotTimings.tickEntityTimer.startTiming(); // Spigot
                     this.updateEntity(entity);
+                    SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
                 }
                 catch (Throwable throwable1)
                 {
                     crashreport = CrashReport.makeCrashReport(throwable1, "Ticking entity");
                     crashreportcategory = crashreport.makeCategory("Entity being ticked");
@@ -1577,81 +1873,120 @@
                 if (entity.addedToChunk && this.isChunkLoaded(j, l, true))
                 {
                     this.getChunkFromChunkCoords(j, l).removeEntity(entity);
                 }
 
-                this.loadedEntityList.remove(i--);
+                guardEntityList = false; // Spigot
+                this.loadedEntityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
+                guardEntityList = true; // Spigot
                 this.onEntityRemoved(entity);
             }
 
             this.theProfiler.endSection();
         }
 
+        guardEntityList = false; // Spigot
+        timings.entityTick.stopTiming(); // Spigot
         this.theProfiler.endStartSection("blockEntities");
         this.processingLoadedTiles = true;
-        Iterator iterator = this.tickableTileEntities.iterator();
 
-        while (iterator.hasNext())
+        // CraftBukkit start - From below, clean up tile entities before ticking them
+        if (!this.tileEntitiesToBeRemoved.isEmpty())
         {
-            TileEntity tileentity = (TileEntity)iterator.next();
+            this.tickableTileEntities.removeAll(this.tileEntitiesToBeRemoved);
+            this.loadedTileEntityList.removeAll(this.tileEntitiesToBeRemoved);
+            this.tileEntitiesToBeRemoved.clear();
+        }
 
+        // CraftBukkit end
+        this.initializeHoppers(); // Spigot - Initializes hoppers which have been added recently.
+        // Spigot start
+        int tilesThisCycle = 0;
+
+        for (tileLimiter.initTick(); tilesThisCycle < tickableTileEntities.size() && (tilesThisCycle % 10 == 0 || tileLimiter.shouldContinue()); tileTickPosition++, tilesThisCycle++)
+        {
+            tileTickPosition = (tileTickPosition < tickableTileEntities.size()) ? tileTickPosition : 0;
+            TileEntity tileentity = (TileEntity)this.tickableTileEntities.get(tileTickPosition);
+
+            if (tileentity == null)
+            {
+                getServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
+                this.tickableTileEntities.remove(tileTickPosition--);
+                continue;
+            }
+
+            // Spigot end
+
             if (!tileentity.isInvalid() && tileentity.hasWorldObj())
             {
                 BlockPos blockpos = tileentity.getPos();
 
                 if (this.isBlockLoaded(blockpos) && this.worldBorder.contains(blockpos))
                 {
                     try
                     {
+                        tileentity.tickTimer.startTiming(); // Spigot
                         ((IUpdatePlayerListBox)tileentity).update();
                     }
                     catch (Throwable throwable)
                     {
                         CrashReport crashreport1 = CrashReport.makeCrashReport(throwable, "Ticking block entity");
                         CrashReportCategory crashreportcategory1 = crashreport1.makeCategory("Block entity being ticked");
                         tileentity.addInfoToCrashReport(crashreportcategory1);
                         throw new ReportedException(crashreport1);
+                        // Spigot Start
                     }
+                    finally
+                    {
+                        tileentity.tickTimer.stopTiming();
+                    }
+
+                    // Spigot end
                 }
             }
 
             if (tileentity.isInvalid())
             {
-                iterator.remove();
+                this.tickableTileEntities.remove(tileTickPosition--); // Spigot
                 this.loadedTileEntityList.remove(tileentity);
 
                 if (this.isBlockLoaded(tileentity.getPos()))
                 {
                     this.getChunkFromBlockCoords(tileentity.getPos()).removeTileEntity(tileentity.getPos());
                 }
             }
         }
 
+        timings.tileEntityTick.stopTiming(); // Spigot
+        timings.tileEntityPending.startTiming(); // Spigot
         this.processingLoadedTiles = false;
-
-        if (!this.tileEntitiesToBeRemoved.isEmpty())
-        {
+        // CraftBukkit start - Moved up
+        /*
+        if (!this.tileEntitiesToBeRemoved.isEmpty()) {
             this.tickableTileEntities.removeAll(this.tileEntitiesToBeRemoved);
             this.loadedTileEntityList.removeAll(this.tileEntitiesToBeRemoved);
             this.tileEntitiesToBeRemoved.clear();
         }
-
+        */
+        // CraftBukkit end
         this.theProfiler.endStartSection("pendingBlockEntities");
 
         if (!this.addedTileEntityList.isEmpty())
         {
             for (int k = 0; k < this.addedTileEntityList.size(); ++k)
             {
                 TileEntity tileentity1 = (TileEntity)this.addedTileEntityList.get(k);
 
                 if (!tileentity1.isInvalid())
                 {
-                    if (!this.loadedTileEntityList.contains(tileentity1))
-                    {
+                    // CraftBukkit start - Order matters, moved down
+                    /*
+                    if (!this.loadedTileEntityList.contains(tileentity1)) {
                         this.addTileEntity(tileentity1);
                     }
-
+                    */
+                    // CraftBukkit end
                     if (this.isBlockLoaded(tileentity1.getPos()))
                     {
                         this.getChunkFromBlockCoords(tileentity1.getPos()).addTileEntity(tileentity1.getPos(), tileentity1);
                     }
 
@@ -1660,10 +1995,11 @@
             }
 
             this.addedTileEntityList.clear();
         }
 
+        timings.tileEntityPending.stopTiming(); // Spigot
         this.theProfiler.endSection();
         this.theProfiler.endSection();
     }
 
     public boolean addTileEntity(TileEntity tile)
@@ -1710,12 +2046,20 @@
     {
         int i = MathHelper.floor_double(p_72866_1_.posX);
         int j = MathHelper.floor_double(p_72866_1_.posZ);
         byte b0 = 32;
 
-        if (!p_72866_2_ || this.isAreaLoaded(i - b0, 0, j - b0, i + b0, 0, j + b0, true))
+        // Spigot Start
+        if (!ActivationRange.checkIfActive(p_72866_1_))
         {
+            p_72866_1_.ticksExisted++;
+            p_72866_1_.inactiveTick();
+        }
+        else
+        {
+            p_72866_1_.tickTimer.startTiming();
+            // Spigot End
             p_72866_1_.lastTickPosX = p_72866_1_.posX;
             p_72866_1_.lastTickPosY = p_72866_1_.posY;
             p_72866_1_.lastTickPosZ = p_72866_1_.posZ;
             p_72866_1_.prevRotationYaw = p_72866_1_.rotationYaw;
             p_72866_1_.prevRotationPitch = p_72866_1_.rotationPitch;
@@ -1795,10 +2139,12 @@
                 {
                     p_72866_1_.riddenByEntity.ridingEntity = null;
                     p_72866_1_.riddenByEntity = null;
                 }
             }
+
+            p_72866_1_.tickTimer.stopTiming(); // Spigot
         }
     }
 
     public boolean checkNoEntityCollision(AxisAlignedBB p_72855_1_)
     {
@@ -2097,22 +2443,10 @@
         {
             return false;
         }
     }
 
-    @SideOnly(Side.CLIENT)
-    public String getDebugLoadedEntities()
-    {
-        return "All: " + this.loadedEntityList.size();
-    }
-
-    @SideOnly(Side.CLIENT)
-    public String getProviderName()
-    {
-        return this.chunkProvider.makeString();
-    }
-
     public TileEntity getTileEntity(BlockPos pos)
     {
         if (!this.isValid(pos))
         {
             return null;
@@ -2178,10 +2512,11 @@
                         tileentity1.invalidate();
                         iterator.remove();
                     }
                 }
 
+                tileEntityIn.setWorldObj(this); // Spigot - No null worlds
                 this.addedTileEntityList.add(tileEntityIn);
             }
             else
             {
                 this.addTileEntity(tileEntityIn);
@@ -2379,32 +2714,60 @@
         }
     }
 
     protected void setActivePlayerChunksAndCheckLight()
     {
-        this.activeChunkSet.clear();
+        // this.activeChunkSet.clear(); // CraftBukkit - removed
         this.theProfiler.startSection("buildList");
         int i;
         EntityPlayer entityplayer;
         int j;
         int k;
         int l;
+        // Spigot start
+        int optimalChunks = spigotConfig.chunksPerTick;
 
+        // Quick conditions to allow us to exist early
+        if (optimalChunks <= 0 || playerEntities.isEmpty())
+        {
+            return;
+        }
+
+        // Keep chunks with growth inside of the optimal chunk range
+        int chunksPerPlayer = Math.min(200, Math.max(1, (int)(((optimalChunks - playerEntities.size()) / (double)playerEntities.size()) + 0.5)));
+        int randRange = 3 + chunksPerPlayer / 30;
+        // Limit to normal tick radius - including view distance
+        randRange = (randRange > chunkTickRadius) ? chunkTickRadius : randRange;
+        // odds of growth happening vs growth happening in vanilla
+        this.growthOdds = this.modifiedOdds = Math.max(35, Math.min(100, ((chunksPerPlayer + 1) * 100F) / 15F));
+
+        // Spigot end
         for (i = 0; i < this.playerEntities.size(); ++i)
         {
             entityplayer = (EntityPlayer)this.playerEntities.get(i);
             j = MathHelper.floor_double(entityplayer.posX / 16.0D);
             k = MathHelper.floor_double(entityplayer.posZ / 16.0D);
             l = this.getRenderDistanceChunks();
+            // Spigot start - Always update the chunk the player is on
+            long key = chunkToKey(j, k);
+            int existingPlayers = Math.max(0, activeChunkSet.get(key)); // filter out -1
+            activeChunkSet.put(key, (short)(existingPlayers + 1));
 
-            for (int i1 = -l; i1 <= l; ++i1)
+            // Check and see if we update the chunks surrounding the player this tick
+            for (int chunk = 0; chunk < chunksPerPlayer; chunk++)
             {
-                for (int j1 = -l; j1 <= l; ++j1)
+                int dx = (rand.nextBoolean() ? 1 : -1) * rand.nextInt(randRange);
+                int dz = (rand.nextBoolean() ? 1 : -1) * rand.nextInt(randRange);
+                long hash = chunkToKey(dx + j, dz + k);
+
+                if (!activeChunkSet.contains(hash) && this.chunkProvider.chunkExists(dx + j, dz + k))
                 {
-                    this.activeChunkSet.add(new ChunkCoordIntPair(i1 + j, j1 + k));
+                    activeChunkSet.put(hash, (short) - 1); // no players
                 }
             }
+
+            // Spigot End
         }
 
         this.theProfiler.endSection();
 
         if (this.ambientTickCountdown > 0)
@@ -2412,11 +2775,11 @@
             --this.ambientTickCountdown;
         }
 
         this.theProfiler.startSection("playerCheckLight");
 
-        if (!this.playerEntities.isEmpty())
+        if (spigotConfig.randomLightUpdates && !this.playerEntities.isEmpty())   // Spigot
         {
             i = this.rand.nextInt(this.playerEntities.size());
             entityplayer = (EntityPlayer)this.playerEntities.get(i);
             j = MathHelper.floor_double(entityplayer.posX) + this.rand.nextInt(11) - 5;
             k = MathHelper.floor_double(entityplayer.posY) + this.rand.nextInt(11) - 5;
@@ -2623,12 +2986,16 @@
         }
     }
 
     public boolean checkLightFor(EnumSkyBlock lightType, BlockPos pos)
     {
-        if (!this.isAreaLoaded(pos, 17, false))
+        // CraftBukkit start - Use neighbor cache instead of looking up
+        Chunk chunk = this.getChunkIfLoaded(pos.getX() >> 4, pos.getZ() >> 4);
+
+        if (chunk == null || !chunk.areNeighborsLoaded(1)/* !this.isAreaLoaded(pos, 17, false) */)
         {
+            // CraftBukkit end
             return false;
         }
         else
         {
             int i = 0;
@@ -2902,16 +3269,10 @@
     public Entity getEntityByID(int id)
     {
         return (Entity)this.entitiesById.lookup(id);
     }
 
-    @SideOnly(Side.CLIENT)
-    public List getLoadedEntityList()
-    {
-        return this.loadedEntityList;
-    }
-
     public void markChunkDirty(BlockPos pos, TileEntity unusedTileEntity)
     {
         if (this.isBlockLoaded(pos))
         {
             this.getChunkFromBlockCoords(pos).setChunkModified();
@@ -2925,27 +3286,50 @@
 
         while (iterator.hasNext())
         {
             Entity entity = (Entity)iterator.next();
 
-            if ((!(entity instanceof EntityLiving) || !((EntityLiving)entity).isNoDespawnRequired()) && entityType.isAssignableFrom(entity.getClass()))
+            // CraftBukkit start - Split out persistent check, don't apply it to special persistent mobs
+            if (entity instanceof EntityLiving)
             {
+                EntityLiving entityinsentient = (EntityLiving)entity;
+
+                if (entityinsentient.canDespawn() && entityinsentient.isNoDespawnRequired())
+                {
+                    continue;
+                }
+            }
+
+            if (entityType.isAssignableFrom(entity.getClass()))
+            {
+                // if ((!(entity instanceof EntityLiving) || !((EntityLiving) entity).isNoDespawnRequired()) && entityType.isAssignableFrom(entity.getClass())) {
+                // CraftBukkit end
                 ++i;
             }
         }
 
         return i;
     }
 
     public void loadEntities(Collection entityCollection)
     {
-        this.loadedEntityList.addAll(entityCollection);
+        AsyncCatcher.catchOp("entity world add"); // Spigot
+        // CraftBukkit start
+        // this.loadedEntityList.addAll(entityCollection);
         Iterator iterator = entityCollection.iterator();
 
         while (iterator.hasNext())
         {
             Entity entity = (Entity)iterator.next();
+
+            if (entity == null)
+            {
+                continue;
+            }
+
+            this.loadedEntityList.add(entity);
+            // CraftBukkit end
             this.onEntityAdded(entity);
         }
     }
 
     public void unloadEntities(Collection entityCollection)
@@ -2955,11 +3339,15 @@
 
     public boolean canBlockBePlaced(Block p_175716_1_, BlockPos p_175716_2_, boolean p_175716_3_, EnumFacing p_175716_4_, Entity p_175716_5_, ItemStack p_175716_6_)
     {
         Block block1 = this.getBlockState(p_175716_2_).getBlock();
         AxisAlignedBB axisalignedbb = p_175716_3_ ? null : p_175716_1_.getCollisionBoundingBox(this, p_175716_2_, p_175716_1_.getDefaultState());
-        return axisalignedbb != null && !this.checkNoEntityCollision(axisalignedbb, p_175716_5_) ? false : (block1.getMaterial() == Material.circuits && p_175716_1_ == Blocks.anvil ? true : block1.getMaterial().isReplaceable() && p_175716_1_.canReplace(this, p_175716_2_, p_175716_4_, p_175716_6_));
+        boolean defaultReturn = axisalignedbb != null && !this.checkNoEntityCollision(axisalignedbb, p_175716_5_) ? false : (block1.getMaterial() == Material.circuits && p_175716_1_ == Blocks.anvil ? true : block1.getMaterial().isReplaceable() && p_175716_1_.canReplace(this, p_175716_2_, p_175716_4_, p_175716_6_));
+        BlockCanBuildEvent event = new BlockCanBuildEvent(this.getWorld().getBlockAt(p_175716_2_.getX(), p_175716_2_.getY(), p_175716_2_.getZ()), CraftMagicNumbers.getId(p_175716_1_), defaultReturn);
+        this.getServer().getPluginManager().callEvent(event);
+        return event.isBuildable();
+        // CraftBukkit end
     }
 
     public int getStrongPower(BlockPos pos, EnumFacing direction)
     {
         IBlockState iblockstate = this.getBlockState(pos);
@@ -3077,10 +3465,18 @@
 
         for (int i = 0; i < this.playerEntities.size(); ++i)
         {
             EntityPlayer entityplayer1 = (EntityPlayer)this.playerEntities.get(i);
 
+            // CraftBukkit start - Fixed an NPE
+            if (entityplayer1 == null || entityplayer1.isDead)
+            {
+                continue;
+            }
+
+            // CraftBukkit end
+
             if (IEntitySelector.NOT_SPECTATING.apply(entityplayer1))
             {
                 double d5 = entityplayer1.getDistanceSq(x, y, z);
 
                 if ((distance < 0.0D || d5 < distance * distance) && (d4 == -1.0D || d5 < d4))
@@ -3142,24 +3538,15 @@
         }
 
         return null;
     }
 
-    @SideOnly(Side.CLIENT)
-    public void sendQuittingDisconnectingPacket() {}
-
-    public void checkSessionLock() throws MinecraftException
+    public void checkSessionLock() throws MinecraftException   // CraftBukkit - added throws // SpigotMCP NOTE -- already added
     {
         this.saveHandler.checkSessionLock();
     }
 
-    @SideOnly(Side.CLIENT)
-    public void setTotalWorldTime(long p_82738_1_)
-    {
-        this.worldInfo.incrementTotalWorldTime(p_82738_1_);
-    }
-
     public long getSeed()
     {
         return this.worldInfo.getSeed();
     }
 
@@ -3193,38 +3580,19 @@
     public void setSpawnPoint(BlockPos pos)
     {
         this.worldInfo.setSpawn(pos);
     }
 
-    @SideOnly(Side.CLIENT)
-    public void joinEntityInSurroundings(Entity entityIn)
+    public boolean isBlockModifiable(EntityPlayer player, BlockPos pos)
     {
-        int i = MathHelper.floor_double(entityIn.posX / 16.0D);
-        int j = MathHelper.floor_double(entityIn.posZ / 16.0D);
-        byte b0 = 2;
-
-        for (int k = i - b0; k <= i + b0; ++k)
-        {
-            for (int l = j - b0; l <= j + b0; ++l)
-            {
-                this.getChunkFromChunkCoords(k, l);
-            }
-        }
-
-        if (!this.loadedEntityList.contains(entityIn))
-        {
-            this.loadedEntityList.add(entityIn);
-        }
+        return true;
     }
 
-    public boolean isBlockModifiable(EntityPlayer player, BlockPos pos)
+    public void setEntityState(Entity entityIn, byte state)
     {
-        return true;
     }
 
-    public void setEntityState(Entity entityIn, byte state) {}
-
     public IChunkProvider getChunkProvider()
     {
         return this.chunkProvider;
     }
 
@@ -3246,36 +3614,36 @@
     public GameRules getGameRules()
     {
         return this.worldInfo.getGameRulesInstance();
     }
 
-    public void updateAllPlayersSleepingFlag() {}
+    public void updateAllPlayersSleepingFlag()
+    {
+    }
 
-    public float getThunderStrength(float delta)
+    // CraftBukkit start
+    // Calls the method that checks to see if players are sleeping
+    // Called by CraftPlayer.setPermanentSleeping()
+    public void checkSleepStatus()
     {
-        return (this.prevThunderingStrength + (this.thunderingStrength - this.prevThunderingStrength) * delta) * this.getRainStrength(delta);
+        if (!this.isRemote)
+        {
+            this.updateAllPlayersSleepingFlag();
+        }
     }
+    // CraftBukkit end
 
-    @SideOnly(Side.CLIENT)
-    public void setThunderStrength(float p_147442_1_)
+    public float getThunderStrength(float delta)
     {
-        this.prevThunderingStrength = p_147442_1_;
-        this.thunderingStrength = p_147442_1_;
+        return (this.prevThunderingStrength + (this.thunderingStrength - this.prevThunderingStrength) * delta) * this.getRainStrength(delta);
     }
 
     public float getRainStrength(float delta)
     {
         return this.prevRainingStrength + (this.rainingStrength - this.prevRainingStrength) * delta;
     }
 
-    @SideOnly(Side.CLIENT)
-    public void setRainStrength(float strength)
-    {
-        this.prevRainingStrength = strength;
-        this.rainingStrength = strength;
-    }
-
     public boolean isThundering()
     {
         return (double)this.getThunderStrength(1.0F) > 0.9D;
     }
 
@@ -3418,22 +3786,10 @@
         }
 
         return crashreportcategory;
     }
 
-    @SideOnly(Side.CLIENT)
-    public boolean extendedLevelsInChunkCache()
-    {
-        return false;
-    }
-
-    @SideOnly(Side.CLIENT)
-    public double getHorizon()
-    {
-        return this.worldInfo.getTerrainType() == WorldType.FLAT ? 0.0D : 63.0D;
-    }
-
     public void sendBlockBreakProgress(int breakerId, BlockPos pos, int progress)
     {
         for (int k = 0; k < this.worldAccesses.size(); ++k)
         {
             IWorldAccess iworldaccess = (IWorldAccess)this.worldAccesses.get(k);
@@ -3449,13 +3805,10 @@
         }
 
         return this.theCalendar;
     }
 
-    @SideOnly(Side.CLIENT)
-    public void makeFireworks(double x, double y, double z, double motionX, double motionY, double motionZ, NBTTagCompound compund) {}
-
     public Scoreboard getScoreboard()
     {
         return this.worldScoreboard;
     }
 
@@ -3517,16 +3870,10 @@
     public void setSkylightSubtracted(int newSkylightSubtracted)
     {
         this.skylightSubtracted = newSkylightSubtracted;
     }
 
-    @SideOnly(Side.CLIENT)
-    public int getLastLightningBolt()
-    {
-        return this.lastLightningBolt;
-    }
-
     public void setLastLightningBolt(int lastLightningBoltIn)
     {
         this.lastLightningBolt = lastLightningBoltIn;
     }
 
@@ -3549,8 +3896,8 @@
     {
         BlockPos blockpos = this.getSpawnPoint();
         int k = x * 16 + 8 - blockpos.getX();
         int l = z * 16 + 8 - blockpos.getZ();
         short short1 = 128;
-        return k >= -short1 && k <= short1 && l >= -short1 && l <= short1;
+        return k >= -short1 && k <= short1 && l >= -short1 && l <= short1 && this.keepSpawnInMemory; // CraftBukkit - Added 'this.keepSpawnInMemory'
     }
 }
