--- decompiled\net\minecraft\world\WorldServer.java
+++ src\main\java\net\minecraft\world\WorldServer.java
@@ -1,51 +1,58 @@
 package net.minecraft.world;
 
-import com.google.common.base.Predicate;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-import com.google.common.util.concurrent.ListenableFuture;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.UUID;
+import java.util.logging.Level;
+
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockEventData;
+import net.minecraft.block.BlockJukebox.TileEntityJukebox;
+import net.minecraft.block.ITileEntityProvider;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityLivingBase;
 import net.minecraft.entity.EntityTracker;
 import net.minecraft.entity.EnumCreatureType;
-import net.minecraft.entity.INpc;
 import net.minecraft.entity.effect.EntityLightningBolt;
-import net.minecraft.entity.passive.EntityAnimal;
-import net.minecraft.entity.passive.EntityWaterMob;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.init.Blocks;
 import net.minecraft.init.Items;
 import net.minecraft.item.Item;
 import net.minecraft.network.play.server.S19PacketEntityStatus;
 import net.minecraft.network.play.server.S24PacketBlockAction;
 import net.minecraft.network.play.server.S27PacketExplosion;
 import net.minecraft.network.play.server.S2APacketParticles;
-import net.minecraft.network.play.server.S2BPacketChangeGameState;
 import net.minecraft.network.play.server.S2CPacketSpawnGlobalEntity;
 import net.minecraft.profiler.Profiler;
 import net.minecraft.scoreboard.ScoreboardSaveData;
 import net.minecraft.scoreboard.ServerScoreboard;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.management.PlayerManager;
 import net.minecraft.tileentity.TileEntity;
+import net.minecraft.tileentity.TileEntityBeacon;
+import net.minecraft.tileentity.TileEntityBrewingStand;
+import net.minecraft.tileentity.TileEntityChest;
+import net.minecraft.tileentity.TileEntityDispenser;
+import net.minecraft.tileentity.TileEntityDropper;
+import net.minecraft.tileentity.TileEntityEnderChest;
+import net.minecraft.tileentity.TileEntityFurnace;
+import net.minecraft.tileentity.TileEntityHopper;
+import net.minecraft.tileentity.TileEntityMobSpawner;
+import net.minecraft.tileentity.TileEntityNote;
+import net.minecraft.tileentity.TileEntitySign;
 import net.minecraft.util.AxisAlignedBB;
 import net.minecraft.util.BlockPos;
 import net.minecraft.util.EnumParticleTypes;
 import net.minecraft.util.IProgressUpdate;
 import net.minecraft.util.IThreadListener;
@@ -65,20 +72,43 @@
 import net.minecraft.world.gen.feature.WorldGeneratorBonusChest;
 import net.minecraft.world.gen.structure.StructureBoundingBox;
 import net.minecraft.world.storage.ISaveHandler;
 import net.minecraft.world.storage.MapStorage;
 import net.minecraft.world.storage.WorldInfo;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
+
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.WeatherType;
+import org.bukkit.World.Environment;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.CraftTravelAgent;
+import org.bukkit.craftbukkit.generator.CustomChunkGenerator;
+import org.bukkit.craftbukkit.generator.InternalChunkGenerator;
+import org.bukkit.craftbukkit.generator.NetherChunkGenerator;
+import org.bukkit.craftbukkit.generator.NormalChunkGenerator;
+import org.bukkit.craftbukkit.generator.SkyLandsChunkGenerator;
+import org.bukkit.event.block.BlockFormEvent;
+import org.bukkit.event.weather.LightningStrikeEvent;
+import org.bukkit.event.world.WorldSaveEvent;
+import org.bukkit.generator.ChunkGenerator;
 
+import com.google.common.base.Predicate;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.ListenableFuture;
+
+import gnu.trove.iterator.TLongShortIterator;
+
 public class WorldServer extends World implements IThreadListener
 {
+
     private static final Logger logger = LogManager.getLogger();
     private final MinecraftServer mcServer;
-    private final EntityTracker theEntityTracker;
+    public EntityTracker theEntityTracker; // SpigotMCP -- Apply access transformation
     private final PlayerManager thePlayerManager;
     private final Set pendingTickListEntriesHashSet = Sets.newHashSet();
     private final TreeSet pendingTickListEntriesTreeSet = new TreeSet();
     private final Map entitiesByUuid = Maps.newHashMap();
     public ChunkProviderServer theChunkProviderServer;
@@ -88,23 +118,42 @@
     private final Teleporter worldTeleporter;
     private final SpawnerAnimals mobSpawner = new SpawnerAnimals();
     protected final VillageSiege villageSiege = new VillageSiege(this);
     private WorldServer.ServerBlockEventList[] field_147490_S = new WorldServer.ServerBlockEventList[] {new WorldServer.ServerBlockEventList(null), new WorldServer.ServerBlockEventList(null)};
     private int blockEventCacheIndex;
-    private static final List bonusChestContent = Lists.newArrayList(new WeightedRandomChestContent[] {new WeightedRandomChestContent(Items.stick, 0, 1, 3, 10), new WeightedRandomChestContent(Item.getItemFromBlock(Blocks.planks), 0, 1, 3, 10), new WeightedRandomChestContent(Item.getItemFromBlock(Blocks.log), 0, 1, 3, 10), new WeightedRandomChestContent(Items.stone_axe, 0, 1, 1, 3), new WeightedRandomChestContent(Items.wooden_axe, 0, 1, 1, 5), new WeightedRandomChestContent(Items.stone_pickaxe, 0, 1, 1, 3), new WeightedRandomChestContent(Items.wooden_pickaxe, 0, 1, 1, 5), new WeightedRandomChestContent(Items.apple, 0, 2, 3, 5), new WeightedRandomChestContent(Items.bread, 0, 2, 3, 3), new WeightedRandomChestContent(Item.getItemFromBlock(Blocks.log2), 0, 1, 3, 10)});
+    private static final List bonusChestContent = Lists.newArrayList(new WeightedRandomChestContent[]
+                {
+                    new WeightedRandomChestContent(Items.stick, 0, 1, 3, 10),
+                    new WeightedRandomChestContent(Item.getItemFromBlock(Blocks.planks), 0, 1, 3, 10),
+                    new WeightedRandomChestContent(Item.getItemFromBlock(Blocks.log), 0, 1, 3, 10),
+                    new WeightedRandomChestContent(Items.stone_axe, 0, 1, 1, 3),
+                    new WeightedRandomChestContent(Items.wooden_axe, 0, 1, 1, 5),
+                    new WeightedRandomChestContent(Items.stone_pickaxe, 0, 1, 1, 3),
+                    new WeightedRandomChestContent(Items.wooden_pickaxe, 0, 1, 1, 5),
+                    new WeightedRandomChestContent(Items.apple, 0, 2, 3, 5),
+                    new WeightedRandomChestContent(Items.bread, 0, 2, 3, 3),
+                    new WeightedRandomChestContent(Item.getItemFromBlock(Blocks.log2), 0, 1, 3, 10)
+                });
     private List pendingTickListEntriesThisTick = Lists.newArrayList();
     private static final String __OBFID = "CL_00001437";
 
-    public WorldServer(MinecraftServer server, ISaveHandler saveHandlerIn, WorldInfo info, int dimensionId, Profiler profilerIn)
+    // CraftBukkit start
+    public final int dimension;
+
+    // Add env and gen to constructor
+    public WorldServer(MinecraftServer server, ISaveHandler saveHandlerIn, WorldInfo info, int dimensionId, Profiler profilerIn, Environment env, ChunkGenerator gen)
     {
-        super(saveHandlerIn, info, WorldProvider.getProviderForDimension(dimensionId), profilerIn, false);
+        super(saveHandlerIn, info, WorldProvider.getProviderForDimension(dimensionId), profilerIn, false, gen, env);
+        this.dimension = dimensionId;
+        this.pvpMode = server.isPVPEnabled();
+        // CraftBukkit end
         this.mcServer = server;
         this.theEntityTracker = new EntityTracker(this);
-        this.thePlayerManager = new PlayerManager(this);
+        this.thePlayerManager = new PlayerManager(this, spigotConfig.viewDistance); // Spigot
         this.provider.registerWorld(this);
         this.chunkProvider = this.createChunkProvider();
-        this.worldTeleporter = new Teleporter(this);
+        this.worldTeleporter = new CraftTravelAgent(this); // CraftBukkit
         this.calculateInitialSkylight();
         this.calculateInitialWeather();
         this.getWorldBorder().setSize(server.getMaxWorldSize());
     }
 
@@ -152,10 +201,136 @@
         }
 
         return this;
     }
 
+    // CraftBukkit start
+    @Override
+    public net.minecraft.tileentity.TileEntity getTileEntity(BlockPos pos)
+    {
+        TileEntity result = super.getTileEntity(pos);
+        Block type = getBlockState(pos).getBlock();
+
+        if (type == Blocks.chest || type == Blocks.trapped_chest)   // Spigot
+        {
+            if (!(result instanceof TileEntityChest))
+            {
+                result = fixTileEntity(pos, type, result);
+            }
+        }
+        else if (type == Blocks.furnace)
+        {
+            if (!(result instanceof TileEntityFurnace))
+            {
+                result = fixTileEntity(pos, type, result);
+            }
+        }
+        else if (type == Blocks.dropper)
+        {
+            if (!(result instanceof TileEntityDropper))
+            {
+                result = fixTileEntity(pos, type, result);
+            }
+        }
+        else if (type == Blocks.dispenser)
+        {
+            if (!(result instanceof TileEntityDispenser))
+            {
+                result = fixTileEntity(pos, type, result);
+            }
+        }
+        else if (type == Blocks.jukebox)
+        {
+            if (!(result instanceof TileEntityJukebox))
+            {
+                result = fixTileEntity(pos, type, result);
+            }
+        }
+        else if (type == Blocks.noteblock)
+        {
+            if (!(result instanceof TileEntityNote))
+            {
+                result = fixTileEntity(pos, type, result);
+            }
+        }
+        else if (type == Blocks.mob_spawner)
+        {
+            if (!(result instanceof TileEntityMobSpawner))
+            {
+                result = fixTileEntity(pos, type, result);
+            }
+        }
+        else if ((type == Blocks.standing_sign) || (type == Blocks.wall_sign))
+        {
+            if (!(result instanceof TileEntitySign))
+            {
+                result = fixTileEntity(pos, type, result);
+            }
+        }
+        else if (type == Blocks.ender_chest)
+        {
+            if (!(result instanceof TileEntityEnderChest))
+            {
+                result = fixTileEntity(pos, type, result);
+            }
+        }
+        else if (type == Blocks.brewing_stand)
+        {
+            if (!(result instanceof TileEntityBrewingStand))
+            {
+                result = fixTileEntity(pos, type, result);
+            }
+        }
+        else if (type == Blocks.beacon)
+        {
+            if (!(result instanceof TileEntityBeacon))
+            {
+                result = fixTileEntity(pos, type, result);
+            }
+        }
+        else if (type == Blocks.hopper)
+        {
+            if (!(result instanceof TileEntityHopper))
+            {
+                result = fixTileEntity(pos, type, result);
+            }
+        }
+
+        return result;
+    }
+
+    private net.minecraft.tileentity.TileEntity fixTileEntity(BlockPos pos, Block type, TileEntity found)
+    {
+        this.getServer().getLogger().log(Level.SEVERE, "Block at {0},{1},{2} is {3} but has {4}" + ". " + "Bukkit will attempt to fix this, but there may be additional damage that we cannot recover.", new Object[] {pos.getX(), pos.getY(), pos.getZ(), org.bukkit.Material.getMaterial(Block.getIdFromBlock(type)).toString(), found});
+
+        if (type instanceof ITileEntityProvider)
+        {
+            TileEntity replacement = ((ITileEntityProvider)type).createNewTileEntity(this, type.getMetaFromState(this.getBlockState(pos)));
+            replacement.worldObj = this;
+            this.setTileEntity(pos, replacement);
+            return replacement;
+        }
+        else
+        {
+            this.getServer().getLogger().severe("Don't know how to fix for this type... Can't do anything! :(");
+            return found;
+        }
+    }
+
+    private boolean canSpawn(int x, int z)
+    {
+        if (this.generator != null)
+        {
+            return this.generator.canSpawn(this.getWorld(), x, z);
+        }
+        else
+        {
+            return this.provider.canCoordinateBeSpawn(x, z);
+        }
+    }
+    // CraftBukkit end
+
     public void tick()
     {
         super.tick();
 
         if (this.getWorldInfo().isHardcoreModeEnabled() && this.getDifficulty() != EnumDifficulty.HARD)
@@ -175,16 +350,23 @@
 
             this.wakeAllPlayers();
         }
 
         this.theProfiler.startSection("mobSpawner");
+        // CraftBukkit start - Only call spawner if we have players online and the world allows for mobs or animals
+        long time = this.worldInfo.getWorldTotalTime();
 
-        if (this.getGameRules().getGameRuleBooleanValue("doMobSpawning") && this.worldInfo.getTerrainType() != WorldType.DEBUG_WORLD)
+        if (this.getGameRules().getGameRuleBooleanValue("doMobSpawning") && this.worldInfo.getTerrainType() != WorldType.DEBUG_WORLD && (this.spawnHostileMobs || this.spawnPeacefulMobs) && (this instanceof WorldServer && this.playerEntities.size() > 0))
         {
-            this.mobSpawner.findChunksForSpawning(this, this.spawnHostileMobs, this.spawnPeacefulMobs, this.worldInfo.getWorldTotalTime() % 400L == 0L);
+            timings.mobSpawn.startTiming(); // Spigot
+            this.mobSpawner.findChunksForSpawning(this, this.spawnHostileMobs && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.spawnPeacefulMobs && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldInfo.getWorldTotalTime() % 400L == 0L);
+            timings.mobSpawn.stopTiming(); // Spigot
+            // CraftBukkit end
         }
 
+        // CraftBukkit end
+        timings.doChunkUnload.startTiming(); // Spigot
         this.theProfiler.endStartSection("chunkSource");
         this.chunkProvider.unloadQueuedChunks();
         int j = this.calculateSkylightSubtracted(1.0F);
 
         if (j != this.getSkylightSubtracted())
@@ -197,23 +379,39 @@
         if (this.getGameRules().getGameRuleBooleanValue("doDaylightCycle"))
         {
             this.worldInfo.setWorldTime(this.worldInfo.getWorldTime() + 1L);
         }
 
+        timings.doChunkUnload.stopTiming(); // Spigot
         this.theProfiler.endStartSection("tickPending");
+        timings.doTickPending.startTiming(); // Spigot
         this.tickUpdates(false);
+        timings.doTickPending.stopTiming(); // Spigot
         this.theProfiler.endStartSection("tickBlocks");
+        timings.doTickTiles.startTiming(); // Spigot
         this.updateBlocks();
+        timings.doTickTiles.stopTiming(); // Spigot
         this.theProfiler.endStartSection("chunkMap");
+        timings.doChunkMap.startTiming(); // Spigot
         this.thePlayerManager.updatePlayerInstances();
+        timings.doChunkMap.stopTiming(); // Spigot
         this.theProfiler.endStartSection("village");
+        timings.doVillages.startTiming(); // Spigot
         this.villageCollectionObj.tick();
         this.villageSiege.tick();
+        timings.doVillages.stopTiming(); // Spigot
         this.theProfiler.endStartSection("portalForcer");
+        timings.doPortalForcer.startTiming(); // Spigot
         this.worldTeleporter.removeStalePortalLocations(this.getTotalWorldTime());
+        timings.doPortalForcer.stopTiming(); // Spigot
         this.theProfiler.endSection();
+        timings.doSounds.startTiming(); // Spigot
         this.sendQueuedBlockEvents();
+        timings.doSounds.stopTiming(); // Spigot
+        timings.doChunkGC.startTiming(); // Spigot
+        this.getWorld().processChunkGC(); // CraftBukkit
+        timings.doChunkGC.stopTiming(); // Spigot
     }
 
     public BiomeGenBase.SpawnListEntry func_175734_a(EnumCreatureType p_175734_1_, BlockPos p_175734_2_)
     {
         List list = this.getChunkProvider().func_177458_a(p_175734_1_, p_175734_2_);
@@ -242,11 +440,11 @@
 
                 if (entityplayer.isSpectator())
                 {
                     ++i;
                 }
-                else if (entityplayer.isPlayerSleeping())
+                else if (entityplayer.isPlayerSleeping() || entityplayer.fauxSleeping)   // CraftBukkit
                 {
                     ++j;
                 }
             }
 
@@ -272,96 +470,120 @@
         this.resetRainAndThunder();
     }
 
     private void resetRainAndThunder()
     {
-        this.worldInfo.setRainTime(0);
+        // CraftBukkit Start
         this.worldInfo.setRaining(false);
-        this.worldInfo.setThunderTime(0);
+
+        // CraftBukkit start
+        // If we stop due to everyone sleeping we should reset the weather duration to some other random value.
+        // Not that everyone ever manages to get the whole server to sleep at the same time....
+        if (!this.worldInfo.isRaining())
+        {
+            this.worldInfo.setRainTime(0);
+        }
+
+        // CraftBukkit end
         this.worldInfo.setThundering(false);
+
+        // CraftBukkit start
+        // If we stop due to everyone sleeping we should reset the weather duration to some other random value.
+        // Not that everyone ever manages to get the whole server to sleep at the same time....
+        if (!this.worldInfo.isThundering())
+        {
+            this.worldInfo.setThunderTime(0);
+        }
+
+        // CraftBukkit end
     }
 
     public boolean areAllPlayersAsleep()
     {
         if (this.allPlayersSleeping && !this.isRemote)
         {
             Iterator iterator = this.playerEntities.iterator();
+            // CraftBukkit - This allows us to assume that some people are in bed but not really, allowing time to pass in spite of AFKers
+            boolean foundActualSleepers = false;
             EntityPlayer entityplayer;
 
             do
             {
                 if (!iterator.hasNext())
                 {
                     return true;
                 }
 
                 entityplayer = (EntityPlayer)iterator.next();
+
+                // CraftBukkit start
+                if (entityplayer.isPlayerFullyAsleep())
+                {
+                    foundActualSleepers = true;
+                }
             }
-            while (!entityplayer.isSpectator() && entityplayer.isPlayerFullyAsleep());
+            while (!entityplayer.isSpectator() && (entityplayer.isPlayerFullyAsleep() || entityplayer.fauxSleeping));
 
+            // CraftBukkit end
             return false;
         }
         else
         {
             return false;
         }
     }
 
-    @SideOnly(Side.CLIENT)
-    public void setInitialSpawnLocation()
-    {
-        if (this.worldInfo.getSpawnY() <= 0)
-        {
-            this.worldInfo.setSpawnY(64);
-        }
-
-        int i = this.worldInfo.getSpawnX();
-        int j = this.worldInfo.getSpawnZ();
-        int k = 0;
-
-        while (this.getGroundAboveSeaLevel(new BlockPos(i, 0, j)).getMaterial() == Material.air)
-        {
-            i += this.rand.nextInt(8) - this.rand.nextInt(8);
-            j += this.rand.nextInt(8) - this.rand.nextInt(8);
-            ++k;
-
-            if (k == 10000)
-            {
-                break;
-            }
-        }
-
-        this.worldInfo.setSpawnX(i);
-        this.worldInfo.setSpawnZ(j);
-    }
-
     protected void updateBlocks()
     {
         super.updateBlocks();
+        // SpigotMCP Note -- The following is a mess. Its in such bad shape no-one is actualy sure what it does ;)
 
         if (this.worldInfo.getTerrainType() == WorldType.DEBUG_WORLD)
         {
-            Iterator iterator1 = this.activeChunkSet.iterator();
+            // Spigot start
+            TLongShortIterator iterator = this.activeChunkSet.iterator();
 
-            while (iterator1.hasNext())
+            while (iterator.hasNext())
             {
-                ChunkCoordIntPair chunkcoordintpair1 = (ChunkCoordIntPair)iterator1.next();
-                this.getChunkFromChunkCoords(chunkcoordintpair1.chunkXPos, chunkcoordintpair1.chunkZPos).func_150804_b(false);
+                iterator.advance();
+                long chunkCoord = iterator.key();
+                this.getChunkFromChunkCoords(World.keyToX(chunkCoord), World.keyToZ(chunkCoord)).func_150804_b(false);
+                // Spigot end
             }
         }
         else
         {
             int i = 0;
             int j = 0;
 
-            for (Iterator iterator = this.activeChunkSet.iterator(); iterator.hasNext(); this.theProfiler.endSection())
+            // CraftBukkit start
+            // for (Iterator iterator = this.activeChunkSet.iterator(); iterator.hasNext(); this.theProfiler.endSection()) {
+            //    ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) iterator.next();
+            //    int k = chunkcoordintpair.chunkXPos * 16;
+            //     int l = chunkcoordintpair.chunkZPos * 16;
+            // Spigot Start
+            for (TLongShortIterator iter = activeChunkSet.iterator(); iter.hasNext();)
             {
-                ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair)iterator.next();
-                int k = chunkcoordintpair.chunkXPos * 16;
-                int l = chunkcoordintpair.chunkZPos * 16;
+                iter.advance();
+                long chunkCoord = iter.key();
+                int chunkX = World.keyToX(chunkCoord);
+                int chunkZ = World.keyToZ(chunkCoord);
+
+                // If unloaded, or in procedd of being unloaded, drop it
+                if ((!this.chunkProvider.chunkExists(chunkX, chunkZ)) || (this.theChunkProviderServer.droppedChunksSet.contains(chunkX, chunkZ)))
+                {
+                    iter.remove();
+                    continue;
+                }
+
+                // Spigot end
+                // ChunkCoordIntPair chunkcoordintpair1 = (ChunkCoordIntPair) iterator.next();
+                int k = chunkX * 16;
+                int l = chunkZ * 16;
                 this.theProfiler.startSection("getChunk");
-                Chunk chunk = this.getChunkFromChunkCoords(chunkcoordintpair.chunkXPos, chunkcoordintpair.chunkZPos);
+                Chunk chunk = this.getChunkFromChunkCoords(chunkX, chunkZ);
+                // CraftBukkit end
                 this.playMoodSoundAndCheckLight(k, l, chunk);
                 this.theProfiler.endStartSection("tickChunk");
                 chunk.func_150804_b(false);
                 this.theProfiler.endStartSection("thunder");
                 int i1;
@@ -388,16 +610,38 @@
                     blockpos = this.getPrecipitationHeight(new BlockPos(k + (i1 & 15), 0, l + (i1 >> 8 & 15)));
                     BlockPos blockpos1 = blockpos.down();
 
                     if (this.func_175662_w(blockpos1))
                     {
-                        this.setBlockState(blockpos1, Blocks.ice.getDefaultState());
+                        // CraftBukkit start
+                        BlockState blockState = this.getWorld().getBlockAt(blockpos1.getX(), blockpos1.getY(), blockpos1.getZ()).getState();
+                        blockState.setTypeId(Block.getIdFromBlock(Blocks.ice));
+                        BlockFormEvent iceBlockForm = new BlockFormEvent(blockState.getBlock(), blockState);
+                        this.getServer().getPluginManager().callEvent(iceBlockForm);
+
+                        if (!iceBlockForm.isCancelled())
+                        {
+                            blockState.update(true);
+                        }
+
+                        // CraftBukkit end
                     }
 
                     if (this.isRaining() && this.canSnowAt(blockpos, true))
                     {
-                        this.setBlockState(blockpos, Blocks.snow_layer.getDefaultState());
+                        // CraftBukkit start
+                        BlockState blockState = this.getWorld().getBlockAt(blockpos.getX(), blockpos.getY(), blockpos.getZ()).getState();
+                        blockState.setTypeId(Block.getIdFromBlock(Blocks.snow_layer));
+                        BlockFormEvent snow = new BlockFormEvent(blockState.getBlock(), blockState);
+                        this.getServer().getPluginManager().callEvent(snow);
+
+                        if (!snow.isCancelled())
+                        {
+                            blockState.update(true);
+                        }
+
+                        // CraftBukkit end
                     }
 
                     if (this.isRaining() && this.getBiomeGenForCoords(blockpos1).canSpawnLightningBolt())
                     {
                         this.getBlockState(blockpos1).getBlock().fillWithRain(this, blockpos1);
@@ -439,10 +683,18 @@
                         }
                     }
                 }
             }
         }
+
+        // Spigot Start
+        if (spigotConfig.clearChunksOnTick)
+        {
+            activeChunkSet.clear();
+        }
+
+        // Spigot End
     }
 
     protected BlockPos func_175736_a(BlockPos pos)
     {
         BlockPos blockpos1 = this.getPrecipitationHeight(pos);
@@ -533,11 +785,11 @@
         }
     }
 
     public void updateEntities()
     {
-        if (this.playerEntities.isEmpty())
+        if (false && this.playerEntities.isEmpty())    // CraftBukkit - this prevents entity cleanup, other issues on servers with no players
         {
             if (this.updateEntityTick++ >= 1200)
             {
                 return;
             }
@@ -546,10 +798,11 @@
         {
             this.resetUpdateEntityTick();
         }
 
         super.updateEntities();
+        spigotConfig.currentPrimedTnt = 0; // Spigot
     }
 
     public void resetUpdateEntityTick()
     {
         this.updateEntityTick = 0;
@@ -571,11 +824,21 @@
             }
             else
             {
                 if (i > 1000)
                 {
-                    i = 1000;
+                    // CraftBukkit start - If the server has too much to process over time, try to alleviate that
+                    if (i > 20 * 1000)
+                    {
+                        i = i / 20;
+                    }
+                    else
+                    {
+                        i = 1000;
+                    }
+
+                    // CraftBukkit end
                 }
 
                 this.theProfiler.startSection("cleaning");
                 NextTickListEntry nextticklistentry;
 
@@ -691,24 +954,25 @@
         }
 
         return arraylist;
     }
 
-    public void updateEntityWithOptionalForce(Entity p_72866_1_, boolean p_72866_2_)
-    {
-        if (!this.func_175735_ai() && (p_72866_1_ instanceof EntityAnimal || p_72866_1_ instanceof EntityWaterMob))
-        {
+    // CraftBukkit start - We prevent spawning in general, so this butchering is not needed
+    /*
+    public void updateEntityWithOptionalForce(Entity p_72866_1_, boolean p_72866_2_) {
+        if (!this.func_175735_ai() && (p_72866_1_ instanceof EntityAnimal || p_72866_1_ instanceof EntityWaterMob)) {
             p_72866_1_.setDead();
         }
 
-        if (!this.func_175738_ah() && p_72866_1_ instanceof INpc)
-        {
+        if (!this.func_175738_ah() && p_72866_1_ instanceof INpc) {
             p_72866_1_.setDead();
         }
 
         super.updateEntityWithOptionalForce(p_72866_1_, p_72866_2_);
     }
+    */
+    // CraftBukkit end
 
     private boolean func_175738_ah()
     {
         return this.mcServer.getCanSpawnNPCs();
     }
@@ -719,29 +983,74 @@
     }
 
     protected IChunkProvider createChunkProvider()
     {
         IChunkLoader ichunkloader = this.saveHandler.getChunkLoader(this.provider);
-        this.theChunkProviderServer = new ChunkProviderServer(this, ichunkloader, this.provider.createChunkGenerator());
+        // CraftBukkit start
+        InternalChunkGenerator gen;
+
+        if (this.generator != null)
+        {
+            gen = new CustomChunkGenerator(this, this.getSeed(), this.generator);
+        }
+        else if (this.provider instanceof WorldProviderHell)
+        {
+            gen = new NetherChunkGenerator(this, this.getSeed());
+        }
+        else if (this.provider instanceof WorldProviderEnd)
+        {
+            gen = new SkyLandsChunkGenerator(this, this.getSeed());
+        }
+        else
+        {
+            gen = new NormalChunkGenerator(this, this.getSeed());
+        }
+
+        this.theChunkProviderServer = new ChunkProviderServer(this, ichunkloader, gen);
+        // CraftBukkit end
         return this.theChunkProviderServer;
     }
 
     public List func_147486_a(int p_147486_1_, int p_147486_2_, int p_147486_3_, int p_147486_4_, int p_147486_5_, int p_147486_6_)
     {
         ArrayList arraylist = Lists.newArrayList();
 
-        for (int k1 = 0; k1 < this.loadedTileEntityList.size(); ++k1)
+        // CraftBukkit start - Get tile entities from chunks instead of world
+        for (int chunkX = (p_147486_1_ >> 4); chunkX <= ((p_147486_4_ - 1) >> 4); chunkX++)
         {
-            TileEntity tileentity = (TileEntity)this.loadedTileEntityList.get(k1);
+            for (int chunkZ = (p_147486_3_ >> 4); chunkZ <= ((p_147486_6_ - 1) >> 4); chunkZ++)
+            {
+                Chunk chunk = getChunkFromChunkCoords(chunkX, chunkZ);
+
+                if (chunk == null)
+                {
+                    continue;
+                }
+
+                for (Object te : chunk.chunkTileEntityMap.values())
+                {
+                    TileEntity tileentity = (TileEntity)te;
+
+                    if ((tileentity.pos.getX() >= p_147486_1_) && (tileentity.pos.getY() >= p_147486_2_) && (tileentity.pos.getZ() >= p_147486_3_) && (tileentity.pos.getX() < p_147486_4_) && (tileentity.pos.getY() < p_147486_5_) && (tileentity.pos.getZ() < p_147486_6_))
+                    {
+                        arraylist.add(tileentity);
+                    }
+                }
+            }
+        }
+
+        /*
+        for (int k1 = 0; k1 < this.loadedTileEntityList.size(); ++k1) {
+            TileEntity tileentity = (TileEntity) this.loadedTileEntityList.get(k1);
             BlockPos blockpos = tileentity.getPos();
 
-            if (blockpos.getX() >= p_147486_1_ && blockpos.getY() >= p_147486_2_ && blockpos.getZ() >= p_147486_3_ && blockpos.getX() < p_147486_4_ && blockpos.getY() < p_147486_5_ && blockpos.getZ() < p_147486_6_)
-            {
+            if (blockpos.getX() >= p_147486_1_ && blockpos.getY() >= p_147486_2_ && blockpos.getZ() >= p_147486_3_ && blockpos.getX() < p_147486_4_ && blockpos.getY() < p_147486_5_ && blockpos.getZ() < p_147486_6_) {
                 arraylist.add(tileentity);
             }
         }
-
+        */
+        // CraftBukkit End
         return arraylist;
     }
 
     public boolean isBlockModifiable(EntityPlayer player, BlockPos pos)
     {
@@ -817,10 +1126,33 @@
             BlockPos blockpos = worldchunkmanager.findBiomePosition(0, 0, 256, list, random);
             int i = 0;
             int j = this.provider.getAverageGroundLevel();
             int k = 0;
 
+            // CraftBukkit start
+            if (this.generator != null)
+            {
+                Random rand = new Random(this.getSeed());
+                Location spawn = this.generator.getFixedSpawnLocation(((WorldServer)this).getWorld(), rand);
+
+                if (spawn != null)
+                {
+                    if (spawn.getWorld() != ((WorldServer)this).getWorld())
+                    {
+                        throw new IllegalStateException("Cannot set spawn point for " + this.worldInfo.getWorldName() + " to be in another world (" + spawn.getWorld().getName() + ")");
+                    }
+                    else
+                    {
+                        this.worldInfo.setSpawn(new BlockPos(spawn.getBlockX(), spawn.getBlockY(), spawn.getBlockZ()));
+                        this.findingSpawnPoint = false;
+                        return;
+                    }
+                }
+            }
+
+            // CraftBukkit end
+
             if (blockpos != null)
             {
                 i = blockpos.getX();
                 k = blockpos.getZ();
             }
@@ -829,11 +1161,11 @@
                 logger.warn("Unable to find spawn biome");
             }
 
             int l = 0;
 
-            while (!this.provider.canCoordinateBeSpawn(i, k))
+            while (!this.canSpawn(i, k))   // CraftBukkit - use our own canSpawn
             {
                 i += random.nextInt(64) - random.nextInt(64);
                 k += random.nextInt(64) - random.nextInt(64);
                 ++l;
 
@@ -873,14 +1205,16 @@
     public BlockPos func_180504_m()
     {
         return this.provider.getSpawnCoordinate();
     }
 
-    public void saveAllChunks(boolean p_73044_1_, IProgressUpdate p_73044_2_) throws MinecraftException
+    public void saveAllChunks(boolean p_73044_1_, IProgressUpdate p_73044_2_) throws MinecraftException   // CraftBukkit - added throws // SpigotMCP NOTE -- already added by mcp
     {
         if (this.chunkProvider.canSave())
         {
+            Bukkit.getPluginManager().callEvent(new WorldSaveEvent(getWorld())); // CraftBukkit
+
             if (p_73044_2_ != null)
             {
                 p_73044_2_.displaySavingString("Saving level");
             }
 
@@ -890,11 +1224,12 @@
             {
                 p_73044_2_.displayLoadingString("Saving chunks");
             }
 
             this.chunkProvider.saveChunks(p_73044_1_, p_73044_2_);
-            List list = this.theChunkProviderServer.func_152380_a();
+            // CraftBukkit - ArrayList -> Collection
+            Collection list = this.theChunkProviderServer.func_152380_a();
             Iterator iterator = list.iterator();
 
             while (iterator.hasNext())
             {
                 Chunk chunk = (Chunk)iterator.next();
@@ -913,11 +1248,11 @@
         {
             this.chunkProvider.saveExtraData();
         }
     }
 
-    protected void saveLevel() throws MinecraftException
+    protected void saveLevel() throws MinecraftException   // CraftBukkit - added throws // SpigotMCP Note -- mcp al    ready added
     {
         this.checkSessionLock();
         this.worldInfo.setBorderSize(this.getWorldBorder().getDiameter());
         this.worldInfo.getBorderCenterX(this.getWorldBorder().getCenterX());
         this.worldInfo.getBorderCenterZ(this.getWorldBorder().getCenterZ());
@@ -925,15 +1260,22 @@
         this.worldInfo.setBorderDamagePerBlock(this.getWorldBorder().getDamageAmount());
         this.worldInfo.setBorderWarningDistance(this.getWorldBorder().getWarningDistance());
         this.worldInfo.setBorderWarningTime(this.getWorldBorder().getWarningTime());
         this.worldInfo.setBorderLerpTarget(this.getWorldBorder().getTargetSize());
         this.worldInfo.setBorderLerpTime(this.getWorldBorder().getTimeUntilTarget());
+
+        // CraftBukkit start - save worldMaps once, rather than once per shared world
+        if (!(this instanceof WorldServerMulti))
+        {
+            this.mapStorage.saveAllData();
+        }
+
         this.saveHandler.saveWorldInfoWithPlayer(this.worldInfo, this.mcServer.getConfigurationManager().getHostPlayerData());
-        this.mapStorage.saveAllData();
+        // CraftBukkit end
     }
 
-    protected void onEntityAdded(Entity p_72923_1_)
+    public void onEntityAdded(Entity p_72923_1_)
     {
         super.onEntityAdded(p_72923_1_);
         this.entitiesById.addKey(p_72923_1_.getEntityId(), p_72923_1_);
         this.entitiesByUuid.put(p_72923_1_.getUniqueID(), p_72923_1_);
         Entity[] aentity = p_72923_1_.getParts();
@@ -945,11 +1287,11 @@
                 this.entitiesById.addKey(aentity[i].getEntityId(), aentity[i]);
             }
         }
     }
 
-    protected void onEntityRemoved(Entity p_72847_1_)
+    public void onEntityRemoved(Entity p_72847_1_)
     {
         super.onEntityRemoved(p_72847_1_);
         this.entitiesById.removeObject(p_72847_1_.getEntityId());
         this.entitiesByUuid.remove(p_72847_1_.getUniqueID());
         Entity[] aentity = p_72847_1_.getParts();
@@ -963,13 +1305,23 @@
         }
     }
 
     public boolean addWeatherEffect(Entity p_72942_1_)
     {
+        // CraftBukkit start
+        LightningStrikeEvent lightning = new LightningStrikeEvent(this.getWorld(), (org.bukkit.entity.LightningStrike)p_72942_1_.getBukkitEntity());
+        this.getServer().getPluginManager().callEvent(lightning);
+
+        if (lightning.isCancelled())
+        {
+            return false;
+        }
+
         if (super.addWeatherEffect(p_72942_1_))
         {
-            this.mcServer.getConfigurationManager().sendToAllNear(p_72942_1_.posX, p_72942_1_.posY, p_72942_1_.posZ, 512.0D, this.provider.getDimensionId(), new S2CPacketSpawnGlobalEntity(p_72942_1_));
+            this.mcServer.getConfigurationManager().sendToAllNear(p_72942_1_.posX, p_72942_1_.posY, p_72942_1_.posZ, 512.0D, this.dimension, new S2CPacketSpawnGlobalEntity(p_72942_1_));
+            // CraftBukkit end
             return true;
         }
         else
         {
             return false;
@@ -981,14 +1333,25 @@
         this.getEntityTracker().func_151248_b(entityIn, new S19PacketEntityStatus(entityIn, state));
     }
 
     public Explosion newExplosion(Entity p_72885_1_, double p_72885_2_, double p_72885_4_, double p_72885_6_, float p_72885_8_, boolean p_72885_9_, boolean p_72885_10_)
     {
+        // CraftBukkit start
+        Explosion explosion = super.newExplosion(p_72885_1_, p_72885_2_, p_72885_4_, p_72885_6_, p_72885_8_, p_72885_9_, p_72885_10_);
+
+        if (explosion.wasCanceled)
+        {
+            return explosion;
+        }
+
+        /*
         Explosion explosion = new Explosion(this, p_72885_1_, p_72885_2_, p_72885_4_, p_72885_6_, p_72885_8_, p_72885_9_, p_72885_10_);
         explosion.doExplosionA();
         explosion.doExplosionB(false);
+        */
 
+        // CraftBukkit end - TODO: Check if explosions are still properly implemented
         if (!p_72885_10_)
         {
             explosion.func_180342_d();
         }
 
@@ -1038,11 +1401,12 @@
             {
                 BlockEventData blockeventdata = (BlockEventData)iterator.next();
 
                 if (this.fireBlockEvent(blockeventdata))
                 {
-                    this.mcServer.getConfigurationManager().sendToAllNear((double)blockeventdata.getPosition().getX(), (double)blockeventdata.getPosition().getY(), (double)blockeventdata.getPosition().getZ(), 64.0D, this.provider.getDimensionId(), new S24PacketBlockAction(blockeventdata.getPosition(), blockeventdata.getBlock(), blockeventdata.getEventID(), blockeventdata.getEventParameter()));
+                    // CraftBukkit - this.worldProvider.dimension -> this.dimension
+                    this.mcServer.getConfigurationManager().sendToAllNear((double)blockeventdata.getPosition().getX(), (double)blockeventdata.getPosition().getY(), (double)blockeventdata.getPosition().getZ(), 64.0D, this.dimension, new S24PacketBlockAction(blockeventdata.getPosition(), blockeventdata.getBlock(), blockeventdata.getEventID(), blockeventdata.getEventParameter()));
                 }
             }
 
             this.field_147490_S[i].clear();
         }
@@ -1061,35 +1425,31 @@
 
     protected void updateWeather()
     {
         boolean flag = this.isRaining();
         super.updateWeather();
-
-        if (this.prevRainingStrength != this.rainingStrength)
+        // CraftBukkit Start
         {
-            this.mcServer.getConfigurationManager().sendPacketToAllPlayersInDimension(new S2BPacketChangeGameState(7, this.rainingStrength), this.provider.getDimensionId());
+            // Only send weather packets to those affected
+            for (int i = 0; i < this.playerEntities.size(); ++i)
+            {
+                if (((EntityPlayer)this.playerEntities.get(i)).worldObj == this)
+                {
+                    ((EntityPlayerMP)this.playerEntities.get(i)).setPlayerWeather((!flag ? WeatherType.DOWNFALL : WeatherType.CLEAR), false);
+                }
+            }
         }
 
-        if (this.prevThunderingStrength != this.thunderingStrength)
+        for (int i = 0; i < this.playerEntities.size(); ++i)
         {
-            this.mcServer.getConfigurationManager().sendPacketToAllPlayersInDimension(new S2BPacketChangeGameState(8, this.thunderingStrength), this.provider.getDimensionId());
-        }
-
-        if (flag != this.isRaining())
-        {
-            if (flag)
+            if (((EntityPlayer)this.playerEntities.get(i)).worldObj == this)
             {
-                this.mcServer.getConfigurationManager().sendPacketToAllPlayers(new S2BPacketChangeGameState(2, 0.0F));
+                ((EntityPlayerMP)this.playerEntities.get(i)).updateWeather(this.prevRainingStrength, this.rainingStrength, this.prevThunderingStrength, this.thunderingStrength);
             }
-            else
-            {
-                this.mcServer.getConfigurationManager().sendPacketToAllPlayers(new S2BPacketChangeGameState(1, 0.0F));
-            }
-
-            this.mcServer.getConfigurationManager().sendPacketToAllPlayers(new S2BPacketChangeGameState(7, this.rainingStrength));
-            this.mcServer.getConfigurationManager().sendPacketToAllPlayers(new S2BPacketChangeGameState(8, this.thunderingStrength));
         }
+
+        // CraftBukkit end
     }
 
     protected int getRenderDistanceChunks()
     {
         return this.mcServer.getConfigurationManager().getViewDistance();
@@ -1113,22 +1473,32 @@
     public Teleporter getDefaultTeleporter()
     {
         return this.worldTeleporter;
     }
 
-    public void spawnParticle(EnumParticleTypes particleType, double xCoord, double yCoord, double zCoord, int numberOfParticles, double p_175739_9_, double p_175739_11_, double p_175739_13_, double p_175739_15_, int ... p_175739_17_)
+    public void spawnParticle(EnumParticleTypes particleType, double xCoord, double yCoord, double zCoord, int numberOfParticles, double p_175739_9_, double p_175739_11_, double p_175739_13_, double p_175739_15_, int... p_175739_17_)
     {
         this.spawnParticle(particleType, false, xCoord, yCoord, zCoord, numberOfParticles, p_175739_9_, p_175739_11_, p_175739_13_, p_175739_15_, p_175739_17_);
     }
 
-    public void spawnParticle(EnumParticleTypes particleType, boolean p_180505_2_, double xCoord, double yCoord, double zCoord, int numberOfParticles, double xOffset, double yOffset, double zOffset, double p_180505_16_, int ... p_180505_18_)
+    public void spawnParticle(EnumParticleTypes particleType, boolean p_180505_2_, double xCoord, double yCoord, double zCoord, int numberOfParticles, double xOffset, double yOffset, double zOffset, double p_180505_16_, int... p_180505_18_)
     {
+        this.spawnParticle(null, particleType, p_180505_2_, xCoord, yCoord, zCoord, numberOfParticles, xOffset, yOffset, zOffset, p_180505_16_, p_180505_18_);
+    }
+
+    public void spawnParticle(EntityPlayerMP sender, EnumParticleTypes particleType, boolean p_180505_2_, double xCoord, double yCoord, double zCoord, int numberOfParticles, double xOffset, double yOffset, double zOffset, double p_180505_16_, int... p_180505_18_)
+    {
+        // CraftBukkit End
         S2APacketParticles s2apacketparticles = new S2APacketParticles(particleType, p_180505_2_, (float)xCoord, (float)yCoord, (float)zCoord, (float)xOffset, (float)yOffset, (float)zOffset, (float)p_180505_16_, numberOfParticles, p_180505_18_);
 
         for (int k = 0; k < this.playerEntities.size(); ++k)
         {
             EntityPlayerMP entityplayermp = (EntityPlayerMP)this.playerEntities.get(k);
+
+            if (sender != null && !entityplayermp.getBukkitEntity().canSee(sender.getBukkitEntity()))
+                continue; // CraftBukkit
+
             BlockPos blockpos = entityplayermp.getPosition();
             double d7 = blockpos.distanceSq(xCoord, yCoord, zCoord);
 
             if (d7 <= 256.0D || p_180505_2_ && d7 <= 65536.0D)
             {
@@ -1152,13 +1522,16 @@
         return this.mcServer.isCallingFromMinecraftThread();
     }
 
     static class ServerBlockEventList extends ArrayList
         {
+
             private static final String __OBFID = "CL_00001439";
 
-            private ServerBlockEventList() {}
+            private ServerBlockEventList()
+            {
+            }
 
             ServerBlockEventList(Object p_i1521_1_)
             {
                 this();
             }
