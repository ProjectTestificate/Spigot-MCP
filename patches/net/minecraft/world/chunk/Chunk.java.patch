--- decompiled\net\minecraft\world\chunk\Chunk.java
+++ src\main\java\net\minecraft\world\chunk\Chunk.java
@@ -1,25 +1,29 @@
 package net.minecraft.world.chunk;
 
-import com.google.common.base.Predicate;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Queues;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentLinkedQueue;
+
 import net.minecraft.block.Block;
+import net.minecraft.block.BlockContainer;
 import net.minecraft.block.ITileEntityProvider;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.entity.Entity;
+import net.minecraft.entity.EntityLiving;
+import net.minecraft.entity.EnumCreatureType;
+import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.init.Blocks;
+import net.minecraft.inventory.IInventory;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.util.AxisAlignedBB;
 import net.minecraft.util.BlockPos;
 import net.minecraft.util.ClassInheritanceMultiMap;
 import net.minecraft.util.EnumFacing;
@@ -31,30 +35,42 @@
 import net.minecraft.world.WorldType;
 import net.minecraft.world.biome.BiomeGenBase;
 import net.minecraft.world.biome.WorldChunkManager;
 import net.minecraft.world.chunk.storage.ExtendedBlockStorage;
 import net.minecraft.world.gen.ChunkProviderDebug;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
+
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.craftbukkit.util.UnsafeList;
+import org.bukkit.entity.HumanEntity;
 
-public class Chunk
-{
+import com.google.common.base.Predicate;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
+
+import gnu.trove.map.hash.TObjectIntHashMap;
+
+public class Chunk {
+
     private static final Logger logger = LogManager.getLogger();
     private final ExtendedBlockStorage[] storageArrays;
     private final byte[] blockBiomeArray;
     private final int[] precipitationHeightMap;
     private final boolean[] updateSkylightColumns;
     private boolean isChunkLoaded;
-    private final World worldObj;
-    private final int[] heightMap;
+    public final World worldObj; // SpigotMCP -- apply access transformation
+    public final int[] heightMap; // CraftBukkit - make public
     public final int xPosition;
     public final int zPosition;
     private boolean isGapLightingUpdated;
-    private final Map chunkTileEntityMap;
-    private final ClassInheritanceMultiMap[] entityLists;
+    public Map chunkTileEntityMap; // SpigotMCP -- apply access transformation
+    public List[] entityLists; // Spigot -- private final -> public
     private boolean isTerrainPopulated;
     private boolean isLightPopulated;
     private boolean field_150815_m;
     private boolean isModified;
     private boolean hasEntities;
@@ -62,205 +78,171 @@
     private int heightMapMinimum;
     private long inhabitedTime;
     private int queuedLightChecks;
     private ConcurrentLinkedQueue field_177447_w;
     private static final String __OBFID = "CL_00000373";
+    public TObjectIntHashMap entityCount = new TObjectIntHashMap(); // Spigot // SpigotMCP -- Make public as bukkit assumes in same package
 
-    public Chunk(World worldIn, int x, int z)
-    {
+    // CraftBukkit start - Neighbor loaded cache for chunk lighting and entity ticking
+    private int neighbors = 0x1 << 12;
+
+    public boolean areNeighborsLoaded(final int radius) {
+        switch (radius) {
+            case 2:
+                return this.neighbors == Integer.MAX_VALUE >> 6;
+            case 1:
+                final int mask =
+                        //       x        z   offset          x        z   offset          x         z   offset
+                        (0x1 << (1 * 5 + 1 + 12)) | (0x1 << (0 * 5 + 1 + 12)) | (0x1 << (-1 * 5 + 1 + 12)) |
+                                (0x1 << (1 * 5 + 0 + 12)) | (0x1 << (0 * 5 + 0 + 12)) | (0x1 << (-1 * 5 + 0 + 12)) |
+                                (0x1 << (1 * 5 + -1 + 12)) | (0x1 << (0 * 5 + -1 + 12)) | (0x1 << (-1 * 5 + -1 + 12));
+                return (this.neighbors & mask) == mask;
+            default:
+                throw new UnsupportedOperationException(String.valueOf(radius));
+        }
+    }
+
+    public void setNeighborLoaded(final int x, final int z) {
+        this.neighbors |= 0x1 << (x * 5 + 12 + z);
+    }
+
+    public void setNeighborUnloaded(final int x, final int z) {
+        this.neighbors &= ~(0x1 << (x * 5 + 12 + z));
+    }
+    // CraftBukkit end
+
+    public Chunk(World worldIn, int x, int z) {
         this.storageArrays = new ExtendedBlockStorage[16];
         this.blockBiomeArray = new byte[256];
         this.precipitationHeightMap = new int[256];
         this.updateSkylightColumns = new boolean[256];
         this.chunkTileEntityMap = Maps.newHashMap();
         this.queuedLightChecks = 4096;
         this.field_177447_w = Queues.newConcurrentLinkedQueue();
-        this.entityLists = (ClassInheritanceMultiMap[])(new ClassInheritanceMultiMap[16]);
+        this.entityLists = (List[]) (new List[16]); // Spigot
         this.worldObj = worldIn;
         this.xPosition = x;
         this.zPosition = z;
         this.heightMap = new int[256];
 
-        for (int k = 0; k < this.entityLists.length; ++k)
-        {
-            this.entityLists[k] = new ClassInheritanceMultiMap(Entity.class);
+        for (int k = 0; k < this.entityLists.length; ++k) {
+            this.entityLists[k] = new UnsafeList();
         }
 
         Arrays.fill(this.precipitationHeightMap, -999);
-        Arrays.fill(this.blockBiomeArray, (byte) - 1);
+        Arrays.fill(this.blockBiomeArray, (byte) -1);
+
+        // CraftBukkit start
+        if (!(this instanceof EmptyChunk)) {
+            this.bukkitChunk = new CraftChunk(this);
+        }
     }
 
-    public Chunk(World worldIn, ChunkPrimer primer, int x, int z)
-    {
+    public CraftChunk bukkitChunk;
+    public boolean mustSave;
+    // CraftBukkit end
+
+    public Chunk(World worldIn, ChunkPrimer primer, int x, int z) {
         this(worldIn, x, z);
         short short1 = 256;
         boolean flag = !worldIn.provider.getHasNoSky();
 
-        for (int k = 0; k < 16; ++k)
-        {
-            for (int l = 0; l < 16; ++l)
-            {
-                for (int i1 = 0; i1 < short1; ++i1)
-                {
+        for (int k = 0; k < 16; ++k) {
+            for (int l = 0; l < 16; ++l) {
+                for (int i1 = 0; i1 < short1; ++i1) {
                     int j1 = k * short1 * 16 | l * short1 | i1;
                     IBlockState iblockstate = primer.getBlockState(j1);
 
-                    if (iblockstate.getBlock().getMaterial() != Material.air)
-                    {
+                    if (iblockstate.getBlock().getMaterial() != Material.air) {
                         int k1 = i1 >> 4;
 
-                        if (this.storageArrays[k1] == null)
-                        {
+                        if (this.storageArrays[k1] == null) {
                             this.storageArrays[k1] = new ExtendedBlockStorage(k1 << 4, flag);
                         }
 
                         this.storageArrays[k1].set(k, i1 & 15, l, iblockstate);
                     }
                 }
             }
         }
     }
 
-    public boolean isAtLocation(int x, int z)
-    {
+    public boolean isAtLocation(int x, int z) {
         return x == this.xPosition && z == this.zPosition;
     }
 
-    public int getHeight(BlockPos pos)
-    {
+    public int getHeight(BlockPos pos) {
         return this.getHeight(pos.getX() & 15, pos.getZ() & 15);
     }
 
-    public int getHeight(int x, int z)
-    {
+    public int getHeight(int x, int z) {
         return this.heightMap[z << 4 | x];
     }
 
-    public int getTopFilledSegment()
-    {
-        for (int i = this.storageArrays.length - 1; i >= 0; --i)
-        {
-            if (this.storageArrays[i] != null)
-            {
+    public int getTopFilledSegment() {
+        for (int i = this.storageArrays.length - 1; i >= 0; --i) {
+            if (this.storageArrays[i] != null) {
                 return this.storageArrays[i].getYLocation();
             }
         }
 
         return 0;
     }
 
-    public ExtendedBlockStorage[] getBlockStorageArray()
-    {
+    public ExtendedBlockStorage[] getBlockStorageArray() {
         return this.storageArrays;
     }
 
-    @SideOnly(Side.CLIENT)
-    protected void generateHeightMap()
-    {
+    public void generateSkylightMap() {
         int i = this.getTopFilledSegment();
         this.heightMapMinimum = Integer.MAX_VALUE;
 
-        for (int j = 0; j < 16; ++j)
-        {
+        for (int j = 0; j < 16; ++j) {
             int k = 0;
 
-            while (k < 16)
-            {
+            while (k < 16) {
                 this.precipitationHeightMap[j + (k << 4)] = -999;
                 int l = i + 16;
 
-                while (true)
-                {
-                    if (l > 0)
-                    {
-                        Block block = this.getBlock0(j, l - 1, k);
-
-                        if (block.getLightOpacity() == 0)
-                        {
+                while (true) {
+                    if (l > 0) {
+                        if (this.getBlockLightOpacity(j, l - 1, k) == 0) {
                             --l;
                             continue;
                         }
 
                         this.heightMap[k << 4 | j] = l;
 
-                        if (l < this.heightMapMinimum)
-                        {
+                        if (l < this.heightMapMinimum) {
                             this.heightMapMinimum = l;
                         }
                     }
 
-                    ++k;
-                    break;
-                }
-            }
-        }
-
-        this.isModified = true;
-    }
-
-    public void generateSkylightMap()
-    {
-        int i = this.getTopFilledSegment();
-        this.heightMapMinimum = Integer.MAX_VALUE;
-
-        for (int j = 0; j < 16; ++j)
-        {
-            int k = 0;
-
-            while (k < 16)
-            {
-                this.precipitationHeightMap[j + (k << 4)] = -999;
-                int l = i + 16;
-
-                while (true)
-                {
-                    if (l > 0)
-                    {
-                        if (this.getBlockLightOpacity(j, l - 1, k) == 0)
-                        {
-                            --l;
-                            continue;
-                        }
-
-                        this.heightMap[k << 4 | j] = l;
-
-                        if (l < this.heightMapMinimum)
-                        {
-                            this.heightMapMinimum = l;
-                        }
-                    }
-
-                    if (!this.worldObj.provider.getHasNoSky())
-                    {
+                    if (!this.worldObj.provider.getHasNoSky()) {
                         l = 15;
                         int i1 = i + 16 - 1;
 
-                        do
-                        {
+                        do {
                             int j1 = this.getBlockLightOpacity(j, i1, k);
 
-                            if (j1 == 0 && l != 15)
-                            {
+                            if (j1 == 0 && l != 15) {
                                 j1 = 1;
                             }
 
                             l -= j1;
 
-                            if (l > 0)
-                            {
+                            if (l > 0) {
                                 ExtendedBlockStorage extendedblockstorage = this.storageArrays[i1 >> 4];
 
-                                if (extendedblockstorage != null)
-                                {
+                                if (extendedblockstorage != null) {
                                     extendedblockstorage.setExtSkylightValue(j, i1 & 15, k, l);
                                     this.worldObj.notifyLightSet(new BlockPos((this.xPosition << 4) + j, i1, (this.zPosition << 4) + k));
                                 }
                             }
 
                             --i1;
-                        }
-                        while (i1 > 0 && l > 0);
+                        } while (i1 > 0 && l > 0);
                     }
 
                     ++k;
                     break;
                 }
@@ -268,52 +250,43 @@
         }
 
         this.isModified = true;
     }
 
-    private void propagateSkylightOcclusion(int x, int z)
-    {
+    private void propagateSkylightOcclusion(int x, int z) {
         this.updateSkylightColumns[x + z * 16] = true;
         this.isGapLightingUpdated = true;
     }
 
-    private void recheckGaps(boolean p_150803_1_)
-    {
+    private void recheckGaps(boolean p_150803_1_) {
         this.worldObj.theProfiler.startSection("recheckGaps");
 
-        if (this.worldObj.isAreaLoaded(new BlockPos(this.xPosition * 16 + 8, 0, this.zPosition * 16 + 8), 16))
-        {
-            for (int i = 0; i < 16; ++i)
-            {
-                for (int j = 0; j < 16; ++j)
-                {
-                    if (this.updateSkylightColumns[i + j * 16])
-                    {
+        if (this.worldObj.isAreaLoaded(new BlockPos(this.xPosition * 16 + 8, 0, this.zPosition * 16 + 8), 16)) {
+            for (int i = 0; i < 16; ++i) {
+                for (int j = 0; j < 16; ++j) {
+                    if (this.updateSkylightColumns[i + j * 16]) {
                         this.updateSkylightColumns[i + j * 16] = false;
                         int k = this.getHeight(i, j);
                         int l = this.xPosition * 16 + i;
                         int i1 = this.zPosition * 16 + j;
                         int j1 = Integer.MAX_VALUE;
                         Iterator iterator;
                         EnumFacing enumfacing;
 
-                        for (iterator = EnumFacing.Plane.HORIZONTAL.iterator(); iterator.hasNext(); j1 = Math.min(j1, this.worldObj.getChunksLowestHorizon(l + enumfacing.getFrontOffsetX(), i1 + enumfacing.getFrontOffsetZ())))
-                        {
-                            enumfacing = (EnumFacing)iterator.next();
+                        for (iterator = EnumFacing.Plane.HORIZONTAL.iterator(); iterator.hasNext(); j1 = Math.min(j1, this.worldObj.getChunksLowestHorizon(l + enumfacing.getFrontOffsetX(), i1 + enumfacing.getFrontOffsetZ()))) {
+                            enumfacing = (EnumFacing) iterator.next();
                         }
 
                         this.checkSkylightNeighborHeight(l, i1, j1);
                         iterator = EnumFacing.Plane.HORIZONTAL.iterator();
 
-                        while (iterator.hasNext())
-                        {
-                            enumfacing = (EnumFacing)iterator.next();
+                        while (iterator.hasNext()) {
+                            enumfacing = (EnumFacing) iterator.next();
                             this.checkSkylightNeighborHeight(l + enumfacing.getFrontOffsetX(), i1 + enumfacing.getFrontOffsetZ(), k);
                         }
 
-                        if (p_150803_1_)
-                        {
+                        if (p_150803_1_) {
                             this.worldObj.theProfiler.endSection();
                             return;
                         }
                     }
                 }
@@ -323,1323 +296,1066 @@
         }
 
         this.worldObj.theProfiler.endSection();
     }
 
-    private void checkSkylightNeighborHeight(int x, int p_76599_2_, int z)
-    {
+    private void checkSkylightNeighborHeight(int x, int p_76599_2_, int z) {
         int l = this.worldObj.getHorizon(new BlockPos(x, 0, p_76599_2_)).getY();
 
-        if (l > z)
-        {
+        if (l > z) {
             this.updateSkylightNeighborHeight(x, p_76599_2_, z, l + 1);
-        }
-        else if (l < z)
-        {
+        } else if (l < z) {
             this.updateSkylightNeighborHeight(x, p_76599_2_, l, z + 1);
         }
     }
 
-    private void updateSkylightNeighborHeight(int x, int z, int startY, int endY)
-    {
-        if (endY > startY && this.worldObj.isAreaLoaded(new BlockPos(x, 0, z), 16))
-        {
-            for (int i1 = startY; i1 < endY; ++i1)
-            {
+    private void updateSkylightNeighborHeight(int x, int z, int startY, int endY) {
+        if (endY > startY && this.worldObj.isAreaLoaded(new BlockPos(x, 0, z), 16)) {
+            for (int i1 = startY; i1 < endY; ++i1) {
                 this.worldObj.checkLightFor(EnumSkyBlock.SKY, new BlockPos(x, i1, z));
             }
 
             this.isModified = true;
         }
     }
 
-    private void relightBlock(int x, int y, int z)
-    {
+    private void relightBlock(int x, int y, int z) {
         int l = this.heightMap[z << 4 | x] & 255;
         int i1 = l;
 
-        if (y > l)
-        {
+        if (y > l) {
             i1 = y;
         }
 
-        while (i1 > 0 && this.getBlockLightOpacity(x, i1 - 1, z) == 0)
-        {
+        while (i1 > 0 && this.getBlockLightOpacity(x, i1 - 1, z) == 0) {
             --i1;
         }
 
-        if (i1 != l)
-        {
+        if (i1 != l) {
             this.worldObj.markBlocksDirtyVertical(x + this.xPosition * 16, z + this.zPosition * 16, i1, l);
             this.heightMap[z << 4 | x] = i1;
             int j1 = this.xPosition * 16 + x;
             int k1 = this.zPosition * 16 + z;
             int l1;
             int i2;
 
-            if (!this.worldObj.provider.getHasNoSky())
-            {
+            if (!this.worldObj.provider.getHasNoSky()) {
                 ExtendedBlockStorage extendedblockstorage;
 
-                if (i1 < l)
-                {
-                    for (l1 = i1; l1 < l; ++l1)
-                    {
+                if (i1 < l) {
+                    for (l1 = i1; l1 < l; ++l1) {
                         extendedblockstorage = this.storageArrays[l1 >> 4];
 
-                        if (extendedblockstorage != null)
-                        {
+                        if (extendedblockstorage != null) {
                             extendedblockstorage.setExtSkylightValue(x, l1 & 15, z, 15);
                             this.worldObj.notifyLightSet(new BlockPos((this.xPosition << 4) + x, l1, (this.zPosition << 4) + z));
                         }
                     }
-                }
-                else
-                {
-                    for (l1 = l; l1 < i1; ++l1)
-                    {
+                } else {
+                    for (l1 = l; l1 < i1; ++l1) {
                         extendedblockstorage = this.storageArrays[l1 >> 4];
 
-                        if (extendedblockstorage != null)
-                        {
+                        if (extendedblockstorage != null) {
                             extendedblockstorage.setExtSkylightValue(x, l1 & 15, z, 0);
                             this.worldObj.notifyLightSet(new BlockPos((this.xPosition << 4) + x, l1, (this.zPosition << 4) + z));
                         }
                     }
                 }
 
                 l1 = 15;
 
-                while (i1 > 0 && l1 > 0)
-                {
+                while (i1 > 0 && l1 > 0) {
                     --i1;
                     i2 = this.getBlockLightOpacity(x, i1, z);
 
-                    if (i2 == 0)
-                    {
+                    if (i2 == 0) {
                         i2 = 1;
                     }
 
                     l1 -= i2;
 
-                    if (l1 < 0)
-                    {
+                    if (l1 < 0) {
                         l1 = 0;
                     }
 
                     ExtendedBlockStorage extendedblockstorage1 = this.storageArrays[i1 >> 4];
 
-                    if (extendedblockstorage1 != null)
-                    {
+                    if (extendedblockstorage1 != null) {
                         extendedblockstorage1.setExtSkylightValue(x, i1 & 15, z, l1);
                     }
                 }
             }
 
             l1 = this.heightMap[z << 4 | x];
             i2 = l;
             int j2 = l1;
 
-            if (l1 < l)
-            {
+            if (l1 < l) {
                 i2 = l1;
                 j2 = l;
             }
 
-            if (l1 < this.heightMapMinimum)
-            {
+            if (l1 < this.heightMapMinimum) {
                 this.heightMapMinimum = l1;
             }
 
-            if (!this.worldObj.provider.getHasNoSky())
-            {
+            if (!this.worldObj.provider.getHasNoSky()) {
                 Iterator iterator = EnumFacing.Plane.HORIZONTAL.iterator();
 
-                while (iterator.hasNext())
-                {
-                    EnumFacing enumfacing = (EnumFacing)iterator.next();
+                while (iterator.hasNext()) {
+                    EnumFacing enumfacing = (EnumFacing) iterator.next();
                     this.updateSkylightNeighborHeight(j1 + enumfacing.getFrontOffsetX(), k1 + enumfacing.getFrontOffsetZ(), i2, j2);
                 }
 
                 this.updateSkylightNeighborHeight(j1, k1, i2, j2);
             }
 
             this.isModified = true;
         }
     }
 
-    public int getBlockLightOpacity(BlockPos pos)
-    {
+    public int getBlockLightOpacity(BlockPos pos) {
         return this.getBlock(pos).getLightOpacity();
     }
 
-    private int getBlockLightOpacity(int x, int y, int z)
-    {
+    private int getBlockLightOpacity(int x, int y, int z) {
         return this.getBlock0(x, y, z).getLightOpacity();
     }
 
-    private Block getBlock0(int x, int y, int z)
-    {
+    private Block getBlock0(int x, int y, int z) {
         Block block = Blocks.air;
 
-        if (y >= 0 && y >> 4 < this.storageArrays.length)
-        {
+        if (y >= 0 && y >> 4 < this.storageArrays.length) {
             ExtendedBlockStorage extendedblockstorage = this.storageArrays[y >> 4];
 
-            if (extendedblockstorage != null)
-            {
-                try
-                {
+            if (extendedblockstorage != null) {
+                try {
                     block = extendedblockstorage.getBlockByExtId(x, y & 15, z);
-                }
-                catch (Throwable throwable)
-                {
+                } catch (Throwable throwable) {
                     CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Getting block");
                     throw new ReportedException(crashreport);
                 }
             }
         }
 
         return block;
     }
 
-    public Block getBlock(final int x, final int y, final int z)
-    {
-        try
-        {
+    public Block getBlock(final int x, final int y, final int z) {
+        try {
             return this.getBlock0(x & 15, y, z & 15);
-        }
-        catch (ReportedException reportedexception)
-        {
+        } catch (ReportedException reportedexception) {
             CrashReportCategory crashreportcategory = reportedexception.getCrashReport().makeCategory("Block being got");
-            crashreportcategory.addCrashSectionCallable("Location", new Callable()
-            {
+            crashreportcategory.addCrashSectionCallable("Location", new Callable() {
+
                 private static final String __OBFID = "CL_00000374";
-                public String call()
-                {
+
+                public String call() {
                     return CrashReportCategory.getCoordinateInfo(new BlockPos(Chunk.this.xPosition * 16 + x, y, Chunk.this.zPosition * 16 + z));
                 }
             });
             throw reportedexception;
         }
     }
 
-    public Block getBlock(final BlockPos pos)
-    {
-        try
-        {
+    public Block getBlock(final BlockPos pos) {
+        try {
             return this.getBlock0(pos.getX() & 15, pos.getY(), pos.getZ() & 15);
-        }
-        catch (ReportedException reportedexception)
-        {
+        } catch (ReportedException reportedexception) {
             CrashReportCategory crashreportcategory = reportedexception.getCrashReport().makeCategory("Block being got");
-            crashreportcategory.addCrashSectionCallable("Location", new Callable()
-            {
+            crashreportcategory.addCrashSectionCallable("Location", new Callable() {
+
                 private static final String __OBFID = "CL_00002011";
-                public String call()
-                {
+
+                public String call() {
                     return CrashReportCategory.getCoordinateInfo(pos);
                 }
             });
             throw reportedexception;
         }
     }
 
-    public IBlockState getBlockState(final BlockPos pos)
-    {
-        if (this.worldObj.getWorldType() == WorldType.DEBUG_WORLD)
-        {
+    public IBlockState getBlockState(final BlockPos pos) {
+        if (this.worldObj.getWorldType() == WorldType.DEBUG_WORLD) {
             IBlockState iblockstate = null;
 
-            if (pos.getY() == 60)
-            {
+            if (pos.getY() == 60) {
                 iblockstate = Blocks.barrier.getDefaultState();
             }
 
-            if (pos.getY() == 70)
-            {
+            if (pos.getY() == 70) {
                 iblockstate = ChunkProviderDebug.func_177461_b(pos.getX(), pos.getZ());
             }
 
             return iblockstate == null ? Blocks.air.getDefaultState() : iblockstate;
-        }
-        else
-        {
-            try
-            {
-                if (pos.getY() >= 0 && pos.getY() >> 4 < this.storageArrays.length)
-                {
+        } else {
+            try {
+                if (pos.getY() >= 0 && pos.getY() >> 4 < this.storageArrays.length) {
                     ExtendedBlockStorage extendedblockstorage = this.storageArrays[pos.getY() >> 4];
 
-                    if (extendedblockstorage != null)
-                    {
+                    if (extendedblockstorage != null) {
                         int j = pos.getX() & 15;
                         int k = pos.getY() & 15;
                         int i = pos.getZ() & 15;
                         return extendedblockstorage.get(j, k, i);
                     }
                 }
 
                 return Blocks.air.getDefaultState();
-            }
-            catch (Throwable throwable)
-            {
+            } catch (Throwable throwable) {
                 CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Getting block state");
                 CrashReportCategory crashreportcategory = crashreport.makeCategory("Block being got");
-                crashreportcategory.addCrashSectionCallable("Location", new Callable()
-                {
+                crashreportcategory.addCrashSectionCallable("Location", new Callable() {
+
                     private static final String __OBFID = "CL_00002010";
-                    public String call()
-                    {
+
+                    public String call() {
                         return CrashReportCategory.getCoordinateInfo(pos);
                     }
                 });
                 throw new ReportedException(crashreport);
             }
         }
     }
 
-    private int getBlockMetadata(int x, int y, int z)
-    {
-        if (y >> 4 >= this.storageArrays.length)
-        {
+    private int getBlockMetadata(int x, int y, int z) {
+        if (y >> 4 >= this.storageArrays.length) {
             return 0;
-        }
-        else
-        {
+        } else {
             ExtendedBlockStorage extendedblockstorage = this.storageArrays[y >> 4];
             return extendedblockstorage != null ? extendedblockstorage.getExtBlockMetadata(x, y & 15, z) : 0;
         }
     }
 
-    public int getBlockMetadata(BlockPos pos)
-    {
+    public int getBlockMetadata(BlockPos pos) {
         return this.getBlockMetadata(pos.getX() & 15, pos.getY(), pos.getZ() & 15);
     }
 
-    public IBlockState setBlockState(BlockPos pos, IBlockState state)
-    {
+    public IBlockState setBlockState(BlockPos pos, IBlockState state) {
         int i = pos.getX() & 15;
         int j = pos.getY();
         int k = pos.getZ() & 15;
         int l = k << 4 | i;
 
-        if (j >= this.precipitationHeightMap[l] - 1)
-        {
+        if (j >= this.precipitationHeightMap[l] - 1) {
             this.precipitationHeightMap[l] = -999;
         }
 
         int i1 = this.heightMap[l];
         IBlockState iblockstate1 = this.getBlockState(pos);
 
-        if (iblockstate1 == state)
-        {
+        if (iblockstate1 == state) {
             return null;
-        }
-        else
-        {
+        } else {
             Block block = state.getBlock();
             Block block1 = iblockstate1.getBlock();
             ExtendedBlockStorage extendedblockstorage = this.storageArrays[j >> 4];
             boolean flag = false;
 
-            if (extendedblockstorage == null)
-            {
-                if (block == Blocks.air)
-                {
+            if (extendedblockstorage == null) {
+                if (block == Blocks.air) {
                     return null;
                 }
 
                 extendedblockstorage = this.storageArrays[j >> 4] = new ExtendedBlockStorage(j >> 4 << 4, !this.worldObj.provider.getHasNoSky());
                 flag = j >= i1;
             }
 
             extendedblockstorage.set(i, j & 15, k, state);
 
-            if (block1 != block)
-            {
-                if (!this.worldObj.isRemote)
-                {
+            if (block1 != block) {
+                if (!this.worldObj.isRemote) {
                     block1.breakBlock(this.worldObj, pos, iblockstate1);
-                }
-                else if (block1 instanceof ITileEntityProvider)
-                {
+                } else if (block1 instanceof ITileEntityProvider) {
                     this.worldObj.removeTileEntity(pos);
                 }
             }
 
-            if (extendedblockstorage.getBlockByExtId(i, j & 15, k) != block)
-            {
+            if (extendedblockstorage.getBlockByExtId(i, j & 15, k) != block) {
                 return null;
-            }
-            else
-            {
-                if (flag)
-                {
+            } else {
+                if (flag) {
                     this.generateSkylightMap();
-                }
-                else
-                {
+                } else {
                     int j1 = block.getLightOpacity();
                     int k1 = block1.getLightOpacity();
 
-                    if (j1 > 0)
-                    {
-                        if (j >= i1)
-                        {
+                    if (j1 > 0) {
+                        if (j >= i1) {
                             this.relightBlock(i, j + 1, k);
                         }
-                    }
-                    else if (j == i1 - 1)
-                    {
+                    } else if (j == i1 - 1) {
                         this.relightBlock(i, j, k);
                     }
 
-                    if (j1 != k1 && (j1 < k1 || this.getLightFor(EnumSkyBlock.SKY, pos) > 0 || this.getLightFor(EnumSkyBlock.BLOCK, pos) > 0))
-                    {
+                    if (j1 != k1 && (j1 < k1 || this.getLightFor(EnumSkyBlock.SKY, pos) > 0 || this.getLightFor(EnumSkyBlock.BLOCK, pos) > 0)) {
                         this.propagateSkylightOcclusion(i, k);
                     }
                 }
 
                 TileEntity tileentity;
 
-                if (block1 instanceof ITileEntityProvider)
-                {
+                if (block1 instanceof ITileEntityProvider) {
                     tileentity = this.getTileEntity(pos, Chunk.EnumCreateEntityType.CHECK);
 
-                    if (tileentity != null)
-                    {
+                    if (tileentity != null) {
                         tileentity.updateContainingBlockInfo();
                     }
                 }
 
-                if (!this.worldObj.isRemote && block1 != block)
-                {
+                // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
+                if (!this.worldObj.isRemote && block1 != block && (!this.worldObj.captureBlockStates || block instanceof BlockContainer)) {
                     block.onBlockAdded(this.worldObj, pos, state);
                 }
 
-                if (block instanceof ITileEntityProvider)
-                {
+                if (block instanceof ITileEntityProvider) {
                     tileentity = this.getTileEntity(pos, Chunk.EnumCreateEntityType.CHECK);
 
-                    if (tileentity == null)
-                    {
-                        tileentity = ((ITileEntityProvider)block).createNewTileEntity(this.worldObj, block.getMetaFromState(state));
+                    if (tileentity == null) {
+                        tileentity = ((ITileEntityProvider) block).createNewTileEntity(this.worldObj, block.getMetaFromState(state));
                         this.worldObj.setTileEntity(pos, tileentity);
                     }
 
-                    if (tileentity != null)
-                    {
+                    if (tileentity != null) {
                         tileentity.updateContainingBlockInfo();
                     }
                 }
 
                 this.isModified = true;
                 return iblockstate1;
             }
         }
     }
 
-    public int getLightFor(EnumSkyBlock p_177413_1_, BlockPos pos)
-    {
+    public int getLightFor(EnumSkyBlock p_177413_1_, BlockPos pos) {
         int i = pos.getX() & 15;
         int j = pos.getY();
         int k = pos.getZ() & 15;
         ExtendedBlockStorage extendedblockstorage = this.storageArrays[j >> 4];
         return extendedblockstorage == null ? (this.canSeeSky(pos) ? p_177413_1_.defaultLightValue : 0) : (p_177413_1_ == EnumSkyBlock.SKY ? (this.worldObj.provider.getHasNoSky() ? 0 : extendedblockstorage.getExtSkylightValue(i, j & 15, k)) : (p_177413_1_ == EnumSkyBlock.BLOCK ? extendedblockstorage.getExtBlocklightValue(i, j & 15, k) : p_177413_1_.defaultLightValue));
     }
 
-    public void setLightFor(EnumSkyBlock p_177431_1_, BlockPos pos, int value)
-    {
+    public void setLightFor(EnumSkyBlock p_177431_1_, BlockPos pos, int value) {
         int j = pos.getX() & 15;
         int k = pos.getY();
         int l = pos.getZ() & 15;
         ExtendedBlockStorage extendedblockstorage = this.storageArrays[k >> 4];
 
-        if (extendedblockstorage == null)
-        {
+        if (extendedblockstorage == null) {
             extendedblockstorage = this.storageArrays[k >> 4] = new ExtendedBlockStorage(k >> 4 << 4, !this.worldObj.provider.getHasNoSky());
             this.generateSkylightMap();
         }
 
         this.isModified = true;
 
-        if (p_177431_1_ == EnumSkyBlock.SKY)
-        {
-            if (!this.worldObj.provider.getHasNoSky())
-            {
+        if (p_177431_1_ == EnumSkyBlock.SKY) {
+            if (!this.worldObj.provider.getHasNoSky()) {
                 extendedblockstorage.setExtSkylightValue(j, k & 15, l, value);
             }
-        }
-        else if (p_177431_1_ == EnumSkyBlock.BLOCK)
-        {
+        } else if (p_177431_1_ == EnumSkyBlock.BLOCK) {
             extendedblockstorage.setExtBlocklightValue(j, k & 15, l, value);
         }
     }
 
-    public int setLight(BlockPos pos, int p_177443_2_)
-    {
+    public int setLight(BlockPos pos, int p_177443_2_) {
         int j = pos.getX() & 15;
         int k = pos.getY();
         int l = pos.getZ() & 15;
         ExtendedBlockStorage extendedblockstorage = this.storageArrays[k >> 4];
 
-        if (extendedblockstorage == null)
-        {
+        if (extendedblockstorage == null) {
             return !this.worldObj.provider.getHasNoSky() && p_177443_2_ < EnumSkyBlock.SKY.defaultLightValue ? EnumSkyBlock.SKY.defaultLightValue - p_177443_2_ : 0;
-        }
-        else
-        {
+        } else {
             int i1 = this.worldObj.provider.getHasNoSky() ? 0 : extendedblockstorage.getExtSkylightValue(j, k & 15, l);
             i1 -= p_177443_2_;
             int j1 = extendedblockstorage.getExtBlocklightValue(j, k & 15, l);
 
-            if (j1 > i1)
-            {
+            if (j1 > i1) {
                 i1 = j1;
             }
 
             return i1;
         }
     }
 
-    public void addEntity(Entity entityIn)
-    {
+    public void addEntity(Entity entityIn) {
         this.hasEntities = true;
         int i = MathHelper.floor_double(entityIn.posX / 16.0D);
         int j = MathHelper.floor_double(entityIn.posZ / 16.0D);
 
-        if (i != this.xPosition || j != this.zPosition)
-        {
-            logger.warn("Wrong location! (" + i + ", " + j + ") should be (" + this.xPosition + ", " + this.zPosition + "), " + entityIn, new Object[] {entityIn});
+        if (i != this.xPosition || j != this.zPosition) {
+            // CraftBukkit start
+            Bukkit.getLogger().warning("Wrong location for " + entityIn + " in world '" + worldObj.getWorld().getName() + "'!");
+            // logger.warn("Wrong location! (" + i + ", " + j + ") should be (" + this.xPosition + ", " + this.zPosition + "), " + entityIn, new Object[]{entityIn});
+            Bukkit.getLogger().warning("Entity is at " + entityIn.posX + "," + entityIn.posZ + " (chunk " + i + "," + j + ") but was stored in chunk " + this.xPosition + "," + this.zPosition);
+            // CraftBukkit end
             entityIn.setDead();
         }
 
         int k = MathHelper.floor_double(entityIn.posY / 16.0D);
 
-        if (k < 0)
-        {
+        if (k < 0) {
             k = 0;
         }
 
-        if (k >= this.entityLists.length)
-        {
+        if (k >= this.entityLists.length) {
             k = this.entityLists.length - 1;
         }
 
         entityIn.addedToChunk = true;
         entityIn.chunkCoordX = this.xPosition;
         entityIn.chunkCoordY = k;
         entityIn.chunkCoordZ = this.zPosition;
         this.entityLists[k].add(entityIn);
+        // Spigot start - increment creature type count
+        // Keep this synced up with World.a(Class)
+        if (entityIn instanceof EntityLiving) {
+            EntityLiving entityinsentient = (EntityLiving) entityIn;
+            if (entityinsentient.canDespawn() && entityinsentient.isNoDespawnRequired()) {
+                return;
+            }
+        }
+        for (EnumCreatureType creatureType : EnumCreatureType.values()) {
+            if (creatureType.getCreatureClass().isAssignableFrom(entityIn.getClass())) {
+                this.entityCount.adjustOrPutValue(creatureType.getCreatureClass(), 1, 1);
+            }
+        }
+        // Spigot end
     }
 
-    public void removeEntity(Entity p_76622_1_)
-    {
+    public void removeEntity(Entity p_76622_1_) {
         this.removeEntityAtIndex(p_76622_1_, p_76622_1_.chunkCoordY);
     }
 
-    public void removeEntityAtIndex(Entity p_76608_1_, int p_76608_2_)
-    {
-        if (p_76608_2_ < 0)
-        {
+    public void removeEntityAtIndex(Entity p_76608_1_, int p_76608_2_) {
+        if (p_76608_2_ < 0) {
             p_76608_2_ = 0;
         }
 
-        if (p_76608_2_ >= this.entityLists.length)
-        {
+        if (p_76608_2_ >= this.entityLists.length) {
             p_76608_2_ = this.entityLists.length - 1;
         }
 
         this.entityLists[p_76608_2_].remove(p_76608_1_);
+        // Spigot start - decrement creature type count
+        // Keep this synced up with World.a(Class)
+        if (p_76608_1_ instanceof EntityLiving) {
+            EntityLiving entityinsentient = (EntityLiving) p_76608_1_;
+            if (entityinsentient.canDespawn() && entityinsentient.isNoDespawnRequired()) {
+                return;
+            }
+        }
+        for (EnumCreatureType creatureType : EnumCreatureType.values()) {
+            if (creatureType.getCreatureClass().isAssignableFrom(p_76608_1_.getClass())) {
+                this.entityCount.adjustValue(creatureType.getCreatureClass(), -1);
+            }
+        }
+        // Spigot end
     }
 
-    public boolean canSeeSky(BlockPos pos)
-    {
+    public boolean canSeeSky(BlockPos pos) {
         int i = pos.getX() & 15;
         int j = pos.getY();
         int k = pos.getZ() & 15;
         return j >= this.heightMap[k << 4 | i];
     }
 
-    private TileEntity createNewTileEntity(BlockPos pos)
-    {
+    private TileEntity createNewTileEntity(BlockPos pos) {
         Block block = this.getBlock(pos);
-        return !block.hasTileEntity() ? null : ((ITileEntityProvider)block).createNewTileEntity(this.worldObj, this.getBlockMetadata(pos));
+        return !block.hasTileEntity() ? null : ((ITileEntityProvider) block).createNewTileEntity(this.worldObj, this.getBlockMetadata(pos));
     }
 
-    public TileEntity getTileEntity(BlockPos pos, Chunk.EnumCreateEntityType p_177424_2_)
-    {
-        TileEntity tileentity = (TileEntity)this.chunkTileEntityMap.get(pos);
+    public TileEntity getTileEntity(BlockPos pos, Chunk.EnumCreateEntityType p_177424_2_) {
+        TileEntity tileentity = (TileEntity) this.chunkTileEntityMap.get(pos);
 
-        if (tileentity == null)
-        {
-            if (p_177424_2_ == Chunk.EnumCreateEntityType.IMMEDIATE)
-            {
+        if (tileentity == null) {
+            if (p_177424_2_ == Chunk.EnumCreateEntityType.IMMEDIATE) {
                 tileentity = this.createNewTileEntity(pos);
                 this.worldObj.setTileEntity(pos, tileentity);
-            }
-            else if (p_177424_2_ == Chunk.EnumCreateEntityType.QUEUED)
-            {
+            } else if (p_177424_2_ == Chunk.EnumCreateEntityType.QUEUED) {
                 this.field_177447_w.add(pos);
             }
-        }
-        else if (tileentity.isInvalid())
-        {
+        } else if (tileentity.isInvalid()) {
             this.chunkTileEntityMap.remove(pos);
             return null;
         }
 
         return tileentity;
     }
 
-    public void addTileEntity(TileEntity tileEntityIn)
-    {
+    public void addTileEntity(TileEntity tileEntityIn) {
         this.addTileEntity(tileEntityIn.getPos(), tileEntityIn);
 
-        if (this.isChunkLoaded)
-        {
+        if (this.isChunkLoaded) {
             this.worldObj.addTileEntity(tileEntityIn);
         }
     }
 
-    public void addTileEntity(BlockPos pos, TileEntity tileEntityIn)
-    {
+    public void addTileEntity(BlockPos pos, TileEntity tileEntityIn) {
         tileEntityIn.setWorldObj(this.worldObj);
         tileEntityIn.setPos(pos);
 
-        if (this.getBlock(pos) instanceof ITileEntityProvider)
-        {
-            if (this.chunkTileEntityMap.containsKey(pos))
-            {
-                ((TileEntity)this.chunkTileEntityMap.get(pos)).invalidate();
+        if (this.getBlock(pos) instanceof ITileEntityProvider) {
+            if (this.chunkTileEntityMap.containsKey(pos)) {
+                ((TileEntity) this.chunkTileEntityMap.get(pos)).invalidate();
             }
 
             tileEntityIn.validate();
             this.chunkTileEntityMap.put(pos, tileEntityIn);
+            // Spigot start - The tile entity has a world, now hoppers can be born ticking.
+            if (this.worldObj.spigotConfig.altHopperTicking) {
+                this.worldObj.triggerHoppersList.add(tileEntityIn);
+            }
+            // Spigot end
+            // CraftBukkit start
+        } else {
+            System.out.println("Attempted to place a tile entity (" + tileEntityIn + ") at " + tileEntityIn.pos.getX() + "," + tileEntityIn.pos.getY() + "," + tileEntityIn.pos.getZ() + " (" + CraftMagicNumbers.getMaterial(getBlock(pos)) + ") where there was no entity tile!");
+            System.out.println("Chunk coordinates: " + (this.xPosition * 16) + "," + (this.zPosition * 16));
+            new Exception().printStackTrace();
+            // CraftBukkit end
         }
     }
 
-    public void removeTileEntity(BlockPos pos)
-    {
-        if (this.isChunkLoaded)
-        {
-            TileEntity tileentity = (TileEntity)this.chunkTileEntityMap.remove(pos);
+    public void removeTileEntity(BlockPos pos) {
+        if (this.isChunkLoaded) {
+            TileEntity tileentity = (TileEntity) this.chunkTileEntityMap.remove(pos);
 
-            if (tileentity != null)
-            {
+            if (tileentity != null) {
                 tileentity.invalidate();
             }
         }
     }
 
-    public void onChunkLoad()
-    {
+    public void onChunkLoad() {
         this.isChunkLoaded = true;
         this.worldObj.addTileEntities(this.chunkTileEntityMap.values());
 
-        for (int i = 0; i < this.entityLists.length; ++i)
-        {
+        for (int i = 0; i < this.entityLists.length; ++i) {
             Iterator iterator = this.entityLists[i].iterator();
 
-            while (iterator.hasNext())
-            {
-                Entity entity = (Entity)iterator.next();
+            while (iterator.hasNext()) {
+                Entity entity = (Entity) iterator.next();
                 entity.onChunkLoad();
             }
 
             this.worldObj.loadEntities(this.entityLists[i]);
         }
     }
 
-    public void onChunkUnload()
-    {
+    public void onChunkUnload() {
         this.isChunkLoaded = false;
         Iterator iterator = this.chunkTileEntityMap.values().iterator();
 
-        while (iterator.hasNext())
-        {
-            TileEntity tileentity = (TileEntity)iterator.next();
+        while (iterator.hasNext()) {
+            TileEntity tileentity = (TileEntity) iterator.next();
+            // Spigot Start
+            if (tileentity instanceof IInventory) {
+                for (HumanEntity h : Lists.newArrayList(((IInventory) tileentity).getViewers())) // SpigotMCP -- Fix shit
+                {
+                    if (h instanceof CraftHumanEntity) {
+                        ((CraftHumanEntity) h).getHandle().closeScreen();
+                    }
+                }
+            }
+            // Spigot End
+
             this.worldObj.markTileEntityForRemoval(tileentity);
         }
 
-        for (int i = 0; i < this.entityLists.length; ++i)
-        {
-            this.worldObj.unloadEntities(this.entityLists[i]);
+        for (int i = 0; i < this.entityLists.length; ++i) {
+            // CraftBukkit start
+            List<Entity> newList = Lists.newArrayList(this.entityLists[i]);
+            Iterator<Entity> iter = newList.iterator();
+            while (iter.hasNext()) {
+                Entity entity = iter.next();
+                // Spigot Start
+                if (entity instanceof IInventory) {
+                    for (HumanEntity h : Lists.newArrayList(((IInventory) entity).getViewers())) // SpigotMCP -- Fix shit
+                    {
+                        if (h instanceof CraftHumanEntity) {
+                            ((CraftHumanEntity) h).getHandle().closeScreen();
+                        }
+                    }
+                }
+                // Spigot End
+
+                // Do not pass along players, as doing so can get them stuck outside of time.
+                // (which for example disables inventory icon updates and prevents block breaking)
+                if (entity instanceof EntityPlayer) {
+                    iter.remove();
+                }
+            }
+            this.worldObj.unloadEntities(newList);
+            // CraftBukkit end
         }
     }
 
-    public void setChunkModified()
-    {
+    public void setChunkModified() {
         this.isModified = true;
     }
 
-    public void getEntitiesWithinAABBForEntity(Entity entityIn, AxisAlignedBB aabb, List listToFill, Predicate p_177414_4_)
-    {
+    public void getEntitiesWithinAABBForEntity(Entity entityIn, AxisAlignedBB aabb, List listToFill, Predicate p_177414_4_) {
         int i = MathHelper.floor_double((aabb.minY - 2.0D) / 16.0D);
         int j = MathHelper.floor_double((aabb.maxY + 2.0D) / 16.0D);
         i = MathHelper.clamp_int(i, 0, this.entityLists.length - 1);
         j = MathHelper.clamp_int(j, 0, this.entityLists.length - 1);
 
-        for (int k = i; k <= j; ++k)
-        {
+        for (int k = i; k <= j; ++k) {
             Iterator iterator = this.entityLists[k].iterator();
 
-            while (iterator.hasNext())
-            {
-                Entity entity1 = (Entity)iterator.next();
+            while (iterator.hasNext()) {
+                Entity entity1 = (Entity) iterator.next();
 
-                if (entity1 != entityIn && entity1.getEntityBoundingBox().intersectsWith(aabb) && (p_177414_4_ == null || p_177414_4_.apply(entity1)))
-                {
+                if (entity1 != entityIn && entity1.getEntityBoundingBox().intersectsWith(aabb) && (p_177414_4_ == null || p_177414_4_.apply(entity1))) {
                     listToFill.add(entity1);
                     Entity[] aentity = entity1.getParts();
 
-                    if (aentity != null)
-                    {
-                        for (int l = 0; l < aentity.length; ++l)
-                        {
+                    if (aentity != null) {
+                        for (int l = 0; l < aentity.length; ++l) {
                             entity1 = aentity[l];
 
-                            if (entity1 != entityIn && entity1.getEntityBoundingBox().intersectsWith(aabb) && (p_177414_4_ == null || p_177414_4_.apply(entity1)))
-                            {
+                            if (entity1 != entityIn && entity1.getEntityBoundingBox().intersectsWith(aabb) && (p_177414_4_ == null || p_177414_4_.apply(entity1))) {
                                 listToFill.add(entity1);
                             }
                         }
                     }
                 }
             }
         }
     }
 
-    public void getEntitiesOfTypeWithinAAAB(Class entityClass, AxisAlignedBB aabb, List listToFill, Predicate p_177430_4_)
-    {
+    public void getEntitiesOfTypeWithinAAAB(Class entityClass, AxisAlignedBB aabb, List<Entity> listToFill, Predicate<Entity> p_177430_4_) {
         int i = MathHelper.floor_double((aabb.minY - 2.0D) / 16.0D);
         int j = MathHelper.floor_double((aabb.maxY + 2.0D) / 16.0D);
         i = MathHelper.clamp_int(i, 0, this.entityLists.length - 1);
         j = MathHelper.clamp_int(j, 0, this.entityLists.length - 1);
 
-        for (int k = i; k <= j; ++k)
-        {
-            Iterator iterator = this.entityLists[k].func_180215_b(entityClass).iterator();
+        for (int k = i; k <= j; ++k) {
+            Iterator iterator = this.entityLists[k].iterator(); // Spigot
 
-            while (iterator.hasNext())
-            {
-                Entity entity = (Entity)iterator.next();
+            while (iterator.hasNext()) {
+                Entity entity = (Entity) iterator.next();
 
-                if (entity.getEntityBoundingBox().intersectsWith(aabb) && (p_177430_4_ == null || p_177430_4_.apply(entity)))
-                {
+                if (entityClass.isInstance(entity) && entity.getEntityBoundingBox().intersectsWith(aabb) && (p_177430_4_ == null || p_177430_4_.apply(entity))) { // Spigot
                     listToFill.add(entity);
                 }
             }
         }
     }
 
-    public boolean needsSaving(boolean p_76601_1_)
-    {
-        if (p_76601_1_)
-        {
-            if (this.hasEntities && this.worldObj.getTotalWorldTime() != this.lastSaveTime || this.isModified)
-            {
+    public boolean needsSaving(boolean p_76601_1_) {
+        if (p_76601_1_) {
+            if (this.hasEntities && this.worldObj.getTotalWorldTime() != this.lastSaveTime || this.isModified) {
                 return true;
             }
-        }
-        else if (this.hasEntities && this.worldObj.getTotalWorldTime() >= this.lastSaveTime + 600L)
-        {
+        } else if (this.hasEntities && this.worldObj.getTotalWorldTime() >= this.lastSaveTime + MinecraftServer.getServer().autosavePeriod * 4) { // Spigot - Only save if we've passed 2 auto save intervals without modification
             return true;
         }
 
         return this.isModified;
     }
 
-    public Random getRandomWithSeed(long seed)
-    {
-        return new Random(this.worldObj.getSeed() + (long)(this.xPosition * this.xPosition * 4987142) + (long)(this.xPosition * 5947611) + (long)(this.zPosition * this.zPosition) * 4392871L + (long)(this.zPosition * 389711) ^ seed);
+    public Random getRandomWithSeed(long seed) {
+        return new Random(this.worldObj.getSeed() + (long) (this.xPosition * this.xPosition * 4987142) + (long) (this.xPosition * 5947611) + (long) (this.zPosition * this.zPosition) * 4392871L + (long) (this.zPosition * 389711) ^ seed);
     }
 
-    public boolean isEmpty()
-    {
+    public boolean isEmpty() {
         return false;
     }
 
-    public void populateChunk(IChunkProvider p_76624_1_, IChunkProvider p_76624_2_, int p_76624_3_, int p_76624_4_)
-    {
+    public void populateChunk(IChunkProvider p_76624_1_, IChunkProvider p_76624_2_, int p_76624_3_, int p_76624_4_) {
+        worldObj.timings.syncChunkLoadPostTimer.startTiming(); // Spigot
         boolean flag = p_76624_1_.chunkExists(p_76624_3_, p_76624_4_ - 1);
         boolean flag1 = p_76624_1_.chunkExists(p_76624_3_ + 1, p_76624_4_);
         boolean flag2 = p_76624_1_.chunkExists(p_76624_3_, p_76624_4_ + 1);
         boolean flag3 = p_76624_1_.chunkExists(p_76624_3_ - 1, p_76624_4_);
         boolean flag4 = p_76624_1_.chunkExists(p_76624_3_ - 1, p_76624_4_ - 1);
         boolean flag5 = p_76624_1_.chunkExists(p_76624_3_ + 1, p_76624_4_ + 1);
         boolean flag6 = p_76624_1_.chunkExists(p_76624_3_ - 1, p_76624_4_ + 1);
         boolean flag7 = p_76624_1_.chunkExists(p_76624_3_ + 1, p_76624_4_ - 1);
 
-        if (flag1 && flag2 && flag5)
-        {
-            if (!this.isTerrainPopulated)
-            {
+        if (flag1 && flag2 && flag5) {
+            if (!this.isTerrainPopulated) {
                 p_76624_1_.populate(p_76624_2_, p_76624_3_, p_76624_4_);
-            }
-            else
-            {
+            } else {
                 p_76624_1_.func_177460_a(p_76624_2_, this, p_76624_3_, p_76624_4_);
             }
         }
 
         Chunk chunk;
 
-        if (flag3 && flag2 && flag6)
-        {
+        if (flag3 && flag2 && flag6) {
             chunk = p_76624_1_.provideChunk(p_76624_3_ - 1, p_76624_4_);
 
-            if (!chunk.isTerrainPopulated)
-            {
+            if (!chunk.isTerrainPopulated) {
                 p_76624_1_.populate(p_76624_2_, p_76624_3_ - 1, p_76624_4_);
-            }
-            else
-            {
+            } else {
                 p_76624_1_.func_177460_a(p_76624_2_, chunk, p_76624_3_ - 1, p_76624_4_);
             }
         }
 
-        if (flag && flag1 && flag7)
-        {
+        if (flag && flag1 && flag7) {
             chunk = p_76624_1_.provideChunk(p_76624_3_, p_76624_4_ - 1);
 
-            if (!chunk.isTerrainPopulated)
-            {
+            if (!chunk.isTerrainPopulated) {
                 p_76624_1_.populate(p_76624_2_, p_76624_3_, p_76624_4_ - 1);
-            }
-            else
-            {
+            } else {
                 p_76624_1_.func_177460_a(p_76624_2_, chunk, p_76624_3_, p_76624_4_ - 1);
             }
         }
 
-        if (flag4 && flag && flag3)
-        {
+        if (flag4 && flag && flag3) {
             chunk = p_76624_1_.provideChunk(p_76624_3_ - 1, p_76624_4_ - 1);
 
-            if (!chunk.isTerrainPopulated)
-            {
+            if (!chunk.isTerrainPopulated) {
                 p_76624_1_.populate(p_76624_2_, p_76624_3_ - 1, p_76624_4_ - 1);
-            }
-            else
-            {
+            } else {
                 p_76624_1_.func_177460_a(p_76624_2_, chunk, p_76624_3_ - 1, p_76624_4_ - 1);
             }
         }
+
+        worldObj.timings.syncChunkLoadPostTimer.stopTiming(); // Spigot
     }
 
-    public BlockPos getPrecipitationHeight(BlockPos pos)
-    {
+    public BlockPos getPrecipitationHeight(BlockPos pos) {
         int i = pos.getX() & 15;
         int j = pos.getZ() & 15;
         int k = i | j << 4;
         BlockPos blockpos1 = new BlockPos(pos.getX(), this.precipitationHeightMap[k], pos.getZ());
 
-        if (blockpos1.getY() == -999)
-        {
+        if (blockpos1.getY() == -999) {
             int l = this.getTopFilledSegment() + 15;
             blockpos1 = new BlockPos(pos.getX(), l, pos.getZ());
             int i1 = -1;
 
-            while (blockpos1.getY() > 0 && i1 == -1)
-            {
+            while (blockpos1.getY() > 0 && i1 == -1) {
                 Block block = this.getBlock(blockpos1);
                 Material material = block.getMaterial();
 
-                if (!material.blocksMovement() && !material.isLiquid())
-                {
+                if (!material.blocksMovement() && !material.isLiquid()) {
                     blockpos1 = blockpos1.down();
-                }
-                else
-                {
+                } else {
                     i1 = blockpos1.getY() + 1;
                 }
             }
 
             this.precipitationHeightMap[k] = i1;
         }
 
         return new BlockPos(pos.getX(), this.precipitationHeightMap[k], pos.getZ());
     }
 
-    public void func_150804_b(boolean p_150804_1_)
-    {
-        if (this.isGapLightingUpdated && !this.worldObj.provider.getHasNoSky() && !p_150804_1_)
-        {
+    public void func_150804_b(boolean p_150804_1_) {
+        if (this.isGapLightingUpdated && !this.worldObj.provider.getHasNoSky() && !p_150804_1_) {
             this.recheckGaps(this.worldObj.isRemote);
         }
 
         this.field_150815_m = true;
 
-        if (!this.isLightPopulated && this.isTerrainPopulated)
-        {
+        if (!this.isLightPopulated && this.isTerrainPopulated && this.worldObj.spigotConfig.randomLightUpdates) { // Spigot - also use random light updates setting to determine if we should relight
             this.func_150809_p();
         }
 
-        while (!this.field_177447_w.isEmpty())
-        {
-            BlockPos blockpos = (BlockPos)this.field_177447_w.poll();
+        while (!this.field_177447_w.isEmpty()) {
+            BlockPos blockpos = (BlockPos) this.field_177447_w.poll();
 
-            if (this.getTileEntity(blockpos, Chunk.EnumCreateEntityType.CHECK) == null && this.getBlock(blockpos).hasTileEntity())
-            {
+            if (this.getTileEntity(blockpos, Chunk.EnumCreateEntityType.CHECK) == null && this.getBlock(blockpos).hasTileEntity()) {
                 TileEntity tileentity = this.createNewTileEntity(blockpos);
                 this.worldObj.setTileEntity(blockpos, tileentity);
                 this.worldObj.markBlockRangeForRenderUpdate(blockpos, blockpos);
             }
         }
     }
 
-    public boolean isPopulated()
-    {
-        return this.field_150815_m && this.isTerrainPopulated && this.isLightPopulated;
+    public boolean isPopulated() {
+        // Spigot Start
+        /*
+         * As of 1.7, Mojang added a check to make sure that only chunks which have been lit are sent to the client.
+         * Unfortunately this interferes with our modified chunk ticking algorithm, which will only tick chunks distant from the player on a very infrequent basis.
+         * We cannot unfortunately do this lighting stage during chunk gen as it appears to put a lot more noticeable load on the server, than when it is done at play time.
+         * For now at least we will simply send all chunks, in accordance with pre 1.7 behaviour.
+         */
+        return true;
+        // Spigot End
     }
 
-    public ChunkCoordIntPair getChunkCoordIntPair()
-    {
+    public ChunkCoordIntPair getChunkCoordIntPair() {
         return new ChunkCoordIntPair(this.xPosition, this.zPosition);
     }
 
-    public boolean getAreLevelsEmpty(int startY, int endY)
-    {
-        if (startY < 0)
-        {
+    public boolean getAreLevelsEmpty(int startY, int endY) {
+        if (startY < 0) {
             startY = 0;
         }
 
-        if (endY >= 256)
-        {
+        if (endY >= 256) {
             endY = 255;
         }
 
-        for (int k = startY; k <= endY; k += 16)
-        {
+        for (int k = startY; k <= endY; k += 16) {
             ExtendedBlockStorage extendedblockstorage = this.storageArrays[k >> 4];
 
-            if (extendedblockstorage != null && !extendedblockstorage.isEmpty())
-            {
+            if (extendedblockstorage != null && !extendedblockstorage.isEmpty()) {
                 return false;
             }
         }
 
         return true;
     }
 
-    public void setStorageArrays(ExtendedBlockStorage[] newStorageArrays)
-    {
-        if (this.storageArrays.length != newStorageArrays.length)
-        {
+    public void setStorageArrays(ExtendedBlockStorage[] newStorageArrays) {
+        if (this.storageArrays.length != newStorageArrays.length) {
             logger.warn("Could not set level chunk sections, array length is " + newStorageArrays.length + " instead of " + this.storageArrays.length);
-        }
-        else
-        {
-            for (int i = 0; i < this.storageArrays.length; ++i)
-            {
+        } else {
+            for (int i = 0; i < this.storageArrays.length; ++i) {
                 this.storageArrays[i] = newStorageArrays[i];
             }
         }
     }
 
-    @SideOnly(Side.CLIENT)
-    public void fillChunk(byte[] p_177439_1_, int p_177439_2_, boolean p_177439_3_)
-    {
-        int j = 0;
-        boolean flag1 = !this.worldObj.provider.getHasNoSky();
-        int k;
-
-        for (k = 0; k < this.storageArrays.length; ++k)
-        {
-            if ((p_177439_2_ & 1 << k) != 0)
-            {
-                if (this.storageArrays[k] == null)
-                {
-                    this.storageArrays[k] = new ExtendedBlockStorage(k << 4, flag1);
-                }
-
-                char[] achar = this.storageArrays[k].getData();
-
-                for (int l = 0; l < achar.length; ++l)
-                {
-                    achar[l] = (char)((p_177439_1_[j + 1] & 255) << 8 | p_177439_1_[j] & 255);
-                    j += 2;
-                }
-            }
-            else if (p_177439_3_ && this.storageArrays[k] != null)
-            {
-                this.storageArrays[k] = null;
-            }
-        }
-
-        NibbleArray nibblearray;
-
-        for (k = 0; k < this.storageArrays.length; ++k)
-        {
-            if ((p_177439_2_ & 1 << k) != 0 && this.storageArrays[k] != null)
-            {
-                nibblearray = this.storageArrays[k].getBlocklightArray();
-                System.arraycopy(p_177439_1_, j, nibblearray.getData(), 0, nibblearray.getData().length);
-                j += nibblearray.getData().length;
-            }
-        }
-
-        if (flag1)
-        {
-            for (k = 0; k < this.storageArrays.length; ++k)
-            {
-                if ((p_177439_2_ & 1 << k) != 0 && this.storageArrays[k] != null)
-                {
-                    nibblearray = this.storageArrays[k].getSkylightArray();
-                    System.arraycopy(p_177439_1_, j, nibblearray.getData(), 0, nibblearray.getData().length);
-                    j += nibblearray.getData().length;
-                }
-            }
-        }
-
-        if (p_177439_3_)
-        {
-            System.arraycopy(p_177439_1_, j, this.blockBiomeArray, 0, this.blockBiomeArray.length);
-            int i1 = j + this.blockBiomeArray.length;
-        }
-
-        for (k = 0; k < this.storageArrays.length; ++k)
-        {
-            if (this.storageArrays[k] != null && (p_177439_2_ & 1 << k) != 0)
-            {
-                this.storageArrays[k].removeInvalidBlocks();
-            }
-        }
-
-        this.isLightPopulated = true;
-        this.isTerrainPopulated = true;
-        this.generateHeightMap();
-        Iterator iterator = this.chunkTileEntityMap.values().iterator();
-
-        while (iterator.hasNext())
-        {
-            TileEntity tileentity = (TileEntity)iterator.next();
-            tileentity.updateContainingBlockInfo();
-        }
-    }
-
-    public BiomeGenBase getBiome(BlockPos pos, WorldChunkManager chunkManager)
-    {
+    public BiomeGenBase getBiome(BlockPos pos, WorldChunkManager chunkManager) {
         int i = pos.getX() & 15;
         int j = pos.getZ() & 15;
         int k = this.blockBiomeArray[j << 4 | i] & 255;
         BiomeGenBase biomegenbase;
 
-        if (k == 255)
-        {
+        if (k == 255) {
             biomegenbase = chunkManager.func_180300_a(pos, BiomeGenBase.plains);
             k = biomegenbase.biomeID;
-            this.blockBiomeArray[j << 4 | i] = (byte)(k & 255);
+            this.blockBiomeArray[j << 4 | i] = (byte) (k & 255);
         }
 
         biomegenbase = BiomeGenBase.getBiome(k);
         return biomegenbase == null ? BiomeGenBase.plains : biomegenbase;
     }
 
-    public byte[] getBiomeArray()
-    {
+    public byte[] getBiomeArray() {
         return this.blockBiomeArray;
     }
 
-    public void setBiomeArray(byte[] biomeArray)
-    {
-        if (this.blockBiomeArray.length != biomeArray.length)
-        {
+    public void setBiomeArray(byte[] biomeArray) {
+        if (this.blockBiomeArray.length != biomeArray.length) {
             logger.warn("Could not set level chunk biomes, array length is " + biomeArray.length + " instead of " + this.blockBiomeArray.length);
-        }
-        else
-        {
-            for (int i = 0; i < this.blockBiomeArray.length; ++i)
-            {
+        } else {
+            for (int i = 0; i < this.blockBiomeArray.length; ++i) {
                 this.blockBiomeArray[i] = biomeArray[i];
             }
         }
     }
 
-    public void resetRelightChecks()
-    {
+    public void resetRelightChecks() {
         this.queuedLightChecks = 0;
     }
 
-    public void enqueueRelightChecks()
-    {
+    public void enqueueRelightChecks() {
         BlockPos blockpos = new BlockPos(this.xPosition << 4, 0, this.zPosition << 4);
 
-        for (int i = 0; i < 8; ++i)
-        {
-            if (this.queuedLightChecks >= 4096)
-            {
+        for (int i = 0; i < 8; ++i) {
+            if (this.queuedLightChecks >= 4096) {
                 return;
             }
 
             int j = this.queuedLightChecks % 16;
             int k = this.queuedLightChecks / 16 % 16;
             int l = this.queuedLightChecks / 256;
             ++this.queuedLightChecks;
 
-            for (int i1 = 0; i1 < 16; ++i1)
-            {
+            for (int i1 = 0; i1 < 16; ++i1) {
                 BlockPos blockpos1 = blockpos.add(k, (j << 4) + i1, l);
                 boolean flag = i1 == 0 || i1 == 15 || k == 0 || k == 15 || l == 0 || l == 15;
 
-                if (this.storageArrays[j] == null && flag || this.storageArrays[j] != null && this.storageArrays[j].getBlockByExtId(k, i1, l).getMaterial() == Material.air)
-                {
+                if (this.storageArrays[j] == null && flag || this.storageArrays[j] != null && this.storageArrays[j].getBlockByExtId(k, i1, l).getMaterial() == Material.air) {
                     EnumFacing[] aenumfacing = EnumFacing.values();
                     int j1 = aenumfacing.length;
 
-                    for (int k1 = 0; k1 < j1; ++k1)
-                    {
+                    for (int k1 = 0; k1 < j1; ++k1) {
                         EnumFacing enumfacing = aenumfacing[k1];
                         BlockPos blockpos2 = blockpos1.offset(enumfacing);
 
-                        if (this.worldObj.getBlockState(blockpos2).getBlock().getLightValue() > 0)
-                        {
+                        if (this.worldObj.getBlockState(blockpos2).getBlock().getLightValue() > 0) {
                             this.worldObj.checkLight(blockpos2);
                         }
                     }
 
                     this.worldObj.checkLight(blockpos1);
                 }
             }
         }
     }
 
-    public void func_150809_p()
-    {
+    public void func_150809_p() {
         this.isTerrainPopulated = true;
         this.isLightPopulated = true;
         BlockPos blockpos = new BlockPos(this.xPosition << 4, 0, this.zPosition << 4);
 
-        if (!this.worldObj.provider.getHasNoSky())
-        {
-            if (this.worldObj.isAreaLoaded(blockpos.add(-1, 0, -1), blockpos.add(16, 63, 16)))
-            {
+        if (!this.worldObj.provider.getHasNoSky()) {
+            if (this.worldObj.isAreaLoaded(blockpos.add(-1, 0, -1), blockpos.add(16, 63, 16))) {
                 label42:
 
-                for (int i = 0; i < 16; ++i)
-                {
-                    for (int j = 0; j < 16; ++j)
-                    {
-                        if (!this.func_150811_f(i, j))
-                        {
+                for (int i = 0; i < 16; ++i) {
+                    for (int j = 0; j < 16; ++j) {
+                        if (!this.func_150811_f(i, j)) {
                             this.isLightPopulated = false;
                             break label42;
                         }
                     }
                 }
 
-                if (this.isLightPopulated)
-                {
+                if (this.isLightPopulated) {
                     Iterator iterator = EnumFacing.Plane.HORIZONTAL.iterator();
 
-                    while (iterator.hasNext())
-                    {
-                        EnumFacing enumfacing = (EnumFacing)iterator.next();
+                    while (iterator.hasNext()) {
+                        EnumFacing enumfacing = (EnumFacing) iterator.next();
                         int k = enumfacing.getAxisDirection() == EnumFacing.AxisDirection.POSITIVE ? 16 : 1;
                         this.worldObj.getChunkFromBlockCoords(blockpos.offset(enumfacing, k)).func_180700_a(enumfacing.getOpposite());
                     }
 
                     this.func_177441_y();
                 }
-            }
-            else
-            {
+            } else {
                 this.isLightPopulated = false;
             }
         }
     }
 
-    private void func_177441_y()
-    {
-        for (int i = 0; i < this.updateSkylightColumns.length; ++i)
-        {
+    private void func_177441_y() {
+        for (int i = 0; i < this.updateSkylightColumns.length; ++i) {
             this.updateSkylightColumns[i] = true;
         }
 
         this.recheckGaps(false);
     }
 
-    private void func_180700_a(EnumFacing p_180700_1_)
-    {
-        if (this.isTerrainPopulated)
-        {
+    private void func_180700_a(EnumFacing p_180700_1_) {
+        if (this.isTerrainPopulated) {
             int i;
 
-            if (p_180700_1_ == EnumFacing.EAST)
-            {
-                for (i = 0; i < 16; ++i)
-                {
+            if (p_180700_1_ == EnumFacing.EAST) {
+                for (i = 0; i < 16; ++i) {
                     this.func_150811_f(15, i);
                 }
-            }
-            else if (p_180700_1_ == EnumFacing.WEST)
-            {
-                for (i = 0; i < 16; ++i)
-                {
+            } else if (p_180700_1_ == EnumFacing.WEST) {
+                for (i = 0; i < 16; ++i) {
                     this.func_150811_f(0, i);
                 }
-            }
-            else if (p_180700_1_ == EnumFacing.SOUTH)
-            {
-                for (i = 0; i < 16; ++i)
-                {
+            } else if (p_180700_1_ == EnumFacing.SOUTH) {
+                for (i = 0; i < 16; ++i) {
                     this.func_150811_f(i, 15);
                 }
-            }
-            else if (p_180700_1_ == EnumFacing.NORTH)
-            {
-                for (i = 0; i < 16; ++i)
-                {
+            } else if (p_180700_1_ == EnumFacing.NORTH) {
+                for (i = 0; i < 16; ++i) {
                     this.func_150811_f(i, 0);
                 }
             }
         }
     }
 
-    private boolean func_150811_f(int x, int z)
-    {
+    private boolean func_150811_f(int x, int z) {
         BlockPos blockpos = new BlockPos(this.xPosition << 4, 0, this.zPosition << 4);
         int k = this.getTopFilledSegment();
         boolean flag = false;
         boolean flag1 = false;
         int l;
         BlockPos blockpos1;
 
-        for (l = k + 16 - 1; l > 63 || l > 0 && !flag1; --l)
-        {
+        for (l = k + 16 - 1; l > 63 || l > 0 && !flag1; --l) {
             blockpos1 = blockpos.add(x, l, z);
             int i1 = this.getBlockLightOpacity(blockpos1);
 
-            if (i1 == 255 && l < 63)
-            {
+            if (i1 == 255 && l < 63) {
                 flag1 = true;
             }
 
-            if (!flag && i1 > 0)
-            {
+            if (!flag && i1 > 0) {
                 flag = true;
-            }
-            else if (flag && i1 == 0 && !this.worldObj.checkLight(blockpos1))
-            {
+            } else if (flag && i1 == 0 && !this.worldObj.checkLight(blockpos1)) {
                 return false;
             }
         }
 
-        for (; l > 0; --l)
-        {
+        for (; l > 0; --l) {
             blockpos1 = blockpos.add(x, l, z);
 
-            if (this.getBlock(blockpos1).getLightValue() > 0)
-            {
+            if (this.getBlock(blockpos1).getLightValue() > 0) {
                 this.worldObj.checkLight(blockpos1);
             }
         }
 
         return true;
     }
 
-    public boolean isLoaded()
-    {
+    public boolean isLoaded() {
         return this.isChunkLoaded;
     }
 
-    @SideOnly(Side.CLIENT)
-    public void setChunkLoaded(boolean loaded)
-    {
-        this.isChunkLoaded = loaded;
-    }
-
-    public World getWorld()
-    {
+    public World getWorld() {
         return this.worldObj;
     }
 
-    public int[] getHeightMap()
-    {
+    public int[] getHeightMap() {
         return this.heightMap;
     }
 
-    public void setHeightMap(int[] newHeightMap)
-    {
-        if (this.heightMap.length != newHeightMap.length)
-        {
+    public void setHeightMap(int[] newHeightMap) {
+        if (this.heightMap.length != newHeightMap.length) {
             logger.warn("Could not set level chunk heightmap, array length is " + newHeightMap.length + " instead of " + this.heightMap.length);
-        }
-        else
-        {
-            for (int i = 0; i < this.heightMap.length; ++i)
-            {
+        } else {
+            for (int i = 0; i < this.heightMap.length; ++i) {
                 this.heightMap[i] = newHeightMap[i];
             }
         }
     }
 
-    public Map getTileEntityMap()
-    {
+    public Map getTileEntityMap() {
         return this.chunkTileEntityMap;
     }
 
-    public ClassInheritanceMultiMap[] getEntityLists()
-    {
+    public List<Entity>[] getEntityLists() { // Spigot
         return this.entityLists;
     }
 
-    public boolean isTerrainPopulated()
-    {
+    public boolean isTerrainPopulated() {
         return this.isTerrainPopulated;
     }
 
-    public void setTerrainPopulated(boolean terrainPopulated)
-    {
+    public void setTerrainPopulated(boolean terrainPopulated) {
         this.isTerrainPopulated = terrainPopulated;
     }
 
-    public boolean isLightPopulated()
-    {
+    public boolean isLightPopulated() {
         return this.isLightPopulated;
     }
 
-    public void setLightPopulated(boolean lightPopulated)
-    {
+    public void setLightPopulated(boolean lightPopulated) {
         this.isLightPopulated = lightPopulated;
     }
 
-    public void setModified(boolean modified)
-    {
+    public void setModified(boolean modified) {
         this.isModified = modified;
     }
 
-    public void setHasEntities(boolean hasEntitiesIn)
-    {
+    public void setHasEntities(boolean hasEntitiesIn) {
         this.hasEntities = hasEntitiesIn;
     }
 
-    public void setLastSaveTime(long saveTime)
-    {
+    public void setLastSaveTime(long saveTime) {
         this.lastSaveTime = saveTime;
     }
 
-    public int getLowestHeight()
-    {
+    public int getLowestHeight() {
         return this.heightMapMinimum;
     }
 
-    public long getInhabitedTime()
-    {
+    public long getInhabitedTime() {
         return this.inhabitedTime;
     }
 
-    public void setInhabitedTime(long newInhabitedTime)
-    {
+    public void setInhabitedTime(long newInhabitedTime) {
         this.inhabitedTime = newInhabitedTime;
     }
 
-    public static enum EnumCreateEntityType
-    {
+    public static enum EnumCreateEntityType {
         IMMEDIATE,
         QUEUED,
         CHECK;
 
         private static final String __OBFID = "CL_00002009";
