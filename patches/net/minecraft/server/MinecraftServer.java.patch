--- decompiled\net\minecraft\server\MinecraftServer.java
+++ src\main\java\net\minecraft\server\MinecraftServer.java
@@ -1,42 +1,30 @@
 package net.minecraft.server;
 
-import com.google.common.base.Charsets;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.ListenableFutureTask;
-import com.mojang.authlib.GameProfile;
-import com.mojang.authlib.GameProfileRepository;
-import com.mojang.authlib.minecraft.MinecraftSessionService;
-import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufOutputStream;
-import io.netty.buffer.Unpooled;
-import io.netty.handler.codec.base64.Base64;
-import java.awt.GraphicsEnvironment;
+import java.awt.*;
 import java.awt.image.BufferedImage;
 import java.io.File;
 import java.io.IOException;
 import java.net.Proxy;
 import java.security.KeyPair;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Queue;
 import java.util.Random;
 import java.util.UUID;
 import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
+
 import javax.imageio.ImageIO;
-import net.minecraft.command.CommandBase;
+
 import net.minecraft.command.CommandResultStats;
 import net.minecraft.command.ICommandManager;
 import net.minecraft.command.ICommandSender;
 import net.minecraft.command.ServerCommandManager;
 import net.minecraft.crash.CrashReport;
@@ -69,36 +57,71 @@
 import net.minecraft.world.WorldManager;
 import net.minecraft.world.WorldServer;
 import net.minecraft.world.WorldServerMulti;
 import net.minecraft.world.WorldSettings;
 import net.minecraft.world.WorldType;
-import net.minecraft.world.chunk.storage.AnvilSaveConverter;
+import net.minecraft.world.chunk.storage.AnvilSaveHandler;
 import net.minecraft.world.demo.DemoWorldServer;
 import net.minecraft.world.storage.ISaveFormat;
 import net.minecraft.world.storage.ISaveHandler;
 import net.minecraft.world.storage.WorldInfo;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
+
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.World.Environment;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.command.RemoteConsoleCommandSender;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.Main;
+import org.bukkit.craftbukkit.SpigotTimings;
+import org.bukkit.craftbukkit.scoreboard.CraftScoreboardManager;
+import org.bukkit.craftbukkit.util.ServerShutdownThread;
+import org.bukkit.craftbukkit.util.Waitable;
+import org.bukkit.event.world.WorldInitEvent;
+import org.bukkit.event.world.WorldLoadEvent;
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.PluginLoadOrder;
+import org.spigotmc.CustomTimingsHandler;
+import org.spigotmc.WatchdogThread;
 
+import com.google.common.base.Charsets;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.ListenableFutureTask;
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import com.mojang.authlib.minecraft.MinecraftSessionService;
+import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufOutputStream;
+import io.netty.buffer.Unpooled;
+import io.netty.handler.codec.base64.Base64;
+
+import jline.console.ConsoleReader;
+import joptsimple.OptionSet;
+
 public abstract class MinecraftServer implements ICommandSender, Runnable, IThreadListener, IPlayerUsage
 {
+
     private static final Logger logger = LogManager.getLogger();
     public static final File USER_CACHE_FILE = new File("usercache.json");
     private static MinecraftServer mcServer;
-    private final ISaveFormat anvilConverterForAnvilFile;
+    public ISaveFormat anvilConverterForAnvilFile; // SpigotMCP -- Apply access transformation
     private final PlayerUsageSnooper usageSnooper = new PlayerUsageSnooper("server", this, getCurrentTimeMillis());
-    private final File anvilFile;
+    public File anvilFile; // SpigotMCP -- Apply access transformation
     private final List playersOnline = Lists.newArrayList();
     private final ICommandManager commandManager;
     public final Profiler theProfiler = new Profiler();
-    private final NetworkSystem networkSystem;
+    private NetworkSystem networkSystem; // Spigot
     private final ServerStatusResponse statusResponse = new ServerStatusResponse();
     private final Random random = new Random();
-    @SideOnly(Side.SERVER)
+
     private String hostname;
     private int serverPort = -1;
     public WorldServer[] worldServers;
     private ServerConfigurationManager serverConfigManager;
     private boolean serverRunning = true;
@@ -118,12 +141,10 @@
     public final long[] tickTimeArray = new long[100];
     public long[][] timeOfLastDimensionTick;
     private KeyPair serverKeyPair;
     private String serverOwner;
     private String folderName;
-    @SideOnly(Side.CLIENT)
-    private String worldName;
     private boolean isDemo;
     private boolean enableBonusChest;
     private boolean worldIsBeingDeleted;
     private String resourcePackUrl = "";
     private String resourcePackHash = "";
@@ -140,163 +161,306 @@
     protected final Queue futureTaskQueue = Queues.newArrayDeque();
     private Thread serverThread;
     private long currentTime = getCurrentTimeMillis();
     private static final String __OBFID = "CL_00001462";
 
-    @SideOnly(Side.CLIENT)
-    public MinecraftServer(Proxy proxy, File workDir)
-    {
-        this.serverProxy = proxy;
-        mcServer = this;
-        this.anvilFile = null;
-        this.networkSystem = null;
-        this.profileCache = new PlayerProfileCache(this, workDir);
-        this.commandManager = null;
-        this.anvilConverterForAnvilFile = null;
-        this.authService = new YggdrasilAuthenticationService(proxy, UUID.randomUUID().toString());
-        this.sessionService = this.authService.createMinecraftSessionService();
-        this.profileRepo = this.authService.createProfileRepository();
-    }
+    // CraftBukkit start
+    public List<WorldServer> worlds = new ArrayList<WorldServer>();
+    public CraftServer server;
+    public OptionSet options;
+    public ConsoleCommandSender console;
+    public RemoteConsoleCommandSender remoteConsole;
+    public ConsoleReader reader;
+    public static int currentTick = (int)(System.currentTimeMillis() / 50);
+    public final Thread primaryThread;
+    public Queue<Runnable> processQueue = new ConcurrentLinkedQueue<Runnable>();
+    public int autosavePeriod;
+    // CraftBukkit end
+    // Spigot start
+    private static final int TPS = 20;
+    private static final int TICK_TIME = 1000000000 / TPS;
+    private static final int SAMPLE_INTERVAL = 100;
+    public final double[] recentTps = new double[3];
+    // Spigot end
 
-    public MinecraftServer(File workDir, Proxy proxy, File profileCacheDir)
+    public MinecraftServer(OptionSet options, Proxy proxy, File profileCacheDir)
     {
+        io.netty.util.ResourceLeakDetector.setEnabled(false); // Spigot - disable
         this.serverProxy = proxy;
         mcServer = this;
-        this.anvilFile = workDir;
-        this.networkSystem = new NetworkSystem(this);
+        // this.anvilFile = workDir; // CraftBukkit
+        // this.networkSystem = new NetworkSystem(this); // Spigot
         this.profileCache = new PlayerProfileCache(this, profileCacheDir);
         this.commandManager = this.createNewCommandManager();
-        this.anvilConverterForAnvilFile = new AnvilSaveConverter(workDir);
+        // this.anvilConverterForAnvilFile = new AnvilSaveConverter(workDir); // CraftBukkit - moved to DedicatedServer.init
         this.authService = new YggdrasilAuthenticationService(proxy, UUID.randomUUID().toString());
         this.sessionService = this.authService.createMinecraftSessionService();
         this.profileRepo = this.authService.createProfileRepository();
+        // CraftBukkit start
+        this.options = options;
+
+        // Try to see if we're actually running in a terminal, disable jline if not
+        if (System.console() == null)
+        {
+            System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
+            Main.useJline = false;
+        }
+
+        try
+        {
+            reader = new ConsoleReader(System.in, System.out);
+            reader.setExpandEvents(false); // Avoid parsing exceptions for uncommonly used event designators
+        }
+        catch (Throwable e)
+        {
+            try
+            {
+                // Try again with jline disabled for Windows users without C++ 2008 Redistributable
+                System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
+                System.setProperty("user.language", "en");
+                Main.useJline = false;
+                reader = new ConsoleReader(System.in, System.out);
+                reader.setExpandEvents(false);
+            }
+            catch (IOException ex)
+            {
+                logger.warn((String)null, ex);
+            }
+        }
+
+        Runtime.getRuntime().addShutdownHook(new ServerShutdownThread(this));
+        this.serverThread = primaryThread = new Thread(this, "Server thread"); // Moved from main
     }
 
+    public abstract net.minecraft.server.dedicated.PropertyManager getPropertyManager();
+    // CraftBukkit end
+
     protected ServerCommandManager createNewCommandManager()
     {
         return new ServerCommandManager();
     }
 
-    protected abstract boolean startServer() throws IOException;
+    protected abstract boolean startServer() throws IOException; // CraftBukkit - throws UnknownHostException // SpigotMCP NOTE -- MCP added supperclass
 
+    // SpigotMCP Start -- Convert to regualar inner class
+    public class ConvertProgressUpdater implements IProgressUpdate
+    {
+
+        private long startTime = System.currentTimeMillis();
+        private static final String __OBFID = "CL_00001417";
+
+        public void displaySavingString(String message)
+        {
+        }
+
+        public void setLoadingProgress(int progress)
+        {
+            if (System.currentTimeMillis() - this.startTime >= 1000L)
+            {
+                this.startTime = System.currentTimeMillis();
+                MinecraftServer.logger.info("Converting... " + progress + "%");
+            }
+        }
+
+        public void displayLoadingString(String message)
+        {
+        }
+    }
+    // SpigotMCP End
+
     protected void convertMapIfNeeded(String worldNameIn)
     {
         if (this.getActiveAnvilConverter().isOldMapFormat(worldNameIn))
         {
             logger.info("Converting map!");
             this.setUserMessage("menu.convertingLevel");
-            this.getActiveAnvilConverter().convertMapFormat(worldNameIn, new IProgressUpdate()
-            {
-                private long startTime = System.currentTimeMillis();
-                private static final String __OBFID = "CL_00001417";
-                public void displaySavingString(String message) {}
-                public void setLoadingProgress(int progress)
-                {
-                    if (System.currentTimeMillis() - this.startTime >= 1000L)
-                    {
-                        this.startTime = System.currentTimeMillis();
-                        MinecraftServer.logger.info("Converting... " + progress + "%");
-                    }
-                }
-                @SideOnly(Side.CLIENT)
-                public void resetProgressAndMessage(String p_73721_1_) {}
-                @SideOnly(Side.CLIENT)
-                public void setDoneWorking() {}
-                public void displayLoadingString(String message) {}
-            });
+            this.getActiveAnvilConverter().convertMapFormat(worldNameIn, new ConvertProgressUpdater()); // SpigotMCP -- Convert to regualar inner class
         }
     }
 
     protected synchronized void setUserMessage(String message)
     {
         this.userMessage = message;
     }
 
-    @SideOnly(Side.CLIENT)
-
     public synchronized String getUserMessage()
     {
         return this.userMessage;
     }
 
     protected void loadAllWorlds(String p_71247_1_, String p_71247_2_, long seed, WorldType type, String p_71247_6_)
     {
         this.convertMapIfNeeded(p_71247_1_);
         this.setUserMessage("menu.loadingLevel");
         this.worldServers = new WorldServer[3];
+        // CraftBukkit start - Remove ticktime arrays and worldsettings
+        /*
         this.timeOfLastDimensionTick = new long[this.worldServers.length][100];
         ISaveHandler isavehandler = this.anvilConverterForAnvilFile.getSaveLoader(p_71247_1_, true);
         this.setResourcePackFromWorld(this.getFolderName(), isavehandler);
         WorldInfo worldinfo = isavehandler.loadWorldInfo();
         WorldSettings worldsettings;
 
-        if (worldinfo == null)
-        {
-            if (this.isDemo())
-            {
+        if (worldinfo == null) {
+            if (this.isDemo()) {
                 worldsettings = DemoWorldServer.demoWorldSettings;
-            }
-            else
-            {
+            } else {
                 worldsettings = new WorldSettings(seed, this.getGameType(), this.canStructuresSpawn(), this.isHardcore(), type);
                 worldsettings.setWorldName(p_71247_6_);
 
-                if (this.enableBonusChest)
-                {
+                if (this.enableBonusChest) {
                     worldsettings.enableBonusChest();
                 }
             }
 
             worldinfo = new WorldInfo(worldsettings, p_71247_2_);
-        }
-        else
-        {
+        } else {
             worldinfo.setWorldName(p_71247_2_);
             worldsettings = new WorldSettings(worldinfo);
         }
+        */
+        int worldCount = 3;
 
-        for (int j = 0; j < this.worldServers.length; ++j)
+        for (int j = 0; j < worldCount; ++j)
         {
-            byte b0 = 0;
+            WorldServer world;
+            byte dimension = 0;
 
             if (j == 1)
             {
-                b0 = -1;
+                if (getAllowNether())
+                {
+                    dimension = -1;
+                }
+                else
+                {
+                    continue;
+                }
             }
 
             if (j == 2)
             {
-                b0 = 1;
+                if (server.getAllowEnd())
+                {
+                    dimension = 1;
+                }
+                else
+                {
+                    continue;
+                }
             }
 
+            String worldType = Environment.getEnvironment(dimension).toString().toLowerCase();
+            String name = (dimension == 0) ? p_71247_1_ : p_71247_1_ + "_" + worldType;
+            ChunkGenerator gen = this.server.getGenerator(name);
+            WorldSettings worldsettings = new WorldSettings(seed, this.getGameType(), this.canStructuresSpawn(), this.isHardcore(), type);
+            worldsettings.setWorldName(p_71247_6_);
+
             if (j == 0)
             {
+                ISaveHandler idatamanager = new AnvilSaveHandler(server.getWorldContainer(), p_71247_2_, true);
+                WorldInfo worlddata = idatamanager.loadWorldInfo();
+
+                if (worlddata == null)
+                {
+                    worlddata = new WorldInfo(worldsettings, p_71247_2_);
+                }
+
+                worlddata.checkName(p_71247_2_); // CraftBukkit - Migration did not rewrite the level.dat; This forces 1.8 to take the last loaded world as respawn (in this case the end)
+
                 if (this.isDemo())
                 {
-                    this.worldServers[j] = (WorldServer)(new DemoWorldServer(this, isavehandler, worldinfo, b0, this.theProfiler)).init();
+                    world = (WorldServer)(new DemoWorldServer(this, idatamanager, worlddata, dimension, this.theProfiler, Environment.getEnvironment(dimension), gen)).init();  // SpigotMCP -- Add extra args
                 }
                 else
                 {
-                    this.worldServers[j] = (WorldServer)(new WorldServer(this, isavehandler, worldinfo, b0, this.theProfiler)).init();
+                    world = (WorldServer)(new WorldServer(this, idatamanager, worlddata, dimension, this.theProfiler, Environment.getEnvironment(dimension), gen)).init();
                 }
 
-                this.worldServers[j].initialize(worldsettings);
+                world.initialize(worldsettings);
+                this.server.scoreboardManager = new CraftScoreboardManager(this, world.getScoreboard());
             }
             else
             {
-                this.worldServers[j] = (WorldServer)(new WorldServerMulti(this, isavehandler, b0, this.worldServers[0], this.theProfiler)).init();
+                String dim = "DIM" + dimension;
+                File newWorld = new File(new File(name), dim);
+                File oldWorld = new File(new File(p_71247_1_), dim);
+
+                if ((!newWorld.isDirectory()) && (oldWorld.isDirectory()))
+                {
+                    MinecraftServer.logger.info("---- Migration of old " + worldType + " folder required ----");
+                    MinecraftServer.logger.info("Unfortunately due to the way that Minecraft implemented multiworld support in 1.6, Bukkit requires that you move your " + worldType + " folder to a new location in order to operate correctly.");
+                    MinecraftServer.logger.info("We will move this folder for you, but it will mean that you need to move it back should you wish to stop using Bukkit in the future.");
+                    MinecraftServer.logger.info("Attempting to move " + oldWorld + " to " + newWorld + "...");
+
+                    if (newWorld.exists())
+                    {
+                        MinecraftServer.logger.warn("A file or folder already exists at " + newWorld + "!");
+                        MinecraftServer.logger.info("---- Migration of old " + worldType + " folder failed ----");
+                    }
+                    else if (newWorld.getParentFile().mkdirs())
+                    {
+                        if (oldWorld.renameTo(newWorld))
+                        {
+                            MinecraftServer.logger.info("Success! To restore " + worldType + " in the future, simply move " + newWorld + " to " + oldWorld);
+
+                            // Migrate world data too.
+                            try
+                            {
+                                com.google.common.io.Files.copy(new File(new File(p_71247_1_), "level.dat"), new File(new File(name), "level.dat"));
+                            }
+                            catch (IOException exception)
+                            {
+                                MinecraftServer.logger.warn("Unable to migrate world data.");
+                            }
+
+                            MinecraftServer.logger.info("---- Migration of old " + worldType + " folder complete ----");
+                        }
+                        else
+                        {
+                            MinecraftServer.logger.warn("Could not move folder " + oldWorld + " to " + newWorld + "!");
+                            MinecraftServer.logger.info("---- Migration of old " + worldType + " folder failed ----");
+                        }
+                    }
+                    else
+                    {
+                        MinecraftServer.logger.warn("Could not create path for " + newWorld + "!");
+                        MinecraftServer.logger.info("---- Migration of old " + worldType + " folder failed ----");
+                    }
+                }
+
+                ISaveHandler idatamanager = new AnvilSaveHandler(server.getWorldContainer(), name, true);
+                // world =, b0 to dimension, s1 to name, added Environment and gen
+                WorldInfo worlddata = idatamanager.loadWorldInfo();
+
+                if (worlddata == null)
+                {
+                    worlddata = new WorldInfo(worldsettings, name);
+                }
+
+                worlddata.checkName(name); // CraftBukkit - Migration did not rewrite the level.dat; This forces 1.8 to take the last loaded world as respawn (in this case the end)
+                world = (WorldServer)new WorldServerMulti(this, idatamanager, dimension, this.worlds.get(0), this.theProfiler, worlddata, org.bukkit.World.Environment.getEnvironment(dimension), gen).init();
             }
 
-            this.worldServers[j].addWorldAccess(new WorldManager(this, this.worldServers[j]));
+            if (gen != null)
+            {
+                world.getWorld().getPopulators().addAll(gen.getDefaultPopulators(world.getWorld()));
+            }
 
+            this.server.getPluginManager().callEvent(new WorldInitEvent(world.getWorld()));
+            world.addWorldAccess(new WorldManager(this, world));
+
             if (!this.isSinglePlayer())
             {
-                this.worldServers[j].getWorldInfo().setGameType(this.getGameType());
+                world.getWorldInfo().setGameType(this.getGameType());
             }
+
+            worlds.add(world);
+            getConfigurationManager().setPlayerManager(worlds.toArray(new WorldServer[worlds.size()]));
         }
 
-        this.serverConfigManager.setPlayerManager(this.worldServers);
+        // CraftBukkit end
         this.setDifficultyForAllWorlds(this.getDifficulty());
         this.initialWorldChunkLoad();
     }
 
     protected void initialWorldChunkLoad()
@@ -306,32 +470,50 @@
         boolean flag2 = true;
         boolean flag3 = true;
         int i = 0;
         this.setUserMessage("menu.generatingTerrain");
         byte b0 = 0;
-        logger.info("Preparing start region for level " + b0);
-        WorldServer worldserver = this.worldServers[b0];
-        BlockPos blockpos = worldserver.getSpawnPoint();
-        long j = getCurrentTimeMillis();
 
-        for (int k = -192; k <= 192 && this.isServerRunning(); k += 16)
+        // CraftBukkit start - fire WorldLoadEvent and handle whether or not to keep the spawn in memory
+        for (int m = 0; m < worlds.size(); m++)
         {
-            for (int l = -192; l <= 192 && this.isServerRunning(); l += 16)
+            WorldServer worldserver = this.worlds.get(m);
+            logger.info("Preparing start region for level " + m + " (Seed: " + worldserver.getSeed() + ")");
+
+            if (!worldserver.getWorld().getKeepSpawnInMemory())
             {
-                long i1 = getCurrentTimeMillis();
+                continue;
+            }
 
-                if (i1 - j > 1000L)
+            BlockPos blockposition = worldserver.getSpawnPoint();
+            long j = getCurrentTimeMillis();
+            i = 0;
+
+            for (int k = -192; k <= 192 && this.isServerRunning(); k += 16)
+            {
+                for (int l = -192; l <= 192 && this.isServerRunning(); l += 16)
                 {
-                    this.outputPercentRemaining("Preparing spawn area", i * 100 / 625);
-                    j = i1;
-                }
+                    long i1 = getCurrentTimeMillis();
 
-                ++i;
-                worldserver.theChunkProviderServer.loadChunk(blockpos.getX() + k >> 4, blockpos.getZ() + l >> 4);
+                    if (i1 - j > 1000L)
+                    {
+                        this.outputPercentRemaining("Preparing spawn area", i * 100 / 625);
+                        j = i1;
+                    }
+
+                    ++i;
+                    worldserver.theChunkProviderServer.loadChunk(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                }
             }
         }
 
+        for (WorldServer world : this.worlds)
+        {
+            this.server.getPluginManager().callEvent(new WorldLoadEvent(world.getWorld()));
+        }
+
+        // CraftBukkit end
         this.clearCurrentTask();
     }
 
     protected void setResourcePackFromWorld(String worldNameIn, ISaveHandler saveHandlerIn)
     {
@@ -362,23 +544,26 @@
 
     protected void clearCurrentTask()
     {
         this.currentTask = null;
         this.percentDone = 0;
+        this.server.enablePlugins(PluginLoadOrder.POSTWORLD); // CraftBukkit
     }
 
-    protected void saveAllWorlds(boolean dontLog)
+    protected void saveAllWorlds(boolean dontLog) throws MinecraftException   // CraftBukkit - added throws
     {
         if (!this.worldIsBeingDeleted)
         {
             WorldServer[] aworldserver = this.worldServers;
             int i = aworldserver.length;
 
-            for (int j = 0; j < i; ++j)
+            // CraftBukkit start
+            for (int j = 0; j < worlds.size(); ++j)
             {
-                WorldServer worldserver = aworldserver[j];
+                WorldServer worldserver = worlds.get(j);
 
+                // CraftBukkit end
                 if (worldserver != null)
                 {
                     if (!dontLog)
                     {
                         logger.info("Saving chunks for level \'" + worldserver.getWorldInfo().getWorldName() + "\'/" + worldserver.provider.getDimensionName());
@@ -395,16 +580,37 @@
                 }
             }
         }
     }
 
-    public void stopServer()
+    // CraftBukkit start
+    private boolean hasStopped = false;
+    private final Object stopLock = new Object();
+    // CraftBukkit end
+
+    public void stopServer() throws MinecraftException   // CraftBukkit - added throws
     {
+        // CraftBukkit start - prevent double stopping on multiple threads
+        synchronized (stopLock)
+        {
+            if (hasStopped) return;
+
+            hasStopped = true;
+        }
+
+        // CraftBukkit end
         if (!this.worldIsBeingDeleted)
         {
             logger.info("Stopping server");
 
+            // CraftBukkit start
+            if (this.server != null)
+            {
+                this.server.disablePlugins();
+            }
+
+            // CraftBukkit end
             if (this.getNetworkSystem() != null)
             {
                 this.getNetworkSystem().terminateEndpoints();
             }
 
@@ -417,22 +623,31 @@
 
             if (this.worldServers != null)
             {
                 logger.info("Saving worlds");
                 this.saveAllWorlds(false);
-
-                for (int i = 0; i < this.worldServers.length; ++i)
-                {
+                /* CraftBukkit start - Handled in saveChunks
+                for (int i = 0; i < this.worldServers.length; ++i) {
                     WorldServer worldserver = this.worldServers[i];
                     worldserver.flush();
                 }
+                // CraftBukkit end */
             }
 
             if (this.usageSnooper.isSnooperRunning())
             {
                 this.usageSnooper.stopSnooper();
             }
+
+            // Spigot start
+            if (org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly)
+            {
+                logger.info("Saving usercache.json");
+                this.profileCache.func_152658_c();
+            }
+
+            //Spigot end
         }
     }
 
     public boolean isServerRunning()
     {
@@ -442,15 +657,16 @@
     public void initiateShutdown()
     {
         this.serverRunning = false;
     }
 
-    @SideOnly(Side.CLIENT)
-    protected void setInstance()
+    // Spigot Start
+    private static double calcTps(double avg, double exp, double tps)
     {
-        mcServer = this;
+        return (avg * exp) + (tps * (1 - exp));
     }
+    // Spigot End
 
     public void run()
     {
         try
         {
@@ -459,58 +675,62 @@
                 this.currentTime = getCurrentTimeMillis();
                 long i = 0L;
                 this.statusResponse.setServerDescription(new ChatComponentText(this.motd));
                 this.statusResponse.setProtocolVersionInfo(new ServerStatusResponse.MinecraftProtocolVersionIdentifier("1.8", 47));
                 this.addFaviconToStatusResponse(this.statusResponse);
+                // Spigot start
+                Arrays.fill(recentTps, 20);
+                long lastTick = System.nanoTime(), catchupTime = 0, curTime, wait, tickSection = lastTick;
 
                 while (this.serverRunning)
                 {
-                    long k = getCurrentTimeMillis();
-                    long j = k - this.currentTime;
+                    curTime = System.nanoTime();
+                    wait = TICK_TIME - (curTime - lastTick) - catchupTime;
 
-                    if (j > 2000L && this.currentTime - this.timeOfLastWarning >= 15000L)
+                    if (wait > 0)
                     {
-                        logger.warn("Can\'t keep up! Did the system time change, or is the server overloaded? Running {}ms behind, skipping {} tick(s)", new Object[] {Long.valueOf(j), Long.valueOf(j / 50L)});
-                        j = 2000L;
-                        this.timeOfLastWarning = this.currentTime;
+                        Thread.sleep(wait / 1000000);
+                        catchupTime = 0;
+                        continue;
                     }
-
-                    if (j < 0L)
+                    else
                     {
-                        logger.warn("Time ran backwards! Did the system time change?");
-                        j = 0L;
+                        catchupTime = Math.min(1000000000, Math.abs(wait));
                     }
 
-                    i += j;
-                    this.currentTime = k;
-
-                    if (this.worldServers[0].areAllPlayersAsleep())
+                    if (MinecraftServer.currentTick++ % SAMPLE_INTERVAL == 0)
                     {
-                        this.tick();
-                        i = 0L;
+                        double currentTps = 1E9 / (curTime - tickSection) * SAMPLE_INTERVAL;
+                        recentTps[0] = calcTps(recentTps[0], 0.92, currentTps); // 1/exp(5sec/1min)
+                        recentTps[1] = calcTps(recentTps[1], 0.9835, currentTps); // 1/exp(5sec/5min)
+                        recentTps[2] = calcTps(recentTps[2], 0.9945, currentTps); // 1/exp(5sec/15min)
+                        tickSection = curTime;
                     }
-                    else
-                    {
-                        while (i > 50L)
-                        {
-                            i -= 50L;
-                            this.tick();
-                        }
-                    }
 
-                    Thread.sleep(Math.max(1L, 50L - i));
+                    lastTick = curTime;
+                    this.tick();
                     this.serverIsRunning = true;
                 }
+
+                // Spigot end
             }
             else
             {
                 this.finalTick((CrashReport)null);
             }
         }
         catch (Throwable throwable1)
         {
             logger.error("Encountered an unexpected exception", throwable1);
+
+            // Spigot Start
+            if (throwable1.getCause() != null)
+            {
+                MinecraftServer.logger.error("\tCause of unexpected exception was", throwable1.getCause());
+            }
+
+            // Spigot End
             CrashReport crashreport = null;
 
             if (throwable1 instanceof ReportedException)
             {
                 crashreport = this.addServerInfoToCrashReport(((ReportedException)throwable1).getCrashReport());
@@ -535,19 +755,30 @@
         }
         finally
         {
             try
             {
+                WatchdogThread.doStop(); // Spigot
                 this.stopServer();
                 this.serverStopped = true;
             }
             catch (Throwable throwable)
             {
                 logger.error("Exception stopping the server", throwable);
             }
             finally
             {
+                // CraftBukkit start - Restore terminal to original settings
+                try
+                {
+                    reader.getTerminal().restore();
+                }
+                catch (Exception ignored)
+                {
+                }
+
+                // CraftBukkit end
                 this.systemExitNow();
             }
         }
     }
 
@@ -582,16 +813,21 @@
     public File getDataDirectory()
     {
         return new File(".");
     }
 
-    protected void finalTick(CrashReport report) {}
+    protected void finalTick(CrashReport report)
+    {
+    }
 
-    protected void systemExitNow() {}
+    protected void systemExitNow()
+    {
+    }
 
-    public void tick()
+    public void tick() throws MinecraftException   // CraftBukkit - added throws
     {
+        SpigotTimings.serverTickTimer.startTiming(); // Spigot
         long i = System.nanoTime();
         ++this.tickCounter;
 
         if (this.startProfiling)
         {
@@ -617,35 +853,53 @@
 
             Collections.shuffle(Arrays.asList(agameprofile));
             this.statusResponse.getPlayerCountData().setPlayers(agameprofile);
         }
 
-        if (this.tickCounter % 900 == 0)
+        if (autosavePeriod > 0 && this.tickCounter % autosavePeriod == 0)   // CraftBukkit
         {
+            SpigotTimings.worldSaveTimer.startTiming(); // Spigot
             this.theProfiler.startSection("save");
             this.serverConfigManager.saveAllPlayerData();
-            this.saveAllWorlds(true);
+            // Spigot Start
+            // We replace this with saving each individual world as this.saveChunks(...) is broken,
+            // and causes the main thread to sleep for random amounts of time depending on chunk activity
+            // Also pass flag to only save modified chunks
+            server.playerCommandState = true;
+
+            for (World world : worlds)
+            {
+                world.getWorld().save(false);
+            }
+
+            server.playerCommandState = false;
+            // this.saveAllWorlds(true);
+            // Spigot End
             this.theProfiler.endSection();
+            SpigotTimings.worldSaveTimer.stopTiming(); // Spigot
         }
 
         this.theProfiler.startSection("tallying");
         this.tickTimeArray[this.tickCounter % 100] = System.nanoTime() - i;
         this.theProfiler.endSection();
         this.theProfiler.startSection("snooper");
 
-        if (!this.usageSnooper.isSnooperRunning() && this.tickCounter > 100)
+        if (isSnooperEnabled() && !this.usageSnooper.isSnooperRunning() && this.tickCounter > 100)   // Spigot
         {
             this.usageSnooper.startSnooper();
         }
 
-        if (this.tickCounter % 6000 == 0)
+        if (isSnooperEnabled() && this.tickCounter % 6000 == 0)   // Spigot
         {
             this.usageSnooper.addMemoryStatsToSnooper();
         }
 
         this.theProfiler.endSection();
         this.theProfiler.endSection();
+        WatchdogThread.tick(); // Spigot
+        SpigotTimings.serverTickTimer.stopTiming(); // Spigot
+        CustomTimingsHandler.tick(); // Spigot
     }
 
     public void updateTimeLightAndEntities()
     {
         this.theProfiler.startSection("jobs");
@@ -655,96 +909,158 @@
         {
             while (!this.futureTaskQueue.isEmpty())
             {
                 try
                 {
-                    ((FutureTask)this.futureTaskQueue.poll()).run();
+                    // CraftBukkit start - log exceptions
+                    FutureTask task = ((FutureTask)this.futureTaskQueue.poll());
+                    task.run();
+                    task.get();
                 }
                 catch (Throwable throwable2)
                 {
-                    logger.fatal(throwable2);
+                    MinecraftServer.logger.fatal("Handling task", throwable2);
+                    // CraftBukkit end
                 }
             }
         }
 
         this.theProfiler.endStartSection("levels");
-        int j;
+        SpigotTimings.schedulerTimer.startTiming(); // Spigot
+        // CraftBukkit start
+        this.server.getScheduler().mainThreadHeartbeat(this.tickCounter);
+        SpigotTimings.schedulerTimer.stopTiming(); // Spigot
+        // Run tasks that are waiting on processing
+        SpigotTimings.processQueueTimer.startTiming(); // Spigot
 
-        for (j = 0; j < this.worldServers.length; ++j)
+        while (!processQueue.isEmpty())
         {
-            long i = System.nanoTime();
+            processQueue.remove().run();
+        }
 
-            if (j == 0 || this.getAllowNether())
+        SpigotTimings.processQueueTimer.stopTiming(); // Spigot
+        SpigotTimings.chunkIOTickTimer.startTiming(); // Spigot
+        org.bukkit.craftbukkit.chunkio.ChunkIOExecutor.tick();
+        SpigotTimings.chunkIOTickTimer.stopTiming(); // Spigot
+        SpigotTimings.timeUpdateTimer.startTiming(); // Spigot
+        // Send time updates to everyone, it will get the right time from the world the player is in.
+        if (this.tickCounter % 20 == 0)
+        {
+            for (int i = 0; i < this.getConfigurationManager().playerEntityList.size(); ++i)
             {
-                WorldServer worldserver = this.worldServers[j];
-                this.theProfiler.startSection(worldserver.getWorldInfo().getWorldName());
+                EntityPlayerMP entityplayer = (EntityPlayerMP)this.getConfigurationManager().playerEntityList.get(i);
+                entityplayer.playerNetServerHandler.sendPacket(new S03PacketTimeUpdate(entityplayer.worldObj.getTotalWorldTime(), entityplayer.getPlayerTime(), entityplayer.worldObj.getGameRules().getGameRuleBooleanValue("doDaylightCycle"))); // Add support for per player time
+            }
+        }
 
-                if (this.tickCounter % 20 == 0)
-                {
-                    this.theProfiler.startSection("timeSync");
-                    this.serverConfigManager.sendPacketToAllPlayersInDimension(new S03PacketTimeUpdate(worldserver.getTotalWorldTime(), worldserver.getWorldTime(), worldserver.getGameRules().getGameRuleBooleanValue("doDaylightCycle")), worldserver.provider.getDimensionId());
-                    this.theProfiler.endSection();
-                }
+        SpigotTimings.timeUpdateTimer.stopTiming(); // Spigot
+        int j;
 
-                this.theProfiler.startSection("tick");
-                CrashReport crashreport;
+        for (j = 0; j < this.worldServers.length; ++j)
+        {
+            long i = System.nanoTime();
+            // if (j == 0 || this.getAllowNether()) {
+            WorldServer worldserver = this.worldServers[j];
+            this.theProfiler.startSection(worldserver.getWorldInfo().getWorldName());
+            /* Drop global time updates
+            if (this.tickCounter % 20 == 0) {
+                this.theProfiler.startSection("timeSync");
+                this.serverConfigManager.sendPacketToAllPlayersInDimension(new S03PacketTimeUpdate(worldserver.getTotalWorldTime(), worldserver.getWorldTime(), worldserver.getGameRules().getGameRuleBooleanValue("doDaylightCycle")), worldserver.provider.getDimensionId());
+                this.theProfiler.endSection();
+            }
+            // CraftBukkit end */
+            this.theProfiler.startSection("tick");
+            CrashReport crashreport;
 
+            try
+            {
+                worldserver.timings.doTick.startTiming(); // Spigot
+                worldserver.tick();
+                worldserver.timings.doTick.stopTiming(); // Spigot
+            }
+            catch (Throwable throwable1)
+            {
+                // Spigot Start
                 try
                 {
-                    worldserver.tick();
+                    crashreport = CrashReport.makeCrashReport(throwable1, "Exception ticking world");
                 }
-                catch (Throwable throwable1)
+                catch (Throwable t)
                 {
-                    crashreport = CrashReport.makeCrashReport(throwable1, "Exception ticking world");
-                    worldserver.addWorldInfoToCrashReport(crashreport);
-                    throw new ReportedException(crashreport);
+                    throw new RuntimeException("Error generating crash report", t);
                 }
 
+                // Spigot End
+                worldserver.addWorldInfoToCrashReport(crashreport);
+                throw new ReportedException(crashreport);
+            }
+
+            try
+            {
+                worldserver.timings.tickEntities.startTiming(); // Spigot
+                worldserver.updateEntities();
+                worldserver.timings.tickEntities.stopTiming(); // Spigot
+            }
+            catch (Throwable throwable)
+            {
+                // Spigot Start
                 try
                 {
-                    worldserver.updateEntities();
+                    crashreport = CrashReport.makeCrashReport(throwable, "Exception ticking world entities");
                 }
-                catch (Throwable throwable)
+                catch (Throwable t)
                 {
-                    crashreport = CrashReport.makeCrashReport(throwable, "Exception ticking world entities");
-                    worldserver.addWorldInfoToCrashReport(crashreport);
-                    throw new ReportedException(crashreport);
+                    throw new RuntimeException("Error generating crash report", t);
                 }
 
-                this.theProfiler.endSection();
-                this.theProfiler.startSection("tracker");
-                worldserver.getEntityTracker().updateTrackedEntities();
-                this.theProfiler.endSection();
-                this.theProfiler.endSection();
+                // Spigot End
+                worldserver.addWorldInfoToCrashReport(crashreport);
+                throw new ReportedException(crashreport);
             }
 
-            this.timeOfLastDimensionTick[j][this.tickCounter % 100] = System.nanoTime() - i;
+            this.theProfiler.endSection();
+            this.theProfiler.startSection("tracker");
+            worldserver.timings.tracker.startTiming(); // Spigot
+            worldserver.getEntityTracker().updateTrackedEntities();
+            worldserver.timings.tracker.stopTiming(); // Spigot
+            this.theProfiler.endSection();
+            this.theProfiler.endSection();
+            // } // CraftBukkit
+            // this.timeOfLastDimensionTick[j][this.tickCounter % 100] = System.nanoTime() - i; // CraftBukkit
         }
 
         this.theProfiler.endStartSection("connection");
+        SpigotTimings.connectionTimer.startTiming(); // Spigot
         this.getNetworkSystem().networkTick();
+        SpigotTimings.connectionTimer.stopTiming(); // Spigot
         this.theProfiler.endStartSection("players");
+        SpigotTimings.playerListTimer.startTiming(); // Spigot
         this.serverConfigManager.onTick();
+        SpigotTimings.playerListTimer.stopTiming(); // Spigot
         this.theProfiler.endStartSection("tickables");
+        SpigotTimings.tickablesTimer.startTiming(); // Spigot
 
         for (j = 0; j < this.playersOnline.size(); ++j)
         {
             ((IUpdatePlayerListBox)this.playersOnline.get(j)).update();
         }
 
+        SpigotTimings.tickablesTimer.stopTiming(); // Spigot
         this.theProfiler.endSection();
     }
 
     public boolean getAllowNether()
     {
         return true;
     }
 
     public void startServerThread()
     {
+        /* CraftBukkit start - prevent abuse
         this.serverThread = new Thread(this, "Server thread");
         this.serverThread.start();
+        // CraftBukkit end */
     }
 
     public File getFile(String fileName)
     {
         return new File(this.getDataDirectory(), fileName);
@@ -755,11 +1071,21 @@
         logger.warn(msg);
     }
 
     public WorldServer worldServerForDimension(int dimension)
     {
-        return dimension == -1 ? this.worldServers[1] : (dimension == 1 ? this.worldServers[2] : this.worldServers[0]);
+        // CraftBukkit start
+        for (WorldServer world : worlds)
+        {
+            if (world.dimension == dimension)
+            {
+                return world;
+            }
+        }
+
+        return worlds.get(0);
+        // CraftBukkit end
     }
 
     public String getMinecraftVersion()
     {
         return "1.8";
@@ -785,11 +1111,11 @@
         return this.serverConfigManager.getAllProfiles();
     }
 
     public String getServerModName()
     {
-        return "vanilla";
+        return "SpigotMCP"; //SpigotMCP - SpigotMCP -> // Spigot - Spigot > // CraftBukkit - cb > vanilla
     }
 
     public CrashReport addServerInfoToCrashReport(CrashReport report)
     {
         report.getCategory().addCrashSectionCallable("Profiler Position", new Callable()
@@ -816,68 +1142,62 @@
         return report;
     }
 
     public List getTabCompletions(ICommandSender sender, String input, BlockPos pos)
     {
+        /* CraftBukkit start - Allow tab-completion of Bukkit commands
         ArrayList arraylist = Lists.newArrayList();
 
-        if (input.startsWith("/"))
-        {
+        if (input.startsWith("/")) {
             input = input.substring(1);
             boolean flag = !input.contains(" ");
             List list = this.commandManager.getTabCompletionOptions(sender, input, pos);
 
-            if (list != null)
-            {
+            if (list != null) {
                 Iterator iterator = list.iterator();
 
-                while (iterator.hasNext())
-                {
-                    String s3 = (String)iterator.next();
+                while (iterator.hasNext()) {
+                    String s3 = (String) iterator.next();
 
-                    if (flag)
-                    {
+                    if (flag) {
                         arraylist.add("/" + s3);
-                    }
-                    else
-                    {
+                    } else {
                         arraylist.add(s3);
                     }
                 }
             }
 
             return arraylist;
-        }
-        else
-        {
+        } else {
             String[] astring = input.split(" ", -1);
             String s1 = astring[astring.length - 1];
             String[] astring1 = this.serverConfigManager.getAllUsernames();
             int i = astring1.length;
 
-            for (int j = 0; j < i; ++j)
-            {
+            for (int j = 0; j < i; ++j) {
                 String s2 = astring1[j];
 
-                if (CommandBase.doesStringStartWith(s1, s2))
-                {
+                if (CommandBase.doesStringStartWith(s1, s2)) {
                     arraylist.add(s2);
                 }
             }
 
             return arraylist;
         }
+        */
+        return server.tabComplete(sender, input);
+        // CraftBukkit end
     }
 
     public static MinecraftServer getServer()
     {
         return mcServer;
     }
 
     public boolean func_175578_N()
     {
-        return this.anvilFile != null;
+        return true; // CraftBukkit
     }
 
     public String getName()
     {
         return "Server";
@@ -926,32 +1246,22 @@
     public void setFolderName(String name)
     {
         this.folderName = name;
     }
 
-    @SideOnly(Side.CLIENT)
-    public void setWorldName(String p_71246_1_)
-    {
-        this.worldName = p_71246_1_;
-    }
-
-    @SideOnly(Side.CLIENT)
-    public String getWorldName()
-    {
-        return this.worldName;
-    }
-
     public void setKeyPair(KeyPair keyPair)
     {
         this.serverKeyPair = keyPair;
     }
 
     public void setDifficultyForAllWorlds(EnumDifficulty difficulty)
     {
-        for (int i = 0; i < this.worldServers.length; ++i)
+        // CraftBukkit start
+        for (int i = 0; i < this.worlds.size(); ++i)
         {
-            WorldServer worldserver = this.worldServers[i];
+            WorldServer worldserver = this.worlds.get(i);
+            // CraftBukkit end
 
             if (worldserver != null)
             {
                 if (worldserver.getWorldInfo().isHardcoreModeEnabled())
                 {
@@ -1000,21 +1310,23 @@
     public void deleteWorldAndStopServer()
     {
         this.worldIsBeingDeleted = true;
         this.getActiveAnvilConverter().flushCache();
 
-        for (int i = 0; i < this.worldServers.length; ++i)
+        // CraftBukkit start
+        for (int i = 0; i < this.worlds.size(); ++i)
         {
-            WorldServer worldserver = this.worldServers[i];
+            WorldServer worldserver = this.worlds.get(i);
+            // CraftBukkit end
 
             if (worldserver != null)
             {
                 worldserver.flush();
             }
         }
 
-        this.getActiveAnvilConverter().deleteWorldDirectory(this.worldServers[0].getSaveHandler().getWorldDirectoryName());
+        this.getActiveAnvilConverter().deleteWorldDirectory(this.worlds.get(0).getSaveHandler().getWorldDirectoryName()); // CraftBukkit
         this.initiateShutdown();
     }
 
     public String getResourcePackUrl()
     {
@@ -1050,15 +1362,18 @@
         playerSnooper.addClientStat("avg_tick_ms", Integer.valueOf((int)(MathHelper.average(this.tickTimeArray) * 1.0E-6D)));
         int i = 0;
 
         if (this.worldServers != null)
         {
-            for (int j = 0; j < this.worldServers.length; ++j)
+            // CraftBukkit start
+            for (int j = 0; j < this.worlds.size(); ++j)
             {
-                if (this.worldServers[j] != null)
+                WorldServer worldserver = this.worlds.get(j);
+
+                if (worldserver != null)
                 {
-                    WorldServer worldserver = this.worldServers[j];
+                    // CraftBukkit end
                     WorldInfo worldinfo = worldserver.getWorldInfo();
                     playerSnooper.addClientStat("world[" + i + "][dimension]", Integer.valueOf(worldserver.provider.getDimensionId()));
                     playerSnooper.addClientStat("world[" + i + "][mode]", worldinfo.getGameType());
                     playerSnooper.addClientStat("world[" + i + "][difficulty]", worldserver.getDifficulty());
                     playerSnooper.addClientStat("world[" + i + "][hardcore]", Boolean.valueOf(worldinfo.isHardcoreModeEnabled()));
@@ -1089,11 +1404,11 @@
 
     public abstract boolean isDedicatedServer();
 
     public boolean isServerInOnlineMode()
     {
-        return this.onlineMode;
+        return server.getOnlineMode(); // CraftBukkit
     }
 
     public void setOnlineMode(boolean online)
     {
         this.onlineMode = online;
@@ -1171,25 +1486,29 @@
         this.serverConfigManager = configManager;
     }
 
     public void setGameType(WorldSettings.GameType gameMode)
     {
-        for (int i = 0; i < this.worldServers.length; ++i)
+        // CraftBukkit start
+        for (int i = 0; i < this.worlds.size(); ++i)
         {
-            getServer().worldServers[i].getWorldInfo().setGameType(gameMode);
+            getServer().worlds.get(i).getWorldInfo().setGameType(gameMode);
+            // CraftBukkit end
         }
     }
 
-    public NetworkSystem getNetworkSystem()
+
+    // Spigot Start
+    public NetworkSystem getServerConnection()
     {
         return this.networkSystem;
     }
+    // Spigot End
 
-    @SideOnly(Side.CLIENT)
-    public boolean serverIsInRunLoop()
+    public NetworkSystem getNetworkSystem()
     {
-        return this.serverIsRunning;
+        return this.networkSystem == null ? this.networkSystem = new NetworkSystem(this) : this.networkSystem; // Spigot
     }
 
     public boolean getGuiEnabled()
     {
         return false;
@@ -1205,16 +1524,10 @@
     public void enableProfiling()
     {
         this.startProfiling = true;
     }
 
-    @SideOnly(Side.CLIENT)
-    public PlayerUsageSnooper getPlayerUsageSnooper()
-    {
-        return this.usageSnooper;
-    }
-
     public BlockPos getPosition()
     {
         return BlockPos.ORIGIN;
     }
 
@@ -1223,11 +1536,11 @@
         return new Vec3(0.0D, 0.0D, 0.0D);
     }
 
     public World getEntityWorld()
     {
-        return this.worldServers[0];
+        return this.worlds.get(0); // CraftBukkit
     }
 
     public Entity getCommandSenderEntity()
     {
         return null;
@@ -1303,16 +1616,15 @@
         this.nanoTimeSinceStatusRefresh = 0L;
     }
 
     public Entity getEntityFromUuid(UUID uuid)
     {
-        WorldServer[] aworldserver = this.worldServers;
-        int i = aworldserver.length;
-
-        for (int j = 0; j < i; ++j)
+        // CraftBukkit start
+        for (int j = 0; j < worlds.size(); ++j)
         {
-            WorldServer worldserver = aworldserver[j];
+            WorldServer worldserver = worlds.get(j);
+            // CraftBukkit end
 
             if (worldserver != null)
             {
                 Entity entity = worldserver.getEntityFromUuid(uuid);
 
@@ -1326,14 +1638,16 @@
         return null;
     }
 
     public boolean sendCommandFeedback()
     {
-        return getServer().worldServers[0].getGameRules().getGameRuleBooleanValue("sendCommandFeedback");
+        return getServer().worlds.get(0).getGameRules().getGameRuleBooleanValue("sendCommandFeedback"); // CraftBukkit
     }
 
-    public void setCommandStat(CommandResultStats.Type type, int amount) {}
+    public void setCommandStat(CommandResultStats.Type type, int amount)
+    {
+    }
 
     public int getMaxWorldSize()
     {
         return 29999984;
     }
@@ -1380,237 +1694,297 @@
     public int getNetworkCompressionTreshold()
     {
         return 256;
     }
 
-    @SideOnly(Side.SERVER)
+
     public String getServerHostname()
     {
         return this.hostname;
     }
 
-    @SideOnly(Side.SERVER)
+
     public void setHostname(String host)
     {
         this.hostname = host;
     }
 
-    @SideOnly(Side.SERVER)
+
     public void registerTickable(IUpdatePlayerListBox tickable)
     {
         this.playersOnline.add(tickable);
     }
 
-    @SideOnly(Side.SERVER)
-    public static void main(String[] p_main_0_)
+
+    public static void main(final OptionSet options)   // CraftBukkit - replaces main(String[] astring)
     {
         Bootstrap.register();
 
         try
         {
+            // CraftBukkit start - Replace everything
+            /*
             boolean flag = true;
             String s = null;
             String s1 = ".";
             String s2 = null;
             boolean flag1 = false;
             boolean flag2 = false;
             int i = -1;
 
-            for (int j = 0; j < p_main_0_.length; ++j)
-            {
+            for (int j = 0; j < p_main_0_.length; ++j) {
                 String s3 = p_main_0_[j];
                 String s4 = j == p_main_0_.length - 1 ? null : p_main_0_[j + 1];
                 boolean flag3 = false;
 
-                if (!s3.equals("nogui") && !s3.equals("--nogui"))
-                {
-                    if (s3.equals("--port") && s4 != null)
-                    {
+                if (!s3.equals("nogui") && !s3.equals("--nogui")) {
+                    if (s3.equals("--port") && s4 != null) {
                         flag3 = true;
 
-                        try
-                        {
+                        try {
                             i = Integer.parseInt(s4);
-                        }
-                        catch (NumberFormatException numberformatexception)
-                        {
+                        } catch (NumberFormatException numberformatexception) {
                             ;
                         }
-                    }
-                    else if (s3.equals("--singleplayer") && s4 != null)
-                    {
+                    } else if (s3.equals("--singleplayer") && s4 != null) {
                         flag3 = true;
                         s = s4;
-                    }
-                    else if (s3.equals("--universe") && s4 != null)
-                    {
+                    } else if (s3.equals("--universe") && s4 != null) {
                         flag3 = true;
                         s1 = s4;
-                    }
-                    else if (s3.equals("--world") && s4 != null)
-                    {
+                    } else if (s3.equals("--world") && s4 != null) {
                         flag3 = true;
                         s2 = s4;
-                    }
-                    else if (s3.equals("--demo"))
-                    {
+                    } else if (s3.equals("--demo")) {
                         flag1 = true;
-                    }
-                    else if (s3.equals("--bonusChest"))
-                    {
+                    } else if (s3.equals("--bonusChest")) {
                         flag2 = true;
                     }
-                }
-                else
-                {
+                } else {
                     flag = false;
                 }
 
-                if (flag3)
-                {
+                if (flag3) {
                     ++j;
                 }
             }
 
             final DedicatedServer dedicatedserver = new DedicatedServer(new File(s1));
 
-            if (s != null)
-            {
+            if (s != null) {
                 dedicatedserver.setServerOwner(s);
             }
 
-            if (s2 != null)
-            {
+            if (s2 != null) {
                 dedicatedserver.setFolderName(s2);
             }
 
-            if (i >= 0)
-            {
+            if (i >= 0) {
                 dedicatedserver.setServerPort(i);
             }
 
-            if (flag1)
-            {
+            if (flag1) {
                 dedicatedserver.setDemo(true);
             }
 
-            if (flag2)
-            {
+            if (flag2) {
                 dedicatedserver.canCreateBonusChest(true);
             }
 
-            if (flag && !GraphicsEnvironment.isHeadless())
-            {
+            if (flag && !GraphicsEnvironment.isHeadless()) {
                 dedicatedserver.setGuiEnabled();
             }
 
             dedicatedserver.startServerThread();
-            Runtime.getRuntime().addShutdownHook(new Thread("Server Shutdown Thread")
-            {
+            Runtime.getRuntime().addShutdownHook(new Thread("Server Shutdown Thread") {
+
                 private static final String __OBFID = "CL_00001806";
-                public void run()
-                {
+
+                public void run() {
                     dedicatedserver.stopServer();
                 }
             });
+            */
+            DedicatedServer dedicatedserver = new DedicatedServer(options);
+
+            if (options.has("port"))
+            {
+                int port = (Integer)options.valueOf("port");
+
+                if (port > 0)
+                {
+                    dedicatedserver.setServerPort(port);
+                }
+            }
+
+            if (options.has("universe"))
+            {
+                dedicatedserver.anvilFile = (File)options.valueOf("universe");
+            }
+
+            if (options.has("world"))
+            {
+                dedicatedserver.setFolderName((String)options.valueOf("world"));
+            }
+
+            dedicatedserver.primaryThread.start();
+            // CraftBukkit end
         }
         catch (Exception exception)
         {
             logger.fatal("Failed to start the minecraft server", exception);
         }
     }
 
-    @SideOnly(Side.SERVER)
+
     public void logInfo(String msg)
     {
         logger.info(msg);
     }
 
-    @SideOnly(Side.SERVER)
+
     public String getHostname()
     {
         return this.hostname;
     }
 
-    @SideOnly(Side.SERVER)
+
     public int getPort()
     {
         return this.serverPort;
     }
 
-    @SideOnly(Side.SERVER)
+
     public String getMotd()
     {
         return this.motd;
     }
 
-    @SideOnly(Side.SERVER)
+
     public String getPlugins()
     {
-        return "";
+        // CraftBukkit start - Whole method
+        StringBuilder result = new StringBuilder();
+        Plugin[] plugins = server.getPluginManager().getPlugins();
+        result.append(server.getName());
+        result.append(" on Bukkit ");
+        result.append(server.getBukkitVersion());
+
+        if (plugins.length > 0 && server.getQueryPlugins())
+        {
+            result.append(": ");
+
+            for (int i = 0; i < plugins.length; i++)
+            {
+                if (i > 0)
+                {
+                    result.append("; ");
+                }
+
+                result.append(plugins[i].getDescription().getName());
+                result.append(" ");
+                result.append(plugins[i].getDescription().getVersion().replaceAll(";", ","));
+            }
+        }
+
+        return result.toString();
+        // CraftBukkit end
     }
 
-    @SideOnly(Side.SERVER)
-    public String handleRConCommand(String command)
+    // CraftBukkit start - fire RemoteServerCommandEvent
+
+    public String handleRConCommand(final String command)
     {
-        RConConsoleSource.getInstance().resetLog();
-        this.commandManager.executeCommand(RConConsoleSource.getInstance(), command);
-        return RConConsoleSource.getInstance().getLogContents();
+        // CraftBukkit start - fire RemoteServerCommandEvent
+        Waitable<String> waitable = new Waitable<String>()
+        {
+            @Override
+            protected String evaluate()
+            {
+                RConConsoleSource.getInstance().resetLog();
+                // this.commandManager.executeCommand(RConConsoleSource.getInstance(), command);
+                return RConConsoleSource.getInstance().getLogContents();
+            }
+        };
+        processQueue.add(waitable);
+
+        try
+        {
+            return waitable.get();
+        }
+        catch (ExecutionException e)
+        {
+            throw new RuntimeException("Exception processing rcon command " + command, e.getCause());
+        }
+        catch (InterruptedException e)
+        {
+            Thread.currentThread().interrupt(); // Maintain interrupted state
+            throw new RuntimeException("Interrupted processing rcon command " + command, e);
+        }
+
+        // CraftBukkit end
     }
 
-    @SideOnly(Side.SERVER)
+
     public boolean isDebuggingEnabled()
     {
-        return false;
+        return this.getPropertyManager().getBooleanProperty("debug", false); // CraftBukkit - don't hardcode
     }
 
-    @SideOnly(Side.SERVER)
+
     public void logSevere(String msg)
     {
         logger.error(msg);
     }
 
-    @SideOnly(Side.SERVER)
+
     public void logDebug(String msg)
     {
         if (this.isDebuggingEnabled())
         {
             logger.info(msg);
         }
     }
 
-    @SideOnly(Side.SERVER)
+
     public int getServerPort()
     {
         return this.serverPort;
     }
 
-    @SideOnly(Side.SERVER)
+
     public void setServerPort(int port)
     {
         this.serverPort = port;
     }
 
-    @SideOnly(Side.SERVER)
+
     public boolean isServerStopped()
     {
         return this.serverStopped;
     }
 
-    @SideOnly(Side.SERVER)
+
     public void setForceGamemode(boolean force)
     {
         this.isGamemodeForced = force;
     }
 
-    @SideOnly(Side.SERVER)
+
     public long getCurrentTime()
     {
         return this.currentTime;
     }
 
-    @SideOnly(Side.SERVER)
+
     public Thread getServerThread()
     {
         return this.serverThread;
     }
+
+    // SpigotMCP -- Add Method
+    public static Logger getLogger()
+    {
+        return logger;
+    }
+    // SpigotMCP End
 }
