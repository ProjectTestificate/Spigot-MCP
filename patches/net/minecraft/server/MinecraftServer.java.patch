--- decompiled\net\minecraft\server\MinecraftServer.java
+++ src\main\java\net\minecraft\server\MinecraftServer.java
@@ -1,42 +1,30 @@
 package net.minecraft.server;
 
-import com.google.common.base.Charsets;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.ListenableFutureTask;
-import com.mojang.authlib.GameProfile;
-import com.mojang.authlib.GameProfileRepository;
-import com.mojang.authlib.minecraft.MinecraftSessionService;
-import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufOutputStream;
-import io.netty.buffer.Unpooled;
-import io.netty.handler.codec.base64.Base64;
-import java.awt.GraphicsEnvironment;
+import java.awt.*;
 import java.awt.image.BufferedImage;
 import java.io.File;
 import java.io.IOException;
 import java.net.Proxy;
 import java.security.KeyPair;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Queue;
 import java.util.Random;
 import java.util.UUID;
 import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
+
 import javax.imageio.ImageIO;
-import net.minecraft.command.CommandBase;
+
 import net.minecraft.command.CommandResultStats;
 import net.minecraft.command.ICommandManager;
 import net.minecraft.command.ICommandSender;
 import net.minecraft.command.ServerCommandManager;
 import net.minecraft.crash.CrashReport;
@@ -69,36 +57,70 @@
 import net.minecraft.world.WorldManager;
 import net.minecraft.world.WorldServer;
 import net.minecraft.world.WorldServerMulti;
 import net.minecraft.world.WorldSettings;
 import net.minecraft.world.WorldType;
-import net.minecraft.world.chunk.storage.AnvilSaveConverter;
+import net.minecraft.world.chunk.storage.AnvilSaveHandler;
 import net.minecraft.world.demo.DemoWorldServer;
 import net.minecraft.world.storage.ISaveFormat;
 import net.minecraft.world.storage.ISaveHandler;
 import net.minecraft.world.storage.WorldInfo;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
+
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.World.Environment;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.command.RemoteConsoleCommandSender;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.Main;
+import org.bukkit.craftbukkit.SpigotTimings;
+import org.bukkit.craftbukkit.scoreboard.CraftScoreboardManager;
+import org.bukkit.craftbukkit.util.ServerShutdownThread;
+import org.bukkit.craftbukkit.util.Waitable;
+import org.bukkit.event.world.WorldInitEvent;
+import org.bukkit.event.world.WorldLoadEvent;
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.PluginLoadOrder;
+import org.spigotmc.CustomTimingsHandler;
+import org.spigotmc.WatchdogThread;
 
-public abstract class MinecraftServer implements ICommandSender, Runnable, IThreadListener, IPlayerUsage
-{
+import com.google.common.base.Charsets;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.ListenableFutureTask;
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import com.mojang.authlib.minecraft.MinecraftSessionService;
+import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufOutputStream;
+import io.netty.buffer.Unpooled;
+import io.netty.handler.codec.base64.Base64;
+
+import jline.console.ConsoleReader;
+import joptsimple.OptionSet;
+
+public abstract class MinecraftServer implements ICommandSender, Runnable, IThreadListener, IPlayerUsage {
+
     private static final Logger logger = LogManager.getLogger();
     public static final File USER_CACHE_FILE = new File("usercache.json");
     private static MinecraftServer mcServer;
-    private final ISaveFormat anvilConverterForAnvilFile;
+    public ISaveFormat anvilConverterForAnvilFile; // SpigotMCP -- Apply access transformation
     private final PlayerUsageSnooper usageSnooper = new PlayerUsageSnooper("server", this, getCurrentTimeMillis());
-    private final File anvilFile;
+    public File anvilFile; // SpigotMCP -- Apply access transformation
     private final List playersOnline = Lists.newArrayList();
     private final ICommandManager commandManager;
     public final Profiler theProfiler = new Profiler();
-    private final NetworkSystem networkSystem;
+    private NetworkSystem networkSystem; // Spigot
     private final ServerStatusResponse statusResponse = new ServerStatusResponse();
     private final Random random = new Random();
-    @SideOnly(Side.SERVER)
+
     private String hostname;
     private int serverPort = -1;
     public WorldServer[] worldServers;
     private ServerConfigurationManager serverConfigManager;
     private boolean serverRunning = true;
@@ -118,12 +140,10 @@
     public final long[] tickTimeArray = new long[100];
     public long[][] timeOfLastDimensionTick;
     private KeyPair serverKeyPair;
     private String serverOwner;
     private String folderName;
-    @SideOnly(Side.CLIENT)
-    private String worldName;
     private boolean isDemo;
     private boolean enableBonusChest;
     private boolean worldIsBeingDeleted;
     private String resourcePackUrl = "";
     private String resourcePackHash = "";
@@ -140,207 +160,303 @@
     protected final Queue futureTaskQueue = Queues.newArrayDeque();
     private Thread serverThread;
     private long currentTime = getCurrentTimeMillis();
     private static final String __OBFID = "CL_00001462";
 
-    @SideOnly(Side.CLIENT)
-    public MinecraftServer(Proxy proxy, File workDir)
-    {
-        this.serverProxy = proxy;
-        mcServer = this;
-        this.anvilFile = null;
-        this.networkSystem = null;
-        this.profileCache = new PlayerProfileCache(this, workDir);
-        this.commandManager = null;
-        this.anvilConverterForAnvilFile = null;
-        this.authService = new YggdrasilAuthenticationService(proxy, UUID.randomUUID().toString());
-        this.sessionService = this.authService.createMinecraftSessionService();
-        this.profileRepo = this.authService.createProfileRepository();
-    }
+    // CraftBukkit start
+    public List<WorldServer> worlds = new ArrayList<WorldServer>();
+    public CraftServer server;
+    public OptionSet options;
+    public ConsoleCommandSender console;
+    public RemoteConsoleCommandSender remoteConsole;
+    public ConsoleReader reader;
+    public static int currentTick = (int) (System.currentTimeMillis() / 50);
+    public final Thread primaryThread;
+    public Queue<Runnable> processQueue = new ConcurrentLinkedQueue<Runnable>();
+    public int autosavePeriod;
+    // CraftBukkit end
+    // Spigot start
+    private static final int TPS = 20;
+    private static final int TICK_TIME = 1000000000 / TPS;
+    private static final int SAMPLE_INTERVAL = 100;
+    public final double[] recentTps = new double[3];
+    // Spigot end
 
-    public MinecraftServer(File workDir, Proxy proxy, File profileCacheDir)
-    {
+    public MinecraftServer(OptionSet options, Proxy proxy, File profileCacheDir) {
+        io.netty.util.ResourceLeakDetector.setEnabled(false); // Spigot - disable
         this.serverProxy = proxy;
         mcServer = this;
-        this.anvilFile = workDir;
-        this.networkSystem = new NetworkSystem(this);
+        // this.anvilFile = workDir; // CraftBukkit
+        // this.networkSystem = new NetworkSystem(this); // Spigot
         this.profileCache = new PlayerProfileCache(this, profileCacheDir);
         this.commandManager = this.createNewCommandManager();
-        this.anvilConverterForAnvilFile = new AnvilSaveConverter(workDir);
+        // this.anvilConverterForAnvilFile = new AnvilSaveConverter(workDir); // CraftBukkit - moved to DedicatedServer.init
         this.authService = new YggdrasilAuthenticationService(proxy, UUID.randomUUID().toString());
         this.sessionService = this.authService.createMinecraftSessionService();
         this.profileRepo = this.authService.createProfileRepository();
+        // CraftBukkit start
+        this.options = options;
+        // Try to see if we're actually running in a terminal, disable jline if not
+        if (System.console() == null) {
+            System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
+            Main.useJline = false;
+        }
+
+        try {
+            reader = new ConsoleReader(System.in, System.out);
+            reader.setExpandEvents(false); // Avoid parsing exceptions for uncommonly used event designators
+        } catch (Throwable e) {
+            try {
+                // Try again with jline disabled for Windows users without C++ 2008 Redistributable
+                System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
+                System.setProperty("user.language", "en");
+                Main.useJline = false;
+                reader = new ConsoleReader(System.in, System.out);
+                reader.setExpandEvents(false);
+            } catch (IOException ex) {
+                logger.warn((String) null, ex);
+            }
+        }
+        Runtime.getRuntime().addShutdownHook(new ServerShutdownThread(this));
+
+        this.serverThread = primaryThread = new Thread(this, "Server thread"); // Moved from main
     }
 
-    protected ServerCommandManager createNewCommandManager()
-    {
+    public abstract net.minecraft.server.dedicated.PropertyManager getPropertyManager();
+    // CraftBukkit end
+
+    protected ServerCommandManager createNewCommandManager() {
         return new ServerCommandManager();
     }
 
-    protected abstract boolean startServer() throws IOException;
+    protected abstract boolean startServer() throws IOException; // CraftBukkit - throws UnknownHostException // SpigotMCP NOTE -- MCP added supperclass
 
-    protected void convertMapIfNeeded(String worldNameIn)
-    {
-        if (this.getActiveAnvilConverter().isOldMapFormat(worldNameIn))
-        {
+    // SpigotMCP Start -- Convert to regualar inner class
+    public class ConvertProgressUpdater implements IProgressUpdate {
+
+        private long startTime = System.currentTimeMillis();
+        private static final String __OBFID = "CL_00001417";
+
+        public void displaySavingString(String message) {
+        }
+
+        public void setLoadingProgress(int progress) {
+            if (System.currentTimeMillis() - this.startTime >= 1000L) {
+                this.startTime = System.currentTimeMillis();
+                MinecraftServer.logger.info("Converting... " + progress + "%");
+            }
+        }
+
+        public void displayLoadingString(String message) {
+        }
+    }
+    // SpigotMCP End
+
+    protected void convertMapIfNeeded(String worldNameIn) {
+        if (this.getActiveAnvilConverter().isOldMapFormat(worldNameIn)) {
             logger.info("Converting map!");
             this.setUserMessage("menu.convertingLevel");
-            this.getActiveAnvilConverter().convertMapFormat(worldNameIn, new IProgressUpdate()
-            {
-                private long startTime = System.currentTimeMillis();
-                private static final String __OBFID = "CL_00001417";
-                public void displaySavingString(String message) {}
-                public void setLoadingProgress(int progress)
-                {
-                    if (System.currentTimeMillis() - this.startTime >= 1000L)
-                    {
-                        this.startTime = System.currentTimeMillis();
-                        MinecraftServer.logger.info("Converting... " + progress + "%");
-                    }
-                }
-                @SideOnly(Side.CLIENT)
-                public void resetProgressAndMessage(String p_73721_1_) {}
-                @SideOnly(Side.CLIENT)
-                public void setDoneWorking() {}
-                public void displayLoadingString(String message) {}
-            });
+            this.getActiveAnvilConverter().convertMapFormat(worldNameIn, new ConvertProgressUpdater()); // SpigotMCP -- Convert to regualar inner class
         }
     }
 
-    protected synchronized void setUserMessage(String message)
-    {
+    protected synchronized void setUserMessage(String message) {
         this.userMessage = message;
     }
 
-    @SideOnly(Side.CLIENT)
-
-    public synchronized String getUserMessage()
-    {
+    public synchronized String getUserMessage() {
         return this.userMessage;
     }
 
-    protected void loadAllWorlds(String p_71247_1_, String p_71247_2_, long seed, WorldType type, String p_71247_6_)
-    {
+    protected void loadAllWorlds(String p_71247_1_, String p_71247_2_, long seed, WorldType type, String p_71247_6_) {
         this.convertMapIfNeeded(p_71247_1_);
         this.setUserMessage("menu.loadingLevel");
         this.worldServers = new WorldServer[3];
+        // CraftBukkit start - Remove ticktime arrays and worldsettings
+        /*
         this.timeOfLastDimensionTick = new long[this.worldServers.length][100];
         ISaveHandler isavehandler = this.anvilConverterForAnvilFile.getSaveLoader(p_71247_1_, true);
         this.setResourcePackFromWorld(this.getFolderName(), isavehandler);
         WorldInfo worldinfo = isavehandler.loadWorldInfo();
         WorldSettings worldsettings;
 
-        if (worldinfo == null)
-        {
-            if (this.isDemo())
-            {
+        if (worldinfo == null) {
+            if (this.isDemo()) {
                 worldsettings = DemoWorldServer.demoWorldSettings;
-            }
-            else
-            {
+            } else {
                 worldsettings = new WorldSettings(seed, this.getGameType(), this.canStructuresSpawn(), this.isHardcore(), type);
                 worldsettings.setWorldName(p_71247_6_);
 
-                if (this.enableBonusChest)
-                {
+                if (this.enableBonusChest) {
                     worldsettings.enableBonusChest();
                 }
             }
 
             worldinfo = new WorldInfo(worldsettings, p_71247_2_);
-        }
-        else
-        {
+        } else {
             worldinfo.setWorldName(p_71247_2_);
             worldsettings = new WorldSettings(worldinfo);
         }
+        */
+        int worldCount = 3;
 
-        for (int j = 0; j < this.worldServers.length; ++j)
-        {
-            byte b0 = 0;
+        for (int j = 0; j < worldCount; ++j) {
+            WorldServer world;
+            byte dimension = 0;
 
-            if (j == 1)
-            {
-                b0 = -1;
+            if (j == 1) {
+                if (getAllowNether()) {
+                    dimension = -1;
+                } else {
+                    continue;
+                }
             }
 
-            if (j == 2)
-            {
-                b0 = 1;
+            if (j == 2) {
+                if (server.getAllowEnd()) {
+                    dimension = 1;
+                } else {
+                    continue;
+                }
             }
 
-            if (j == 0)
-            {
-                if (this.isDemo())
-                {
-                    this.worldServers[j] = (WorldServer)(new DemoWorldServer(this, isavehandler, worldinfo, b0, this.theProfiler)).init();
+            String worldType = Environment.getEnvironment(dimension).toString().toLowerCase();
+            String name = (dimension == 0) ? p_71247_1_ : p_71247_1_ + "_" + worldType;
+
+            ChunkGenerator gen = this.server.getGenerator(name);
+            WorldSettings worldsettings = new WorldSettings(seed, this.getGameType(), this.canStructuresSpawn(), this.isHardcore(), type);
+            worldsettings.setWorldName(p_71247_6_);
+
+            if (j == 0) {
+                ISaveHandler idatamanager = new AnvilSaveHandler(server.getWorldContainer(), p_71247_2_, true);
+                WorldInfo worlddata = idatamanager.loadWorldInfo();
+                if (worlddata == null) {
+                    worlddata = new WorldInfo(worldsettings, p_71247_2_);
                 }
-                else
-                {
-                    this.worldServers[j] = (WorldServer)(new WorldServer(this, isavehandler, worldinfo, b0, this.theProfiler)).init();
+                worlddata.checkName(p_71247_2_); // CraftBukkit - Migration did not rewrite the level.dat; This forces 1.8 to take the last loaded world as respawn (in this case the end)
+                if (this.isDemo()) {
+                    world = (WorldServer) (new DemoWorldServer(this, idatamanager, worlddata, dimension, this.theProfiler, Environment.getEnvironment(dimension), gen)).init(); // SpigotMCP -- Add extra args
+                } else {
+                    world = (WorldServer) (new WorldServer(this, idatamanager, worlddata, dimension, this.theProfiler, Environment.getEnvironment(dimension), gen)).init();
                 }
 
-                this.worldServers[j].initialize(worldsettings);
+                world.initialize(worldsettings);
+                this.server.scoreboardManager = new CraftScoreboardManager(this, world.getScoreboard());
+            } else {
+                String dim = "DIM" + dimension;
+
+                File newWorld = new File(new File(name), dim);
+                File oldWorld = new File(new File(p_71247_1_), dim);
+
+                if ((!newWorld.isDirectory()) && (oldWorld.isDirectory())) {
+                    MinecraftServer.logger.info("---- Migration of old " + worldType + " folder required ----");
+                    MinecraftServer.logger.info("Unfortunately due to the way that Minecraft implemented multiworld support in 1.6, Bukkit requires that you move your " + worldType + " folder to a new location in order to operate correctly.");
+                    MinecraftServer.logger.info("We will move this folder for you, but it will mean that you need to move it back should you wish to stop using Bukkit in the future.");
+                    MinecraftServer.logger.info("Attempting to move " + oldWorld + " to " + newWorld + "...");
+
+                    if (newWorld.exists()) {
+                        MinecraftServer.logger.warn("A file or folder already exists at " + newWorld + "!");
+                        MinecraftServer.logger.info("---- Migration of old " + worldType + " folder failed ----");
+                    } else if (newWorld.getParentFile().mkdirs()) {
+                        if (oldWorld.renameTo(newWorld)) {
+                            MinecraftServer.logger.info("Success! To restore " + worldType + " in the future, simply move " + newWorld + " to " + oldWorld);
+                            // Migrate world data too.
+                            try {
+                                com.google.common.io.Files.copy(new File(new File(p_71247_1_), "level.dat"), new File(new File(name), "level.dat"));
+                            } catch (IOException exception) {
+                                MinecraftServer.logger.warn("Unable to migrate world data.");
+                            }
+                            MinecraftServer.logger.info("---- Migration of old " + worldType + " folder complete ----");
+                        } else {
+                            MinecraftServer.logger.warn("Could not move folder " + oldWorld + " to " + newWorld + "!");
+                            MinecraftServer.logger.info("---- Migration of old " + worldType + " folder failed ----");
+                        }
+                    } else {
+                        MinecraftServer.logger.warn("Could not create path for " + newWorld + "!");
+                        MinecraftServer.logger.info("---- Migration of old " + worldType + " folder failed ----");
+                    }
+                }
+
+                ISaveHandler idatamanager = new AnvilSaveHandler(server.getWorldContainer(), name, true);
+                // world =, b0 to dimension, s1 to name, added Environment and gen
+                WorldInfo worlddata = idatamanager.loadWorldInfo();
+                if (worlddata == null) {
+                    worlddata = new WorldInfo(worldsettings, name);
+                }
+                worlddata.checkName(name); // CraftBukkit - Migration did not rewrite the level.dat; This forces 1.8 to take the last loaded world as respawn (in this case the end)
+                world = (WorldServer) new WorldServerMulti(this, idatamanager, dimension, this.worlds.get(0), this.theProfiler, worlddata, org.bukkit.World.Environment.getEnvironment(dimension), gen).init();
             }
-            else
-            {
-                this.worldServers[j] = (WorldServer)(new WorldServerMulti(this, isavehandler, b0, this.worldServers[0], this.theProfiler)).init();
+
+            if (gen != null) {
+                world.getWorld().getPopulators().addAll(gen.getDefaultPopulators(world.getWorld()));
             }
 
-            this.worldServers[j].addWorldAccess(new WorldManager(this, this.worldServers[j]));
+            this.server.getPluginManager().callEvent(new WorldInitEvent(world.getWorld()));
 
-            if (!this.isSinglePlayer())
-            {
-                this.worldServers[j].getWorldInfo().setGameType(this.getGameType());
+            world.addWorldAccess(new WorldManager(this, world));
+            if (!this.isSinglePlayer()) {
+                world.getWorldInfo().setGameType(this.getGameType());
             }
+
+            worlds.add(world);
+            getConfigurationManager().setPlayerManager(worlds.toArray(new WorldServer[worlds.size()]));
         }
 
-        this.serverConfigManager.setPlayerManager(this.worldServers);
+        // CraftBukkit end
         this.setDifficultyForAllWorlds(this.getDifficulty());
         this.initialWorldChunkLoad();
     }
 
-    protected void initialWorldChunkLoad()
-    {
+    protected void initialWorldChunkLoad() {
         boolean flag = true;
         boolean flag1 = true;
         boolean flag2 = true;
         boolean flag3 = true;
         int i = 0;
         this.setUserMessage("menu.generatingTerrain");
         byte b0 = 0;
-        logger.info("Preparing start region for level " + b0);
-        WorldServer worldserver = this.worldServers[b0];
-        BlockPos blockpos = worldserver.getSpawnPoint();
-        long j = getCurrentTimeMillis();
 
-        for (int k = -192; k <= 192 && this.isServerRunning(); k += 16)
-        {
-            for (int l = -192; l <= 192 && this.isServerRunning(); l += 16)
-            {
-                long i1 = getCurrentTimeMillis();
+        // CraftBukkit start - fire WorldLoadEvent and handle whether or not to keep the spawn in memory
+        for (int m = 0; m < worlds.size(); m++) {
+            WorldServer worldserver = this.worlds.get(m);
+            logger.info("Preparing start region for level " + m + " (Seed: " + worldserver.getSeed() + ")");
 
-                if (i1 - j > 1000L)
-                {
-                    this.outputPercentRemaining("Preparing spawn area", i * 100 / 625);
-                    j = i1;
-                }
+            if (!worldserver.getWorld().getKeepSpawnInMemory()) {
+                continue;
+            }
 
-                ++i;
-                worldserver.theChunkProviderServer.loadChunk(blockpos.getX() + k >> 4, blockpos.getZ() + l >> 4);
+            BlockPos blockposition = worldserver.getSpawnPoint();
+            long j = getCurrentTimeMillis();
+            i = 0;
+
+            for (int k = -192; k <= 192 && this.isServerRunning(); k += 16) {
+                for (int l = -192; l <= 192 && this.isServerRunning(); l += 16) {
+                    long i1 = getCurrentTimeMillis();
+
+                    if (i1 - j > 1000L) {
+                        this.outputPercentRemaining("Preparing spawn area", i * 100 / 625);
+                        j = i1;
+                    }
+
+                    ++i;
+                    worldserver.theChunkProviderServer.loadChunk(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                }
             }
         }
 
+        for (WorldServer world : this.worlds) {
+            this.server.getPluginManager().callEvent(new WorldLoadEvent(world.getWorld()));
+        }
+        // CraftBukkit end
+
         this.clearCurrentTask();
     }
 
-    protected void setResourcePackFromWorld(String worldNameIn, ISaveHandler saveHandlerIn)
-    {
+    protected void setResourcePackFromWorld(String worldNameIn, ISaveHandler saveHandlerIn) {
         File file1 = new File(saveHandlerIn.getWorldDirectory(), "resources.zip");
 
-        if (file1.isFile())
-        {
+        if (file1.isFile()) {
             this.setResourcePack("level://" + worldNameIn + "/" + file1.getName(), "");
         }
     }
 
     public abstract boolean canStructuresSpawn();
@@ -351,715 +467,693 @@
 
     public abstract boolean isHardcore();
 
     public abstract int getOpPermissionLevel();
 
-    protected void outputPercentRemaining(String message, int percent)
-    {
+    protected void outputPercentRemaining(String message, int percent) {
         this.currentTask = message;
         this.percentDone = percent;
         logger.info(message + ": " + percent + "%");
     }
 
-    protected void clearCurrentTask()
-    {
+    protected void clearCurrentTask() {
         this.currentTask = null;
         this.percentDone = 0;
+
+        this.server.enablePlugins(PluginLoadOrder.POSTWORLD); // CraftBukkit
     }
 
-    protected void saveAllWorlds(boolean dontLog)
-    {
-        if (!this.worldIsBeingDeleted)
-        {
+    protected void saveAllWorlds(boolean dontLog) throws MinecraftException { // CraftBukkit - added throws
+        if (!this.worldIsBeingDeleted) {
             WorldServer[] aworldserver = this.worldServers;
             int i = aworldserver.length;
 
-            for (int j = 0; j < i; ++j)
-            {
-                WorldServer worldserver = aworldserver[j];
-
-                if (worldserver != null)
-                {
-                    if (!dontLog)
-                    {
+            // CraftBukkit start
+            for (int j = 0; j < worlds.size(); ++j) {
+                WorldServer worldserver = worlds.get(j);
+                // CraftBukkit end
+                if (worldserver != null) {
+                    if (!dontLog) {
                         logger.info("Saving chunks for level \'" + worldserver.getWorldInfo().getWorldName() + "\'/" + worldserver.provider.getDimensionName());
                     }
 
-                    try
-                    {
-                        worldserver.saveAllChunks(true, (IProgressUpdate)null);
-                    }
-                    catch (MinecraftException minecraftexception)
-                    {
+                    try {
+                        worldserver.saveAllChunks(true, (IProgressUpdate) null);
+                    } catch (MinecraftException minecraftexception) {
                         logger.warn(minecraftexception.getMessage());
                     }
                 }
             }
         }
     }
 
-    public void stopServer()
-    {
-        if (!this.worldIsBeingDeleted)
-        {
-            logger.info("Stopping server");
+    // CraftBukkit start
+    private boolean hasStopped = false;
+    private final Object stopLock = new Object();
+    // CraftBukkit end
 
-            if (this.getNetworkSystem() != null)
-            {
+    public void stopServer() throws MinecraftException { // CraftBukkit - added throws
+        // CraftBukkit start - prevent double stopping on multiple threads
+        synchronized (stopLock) {
+            if (hasStopped) return;
+            hasStopped = true;
+        }
+        // CraftBukkit end
+        if (!this.worldIsBeingDeleted) {
+            logger.info("Stopping server");
+            // CraftBukkit start
+            if (this.server != null) {
+                this.server.disablePlugins();
+            }
+            // CraftBukkit end
+            if (this.getNetworkSystem() != null) {
                 this.getNetworkSystem().terminateEndpoints();
             }
 
-            if (this.serverConfigManager != null)
-            {
+            if (this.serverConfigManager != null) {
                 logger.info("Saving players");
                 this.serverConfigManager.saveAllPlayerData();
                 this.serverConfigManager.removeAllPlayers();
             }
 
-            if (this.worldServers != null)
-            {
+            if (this.worldServers != null) {
                 logger.info("Saving worlds");
                 this.saveAllWorlds(false);
 
-                for (int i = 0; i < this.worldServers.length; ++i)
-                {
+                /* CraftBukkit start - Handled in saveChunks
+                for (int i = 0; i < this.worldServers.length; ++i) {
                     WorldServer worldserver = this.worldServers[i];
                     worldserver.flush();
                 }
+                // CraftBukkit end */
             }
 
-            if (this.usageSnooper.isSnooperRunning())
-            {
+            if (this.usageSnooper.isSnooperRunning()) {
                 this.usageSnooper.stopSnooper();
             }
+            // Spigot start
+            if (org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly) {
+                logger.info("Saving usercache.json");
+                this.profileCache.func_152658_c();
+            }
+            //Spigot end
         }
     }
 
-    public boolean isServerRunning()
-    {
+    public boolean isServerRunning() {
         return this.serverRunning;
     }
 
-    public void initiateShutdown()
-    {
+    public void initiateShutdown() {
         this.serverRunning = false;
     }
 
-    @SideOnly(Side.CLIENT)
-    protected void setInstance()
-    {
-        mcServer = this;
+    // Spigot Start
+    private static double calcTps(double avg, double exp, double tps) {
+        return (avg * exp) + (tps * (1 - exp));
     }
+    // Spigot End
 
-    public void run()
-    {
-        try
-        {
-            if (this.startServer())
-            {
+    public void run() {
+        try {
+            if (this.startServer()) {
                 this.currentTime = getCurrentTimeMillis();
                 long i = 0L;
                 this.statusResponse.setServerDescription(new ChatComponentText(this.motd));
                 this.statusResponse.setProtocolVersionInfo(new ServerStatusResponse.MinecraftProtocolVersionIdentifier("1.8", 47));
                 this.addFaviconToStatusResponse(this.statusResponse);
 
-                while (this.serverRunning)
-                {
-                    long k = getCurrentTimeMillis();
-                    long j = k - this.currentTime;
-
-                    if (j > 2000L && this.currentTime - this.timeOfLastWarning >= 15000L)
-                    {
-                        logger.warn("Can\'t keep up! Did the system time change, or is the server overloaded? Running {}ms behind, skipping {} tick(s)", new Object[] {Long.valueOf(j), Long.valueOf(j / 50L)});
-                        j = 2000L;
-                        this.timeOfLastWarning = this.currentTime;
+                // Spigot start
+                Arrays.fill(recentTps, 20);
+                long lastTick = System.nanoTime(), catchupTime = 0, curTime, wait, tickSection = lastTick;
+                while (this.serverRunning) {
+                    curTime = System.nanoTime();
+                    wait = TICK_TIME - (curTime - lastTick) - catchupTime;
+                    if (wait > 0) {
+                        Thread.sleep(wait / 1000000);
+                        catchupTime = 0;
+                        continue;
+                    } else {
+                        catchupTime = Math.min(1000000000, Math.abs(wait));
                     }
 
-                    if (j < 0L)
-                    {
-                        logger.warn("Time ran backwards! Did the system time change?");
-                        j = 0L;
+                    if (MinecraftServer.currentTick++ % SAMPLE_INTERVAL == 0) {
+                        double currentTps = 1E9 / (curTime - tickSection) * SAMPLE_INTERVAL;
+                        recentTps[0] = calcTps(recentTps[0], 0.92, currentTps); // 1/exp(5sec/1min)
+                        recentTps[1] = calcTps(recentTps[1], 0.9835, currentTps); // 1/exp(5sec/5min)
+                        recentTps[2] = calcTps(recentTps[2], 0.9945, currentTps); // 1/exp(5sec/15min)
+                        tickSection = curTime;
                     }
+                    lastTick = curTime;
 
-                    i += j;
-                    this.currentTime = k;
-
-                    if (this.worldServers[0].areAllPlayersAsleep())
-                    {
-                        this.tick();
-                        i = 0L;
-                    }
-                    else
-                    {
-                        while (i > 50L)
-                        {
-                            i -= 50L;
-                            this.tick();
-                        }
-                    }
-
-                    Thread.sleep(Math.max(1L, 50L - i));
+                    this.tick();
                     this.serverIsRunning = true;
                 }
+                // Spigot end
+            } else {
+                this.finalTick((CrashReport) null);
             }
-            else
-            {
-                this.finalTick((CrashReport)null);
-            }
-        }
-        catch (Throwable throwable1)
-        {
+        } catch (Throwable throwable1) {
             logger.error("Encountered an unexpected exception", throwable1);
+            // Spigot Start
+            if (throwable1.getCause() != null) {
+                MinecraftServer.logger.error("\tCause of unexpected exception was", throwable1.getCause());
+            }
+            // Spigot End
             CrashReport crashreport = null;
 
-            if (throwable1 instanceof ReportedException)
-            {
-                crashreport = this.addServerInfoToCrashReport(((ReportedException)throwable1).getCrashReport());
-            }
-            else
-            {
+            if (throwable1 instanceof ReportedException) {
+                crashreport = this.addServerInfoToCrashReport(((ReportedException) throwable1).getCrashReport());
+            } else {
                 crashreport = this.addServerInfoToCrashReport(new CrashReport("Exception in server tick loop", throwable1));
             }
 
             File file1 = new File(new File(this.getDataDirectory(), "crash-reports"), "crash-" + (new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss")).format(new Date()) + "-server.txt");
 
-            if (crashreport.saveToFile(file1))
-            {
+            if (crashreport.saveToFile(file1)) {
                 logger.error("This crash report has been saved to: " + file1.getAbsolutePath());
-            }
-            else
-            {
+            } else {
                 logger.error("We were unable to save this crash report to disk.");
             }
 
             this.finalTick(crashreport);
-        }
-        finally
-        {
-            try
-            {
+        } finally {
+            try {
+                WatchdogThread.doStop(); // Spigot
                 this.stopServer();
                 this.serverStopped = true;
-            }
-            catch (Throwable throwable)
-            {
+            } catch (Throwable throwable) {
                 logger.error("Exception stopping the server", throwable);
-            }
-            finally
-            {
+            } finally {
+                // CraftBukkit start - Restore terminal to original settings
+                try {
+                    reader.getTerminal().restore();
+                } catch (Exception ignored) {
+                }
+                // CraftBukkit end
                 this.systemExitNow();
             }
         }
     }
 
-    private void addFaviconToStatusResponse(ServerStatusResponse response)
-    {
+    private void addFaviconToStatusResponse(ServerStatusResponse response) {
         File file1 = this.getFile("server-icon.png");
 
-        if (file1.isFile())
-        {
+        if (file1.isFile()) {
             ByteBuf bytebuf = Unpooled.buffer();
 
-            try
-            {
+            try {
                 BufferedImage bufferedimage = ImageIO.read(file1);
                 Validate.validState(bufferedimage.getWidth() == 64, "Must be 64 pixels wide", new Object[0]);
                 Validate.validState(bufferedimage.getHeight() == 64, "Must be 64 pixels high", new Object[0]);
                 ImageIO.write(bufferedimage, "PNG", new ByteBufOutputStream(bytebuf));
                 ByteBuf bytebuf1 = Base64.encode(bytebuf);
                 response.setFavicon("data:image/png;base64," + bytebuf1.toString(Charsets.UTF_8));
-            }
-            catch (Exception exception)
-            {
+            } catch (Exception exception) {
                 logger.error("Couldn\'t load server icon", exception);
-            }
-            finally
-            {
+            } finally {
                 bytebuf.release();
             }
         }
     }
 
-    public File getDataDirectory()
-    {
+    public File getDataDirectory() {
         return new File(".");
     }
 
-    protected void finalTick(CrashReport report) {}
+    protected void finalTick(CrashReport report) {
+    }
 
-    protected void systemExitNow() {}
+    protected void systemExitNow() {
+    }
 
-    public void tick()
-    {
+    public void tick() throws MinecraftException { // CraftBukkit - added throws
+        SpigotTimings.serverTickTimer.startTiming(); // Spigot
         long i = System.nanoTime();
         ++this.tickCounter;
 
-        if (this.startProfiling)
-        {
+        if (this.startProfiling) {
             this.startProfiling = false;
             this.theProfiler.profilingEnabled = true;
             this.theProfiler.clearProfiling();
         }
 
         this.theProfiler.startSection("root");
         this.updateTimeLightAndEntities();
 
-        if (i - this.nanoTimeSinceStatusRefresh >= 5000000000L)
-        {
+        if (i - this.nanoTimeSinceStatusRefresh >= 5000000000L) {
             this.nanoTimeSinceStatusRefresh = i;
             this.statusResponse.setPlayerCountData(new ServerStatusResponse.PlayerCountData(this.getMaxPlayers(), this.getCurrentPlayerCount()));
             GameProfile[] agameprofile = new GameProfile[Math.min(this.getCurrentPlayerCount(), 12)];
             int j = MathHelper.getRandomIntegerInRange(this.random, 0, this.getCurrentPlayerCount() - agameprofile.length);
 
-            for (int k = 0; k < agameprofile.length; ++k)
-            {
-                agameprofile[k] = ((EntityPlayerMP)this.serverConfigManager.playerEntityList.get(j + k)).getGameProfile();
+            for (int k = 0; k < agameprofile.length; ++k) {
+                agameprofile[k] = ((EntityPlayerMP) this.serverConfigManager.playerEntityList.get(j + k)).getGameProfile();
             }
 
             Collections.shuffle(Arrays.asList(agameprofile));
             this.statusResponse.getPlayerCountData().setPlayers(agameprofile);
         }
 
-        if (this.tickCounter % 900 == 0)
-        {
+        if (autosavePeriod > 0 && this.tickCounter % autosavePeriod == 0) { // CraftBukkit
+            SpigotTimings.worldSaveTimer.startTiming(); // Spigot
             this.theProfiler.startSection("save");
             this.serverConfigManager.saveAllPlayerData();
-            this.saveAllWorlds(true);
+            // Spigot Start
+            // We replace this with saving each individual world as this.saveChunks(...) is broken,
+            // and causes the main thread to sleep for random amounts of time depending on chunk activity
+            // Also pass flag to only save modified chunks
+            server.playerCommandState = true;
+            for (World world : worlds) {
+                world.getWorld().save(false);
+            }
+            server.playerCommandState = false;
+            // this.saveAllWorlds(true);
+            // Spigot End
             this.theProfiler.endSection();
+            SpigotTimings.worldSaveTimer.stopTiming(); // Spigot
         }
 
         this.theProfiler.startSection("tallying");
         this.tickTimeArray[this.tickCounter % 100] = System.nanoTime() - i;
         this.theProfiler.endSection();
         this.theProfiler.startSection("snooper");
 
-        if (!this.usageSnooper.isSnooperRunning() && this.tickCounter > 100)
-        {
+        if (isSnooperEnabled() && !this.usageSnooper.isSnooperRunning() && this.tickCounter > 100) { // Spigot
             this.usageSnooper.startSnooper();
         }
 
-        if (this.tickCounter % 6000 == 0)
-        {
+        if (isSnooperEnabled() && this.tickCounter % 6000 == 0) { // Spigot
             this.usageSnooper.addMemoryStatsToSnooper();
         }
 
         this.theProfiler.endSection();
         this.theProfiler.endSection();
+        WatchdogThread.tick(); // Spigot
+        SpigotTimings.serverTickTimer.stopTiming(); // Spigot
+        CustomTimingsHandler.tick(); // Spigot
     }
 
-    public void updateTimeLightAndEntities()
-    {
+    public void updateTimeLightAndEntities() {
         this.theProfiler.startSection("jobs");
         Queue queue = this.futureTaskQueue;
 
-        synchronized (this.futureTaskQueue)
-        {
-            while (!this.futureTaskQueue.isEmpty())
-            {
-                try
-                {
-                    ((FutureTask)this.futureTaskQueue.poll()).run();
+        synchronized (this.futureTaskQueue) {
+            while (!this.futureTaskQueue.isEmpty()) {
+                try {
+                    // CraftBukkit start - log exceptions
+                    FutureTask task = ((FutureTask) this.futureTaskQueue.poll());
+                    task.run();
+                    task.get();
+                } catch (Throwable throwable2) {
+                    MinecraftServer.logger.fatal("Handling task", throwable2);
+                    // CraftBukkit end
                 }
-                catch (Throwable throwable2)
-                {
-                    logger.fatal(throwable2);
-                }
             }
         }
 
         this.theProfiler.endStartSection("levels");
+
+        SpigotTimings.schedulerTimer.startTiming(); // Spigot
+        // CraftBukkit start
+        this.server.getScheduler().mainThreadHeartbeat(this.tickCounter);
+        SpigotTimings.schedulerTimer.stopTiming(); // Spigot
+
+        // Run tasks that are waiting on processing
+        SpigotTimings.processQueueTimer.startTiming(); // Spigot
+        while (!processQueue.isEmpty()) {
+            processQueue.remove().run();
+        }
+        SpigotTimings.processQueueTimer.stopTiming(); // Spigot
+
+        SpigotTimings.chunkIOTickTimer.startTiming(); // Spigot
+        org.bukkit.craftbukkit.chunkio.ChunkIOExecutor.tick();
+        SpigotTimings.chunkIOTickTimer.stopTiming(); // Spigot
+
+        SpigotTimings.timeUpdateTimer.startTiming(); // Spigot
+        // Send time updates to everyone, it will get the right time from the world the player is in.
+        if (this.tickCounter % 20 == 0) {
+            for (int i = 0; i < this.getConfigurationManager().playerEntityList.size(); ++i) {
+                EntityPlayerMP entityplayer = (EntityPlayerMP) this.getConfigurationManager().playerEntityList.get(i);
+                entityplayer.playerNetServerHandler.sendPacket(new S03PacketTimeUpdate(entityplayer.worldObj.getTotalWorldTime(), entityplayer.getPlayerTime(), entityplayer.worldObj.getGameRules().getGameRuleBooleanValue("doDaylightCycle"))); // Add support for per player time
+            }
+        }
+        SpigotTimings.timeUpdateTimer.stopTiming(); // Spigot
+
         int j;
 
-        for (j = 0; j < this.worldServers.length; ++j)
-        {
+        for (j = 0; j < this.worldServers.length; ++j) {
             long i = System.nanoTime();
 
-            if (j == 0 || this.getAllowNether())
-            {
-                WorldServer worldserver = this.worldServers[j];
-                this.theProfiler.startSection(worldserver.getWorldInfo().getWorldName());
-
-                if (this.tickCounter % 20 == 0)
-                {
+            // if (j == 0 || this.getAllowNether()) {
+            WorldServer worldserver = this.worldServers[j];
+            this.theProfiler.startSection(worldserver.getWorldInfo().getWorldName());
+                /* Drop global time updates
+                if (this.tickCounter % 20 == 0) {
                     this.theProfiler.startSection("timeSync");
                     this.serverConfigManager.sendPacketToAllPlayersInDimension(new S03PacketTimeUpdate(worldserver.getTotalWorldTime(), worldserver.getWorldTime(), worldserver.getGameRules().getGameRuleBooleanValue("doDaylightCycle")), worldserver.provider.getDimensionId());
                     this.theProfiler.endSection();
                 }
+                // CraftBukkit end */
 
-                this.theProfiler.startSection("tick");
-                CrashReport crashreport;
+            this.theProfiler.startSection("tick");
+            CrashReport crashreport;
 
-                try
-                {
-                    worldserver.tick();
-                }
-                catch (Throwable throwable1)
-                {
+            try {
+                worldserver.timings.doTick.startTiming(); // Spigot
+                worldserver.tick();
+                worldserver.timings.doTick.stopTiming(); // Spigot
+            } catch (Throwable throwable1) {
+                // Spigot Start
+                try {
                     crashreport = CrashReport.makeCrashReport(throwable1, "Exception ticking world");
-                    worldserver.addWorldInfoToCrashReport(crashreport);
-                    throw new ReportedException(crashreport);
+                } catch (Throwable t) {
+                    throw new RuntimeException("Error generating crash report", t);
                 }
+                // Spigot End
+                worldserver.addWorldInfoToCrashReport(crashreport);
+                throw new ReportedException(crashreport);
+            }
 
-                try
-                {
-                    worldserver.updateEntities();
-                }
-                catch (Throwable throwable)
-                {
+            try {
+                worldserver.timings.tickEntities.startTiming(); // Spigot
+                worldserver.updateEntities();
+                worldserver.timings.tickEntities.stopTiming(); // Spigot
+            } catch (Throwable throwable) {
+                // Spigot Start
+                try {
                     crashreport = CrashReport.makeCrashReport(throwable, "Exception ticking world entities");
-                    worldserver.addWorldInfoToCrashReport(crashreport);
-                    throw new ReportedException(crashreport);
+                } catch (Throwable t) {
+                    throw new RuntimeException("Error generating crash report", t);
                 }
-
-                this.theProfiler.endSection();
-                this.theProfiler.startSection("tracker");
-                worldserver.getEntityTracker().updateTrackedEntities();
-                this.theProfiler.endSection();
-                this.theProfiler.endSection();
+                // Spigot End
+                worldserver.addWorldInfoToCrashReport(crashreport);
+                throw new ReportedException(crashreport);
             }
 
-            this.timeOfLastDimensionTick[j][this.tickCounter % 100] = System.nanoTime() - i;
+            this.theProfiler.endSection();
+            this.theProfiler.startSection("tracker");
+            worldserver.timings.tracker.startTiming(); // Spigot
+            worldserver.getEntityTracker().updateTrackedEntities();
+            worldserver.timings.tracker.stopTiming(); // Spigot
+            this.theProfiler.endSection();
+            this.theProfiler.endSection();
+            // } // CraftBukkit
+
+            // this.timeOfLastDimensionTick[j][this.tickCounter % 100] = System.nanoTime() - i; // CraftBukkit
         }
 
         this.theProfiler.endStartSection("connection");
+        SpigotTimings.connectionTimer.startTiming(); // Spigot
         this.getNetworkSystem().networkTick();
+        SpigotTimings.connectionTimer.stopTiming(); // Spigot
         this.theProfiler.endStartSection("players");
+        SpigotTimings.playerListTimer.startTiming(); // Spigot
         this.serverConfigManager.onTick();
+        SpigotTimings.playerListTimer.stopTiming(); // Spigot
         this.theProfiler.endStartSection("tickables");
 
-        for (j = 0; j < this.playersOnline.size(); ++j)
-        {
-            ((IUpdatePlayerListBox)this.playersOnline.get(j)).update();
+        SpigotTimings.tickablesTimer.startTiming(); // Spigot
+        for (j = 0; j < this.playersOnline.size(); ++j) {
+            ((IUpdatePlayerListBox) this.playersOnline.get(j)).update();
         }
+        SpigotTimings.tickablesTimer.stopTiming(); // Spigot
 
         this.theProfiler.endSection();
     }
 
-    public boolean getAllowNether()
-    {
+    public boolean getAllowNether() {
         return true;
     }
 
-    public void startServerThread()
-    {
+    public void startServerThread() {
+        /* CraftBukkit start - prevent abuse
         this.serverThread = new Thread(this, "Server thread");
         this.serverThread.start();
+        // CraftBukkit end */
     }
 
-    public File getFile(String fileName)
-    {
+    public File getFile(String fileName) {
         return new File(this.getDataDirectory(), fileName);
     }
 
-    public void logWarning(String msg)
-    {
+    public void logWarning(String msg) {
         logger.warn(msg);
     }
 
-    public WorldServer worldServerForDimension(int dimension)
-    {
-        return dimension == -1 ? this.worldServers[1] : (dimension == 1 ? this.worldServers[2] : this.worldServers[0]);
+    public WorldServer worldServerForDimension(int dimension) {
+        // CraftBukkit start
+        for (WorldServer world : worlds) {
+            if (world.dimension == dimension) {
+                return world;
+            }
+        }
+        return worlds.get(0);
+        // CraftBukkit end
     }
 
-    public String getMinecraftVersion()
-    {
+    public String getMinecraftVersion() {
         return "1.8";
     }
 
-    public int getCurrentPlayerCount()
-    {
+    public int getCurrentPlayerCount() {
         return this.serverConfigManager.getCurrentPlayerCount();
     }
 
-    public int getMaxPlayers()
-    {
+    public int getMaxPlayers() {
         return this.serverConfigManager.getMaxPlayers();
     }
 
-    public String[] getAllUsernames()
-    {
+    public String[] getAllUsernames() {
         return this.serverConfigManager.getAllUsernames();
     }
 
-    public GameProfile[] getGameProfiles()
-    {
+    public GameProfile[] getGameProfiles() {
         return this.serverConfigManager.getAllProfiles();
     }
 
-    public String getServerModName()
-    {
-        return "vanilla";
+    public String getServerModName() {
+        return "SpigotMCP"; //SpigotMCP - SpigotMCP -> // Spigot - Spigot > // CraftBukkit - cb > vanilla
     }
 
-    public CrashReport addServerInfoToCrashReport(CrashReport report)
-    {
-        report.getCategory().addCrashSectionCallable("Profiler Position", new Callable()
-        {
+    public CrashReport addServerInfoToCrashReport(CrashReport report) {
+        report.getCategory().addCrashSectionCallable("Profiler Position", new Callable() {
+
             private static final String __OBFID = "CL_00001418";
-            public String call()
-            {
+
+            public String call() {
                 return MinecraftServer.this.theProfiler.profilingEnabled ? MinecraftServer.this.theProfiler.getNameOfLastSection() : "N/A (disabled)";
             }
         });
 
-        if (this.serverConfigManager != null)
-        {
-            report.getCategory().addCrashSectionCallable("Player Count", new Callable()
-            {
+        if (this.serverConfigManager != null) {
+            report.getCategory().addCrashSectionCallable("Player Count", new Callable() {
+
                 private static final String __OBFID = "CL_00001419";
-                public String call()
-                {
+
+                public String call() {
                     return MinecraftServer.this.serverConfigManager.getCurrentPlayerCount() + " / " + MinecraftServer.this.serverConfigManager.getMaxPlayers() + "; " + MinecraftServer.this.serverConfigManager.playerEntityList;
                 }
             });
         }
 
         return report;
     }
 
-    public List getTabCompletions(ICommandSender sender, String input, BlockPos pos)
-    {
+    public List getTabCompletions(ICommandSender sender, String input, BlockPos pos) {
+        /* CraftBukkit start - Allow tab-completion of Bukkit commands
         ArrayList arraylist = Lists.newArrayList();
 
-        if (input.startsWith("/"))
-        {
+        if (input.startsWith("/")) {
             input = input.substring(1);
             boolean flag = !input.contains(" ");
             List list = this.commandManager.getTabCompletionOptions(sender, input, pos);
 
-            if (list != null)
-            {
+            if (list != null) {
                 Iterator iterator = list.iterator();
 
-                while (iterator.hasNext())
-                {
-                    String s3 = (String)iterator.next();
+                while (iterator.hasNext()) {
+                    String s3 = (String) iterator.next();
 
-                    if (flag)
-                    {
+                    if (flag) {
                         arraylist.add("/" + s3);
-                    }
-                    else
-                    {
+                    } else {
                         arraylist.add(s3);
                     }
                 }
             }
 
             return arraylist;
-        }
-        else
-        {
+        } else {
             String[] astring = input.split(" ", -1);
             String s1 = astring[astring.length - 1];
             String[] astring1 = this.serverConfigManager.getAllUsernames();
             int i = astring1.length;
 
-            for (int j = 0; j < i; ++j)
-            {
+            for (int j = 0; j < i; ++j) {
                 String s2 = astring1[j];
 
-                if (CommandBase.doesStringStartWith(s1, s2))
-                {
+                if (CommandBase.doesStringStartWith(s1, s2)) {
                     arraylist.add(s2);
                 }
             }
 
             return arraylist;
         }
+        */
+        return server.tabComplete(sender, input);
+        // CraftBukkit end
     }
 
-    public static MinecraftServer getServer()
-    {
+    public static MinecraftServer getServer() {
         return mcServer;
     }
 
-    public boolean func_175578_N()
-    {
-        return this.anvilFile != null;
+    public boolean func_175578_N() {
+        return true; // CraftBukkit
     }
 
-    public String getName()
-    {
+    public String getName() {
         return "Server";
     }
 
-    public void addChatMessage(IChatComponent message)
-    {
+    public void addChatMessage(IChatComponent message) {
         logger.info(message.getUnformattedText());
     }
 
-    public boolean canUseCommand(int permLevel, String commandName)
-    {
+    public boolean canUseCommand(int permLevel, String commandName) {
         return true;
     }
 
-    public ICommandManager getCommandManager()
-    {
+    public ICommandManager getCommandManager() {
         return this.commandManager;
     }
 
-    public KeyPair getKeyPair()
-    {
+    public KeyPair getKeyPair() {
         return this.serverKeyPair;
     }
 
-    public String getServerOwner()
-    {
+    public String getServerOwner() {
         return this.serverOwner;
     }
 
-    public void setServerOwner(String owner)
-    {
+    public void setServerOwner(String owner) {
         this.serverOwner = owner;
     }
 
-    public boolean isSinglePlayer()
-    {
+    public boolean isSinglePlayer() {
         return this.serverOwner != null;
     }
 
-    public String getFolderName()
-    {
+    public String getFolderName() {
         return this.folderName;
     }
 
-    public void setFolderName(String name)
-    {
+    public void setFolderName(String name) {
         this.folderName = name;
     }
 
-    @SideOnly(Side.CLIENT)
-    public void setWorldName(String p_71246_1_)
-    {
-        this.worldName = p_71246_1_;
-    }
-
-    @SideOnly(Side.CLIENT)
-    public String getWorldName()
-    {
-        return this.worldName;
-    }
-
-    public void setKeyPair(KeyPair keyPair)
-    {
+    public void setKeyPair(KeyPair keyPair) {
         this.serverKeyPair = keyPair;
     }
 
-    public void setDifficultyForAllWorlds(EnumDifficulty difficulty)
-    {
-        for (int i = 0; i < this.worldServers.length; ++i)
-        {
-            WorldServer worldserver = this.worldServers[i];
+    public void setDifficultyForAllWorlds(EnumDifficulty difficulty) {
+        // CraftBukkit start
+        for (int i = 0; i < this.worlds.size(); ++i) {
+            WorldServer worldserver = this.worlds.get(i);
+            // CraftBukkit end
 
-            if (worldserver != null)
-            {
-                if (worldserver.getWorldInfo().isHardcoreModeEnabled())
-                {
+            if (worldserver != null) {
+                if (worldserver.getWorldInfo().isHardcoreModeEnabled()) {
                     worldserver.getWorldInfo().setDifficulty(EnumDifficulty.HARD);
                     worldserver.setAllowedSpawnTypes(true, true);
-                }
-                else if (this.isSinglePlayer())
-                {
+                } else if (this.isSinglePlayer()) {
                     worldserver.getWorldInfo().setDifficulty(difficulty);
                     worldserver.setAllowedSpawnTypes(worldserver.getDifficulty() != EnumDifficulty.PEACEFUL, true);
-                }
-                else
-                {
+                } else {
                     worldserver.getWorldInfo().setDifficulty(difficulty);
                     worldserver.setAllowedSpawnTypes(this.allowSpawnMonsters(), this.canSpawnAnimals);
                 }
             }
         }
     }
 
-    protected boolean allowSpawnMonsters()
-    {
+    protected boolean allowSpawnMonsters() {
         return true;
     }
 
-    public boolean isDemo()
-    {
+    public boolean isDemo() {
         return this.isDemo;
     }
 
-    public void setDemo(boolean demo)
-    {
+    public void setDemo(boolean demo) {
         this.isDemo = demo;
     }
 
-    public void canCreateBonusChest(boolean enable)
-    {
+    public void canCreateBonusChest(boolean enable) {
         this.enableBonusChest = enable;
     }
 
-    public ISaveFormat getActiveAnvilConverter()
-    {
+    public ISaveFormat getActiveAnvilConverter() {
         return this.anvilConverterForAnvilFile;
     }
 
-    public void deleteWorldAndStopServer()
-    {
+    public void deleteWorldAndStopServer() {
         this.worldIsBeingDeleted = true;
         this.getActiveAnvilConverter().flushCache();
 
-        for (int i = 0; i < this.worldServers.length; ++i)
-        {
-            WorldServer worldserver = this.worldServers[i];
+        // CraftBukkit start
+        for (int i = 0; i < this.worlds.size(); ++i) {
+            WorldServer worldserver = this.worlds.get(i);
+            // CraftBukkit end
 
-            if (worldserver != null)
-            {
+            if (worldserver != null) {
                 worldserver.flush();
             }
         }
 
-        this.getActiveAnvilConverter().deleteWorldDirectory(this.worldServers[0].getSaveHandler().getWorldDirectoryName());
+        this.getActiveAnvilConverter().deleteWorldDirectory(this.worlds.get(0).getSaveHandler().getWorldDirectoryName()); // CraftBukkit
         this.initiateShutdown();
     }
 
-    public String getResourcePackUrl()
-    {
+    public String getResourcePackUrl() {
         return this.resourcePackUrl;
     }
 
-    public String getResourcePackHash()
-    {
+    public String getResourcePackHash() {
         return this.resourcePackHash;
     }
 
-    public void setResourcePack(String url, String hash)
-    {
+    public void setResourcePack(String url, String hash) {
         this.resourcePackUrl = url;
         this.resourcePackHash = hash;
     }
 
-    public void addServerStatsToSnooper(PlayerUsageSnooper playerSnooper)
-    {
+    public void addServerStatsToSnooper(PlayerUsageSnooper playerSnooper) {
         playerSnooper.addClientStat("whitelist_enabled", Boolean.valueOf(false));
         playerSnooper.addClientStat("whitelist_count", Integer.valueOf(0));
 
-        if (this.serverConfigManager != null)
-        {
+        if (this.serverConfigManager != null) {
             playerSnooper.addClientStat("players_current", Integer.valueOf(this.getCurrentPlayerCount()));
             playerSnooper.addClientStat("players_max", Integer.valueOf(this.getMaxPlayers()));
             playerSnooper.addClientStat("players_seen", Integer.valueOf(this.serverConfigManager.getAvailablePlayerDat().length));
         }
 
         playerSnooper.addClientStat("uses_auth", Boolean.valueOf(this.onlineMode));
         playerSnooper.addClientStat("gui_state", this.getGuiEnabled() ? "enabled" : "disabled");
         playerSnooper.addClientStat("run_time", Long.valueOf((getCurrentTimeMillis() - playerSnooper.getMinecraftStartTimeMillis()) / 60L * 1000L));
-        playerSnooper.addClientStat("avg_tick_ms", Integer.valueOf((int)(MathHelper.average(this.tickTimeArray) * 1.0E-6D)));
+        playerSnooper.addClientStat("avg_tick_ms", Integer.valueOf((int) (MathHelper.average(this.tickTimeArray) * 1.0E-6D)));
         int i = 0;
 
-        if (this.worldServers != null)
-        {
-            for (int j = 0; j < this.worldServers.length; ++j)
-            {
-                if (this.worldServers[j] != null)
-                {
-                    WorldServer worldserver = this.worldServers[j];
+        if (this.worldServers != null) {
+            // CraftBukkit start
+            for (int j = 0; j < this.worlds.size(); ++j) {
+                WorldServer worldserver = this.worlds.get(j);
+                if (worldserver != null) {
+                    // CraftBukkit end
                     WorldInfo worldinfo = worldserver.getWorldInfo();
+
                     playerSnooper.addClientStat("world[" + i + "][dimension]", Integer.valueOf(worldserver.provider.getDimensionId()));
                     playerSnooper.addClientStat("world[" + i + "][mode]", worldinfo.getGameType());
                     playerSnooper.addClientStat("world[" + i + "][difficulty]", worldserver.getDifficulty());
                     playerSnooper.addClientStat("world[" + i + "][hardcore]", Boolean.valueOf(worldinfo.isHardcoreModeEnabled()));
                     playerSnooper.addClientStat("world[" + i + "][generator_name]", worldinfo.getTerrainType().getWorldTypeName());
@@ -1072,545 +1166,505 @@
         }
 
         playerSnooper.addClientStat("worlds", Integer.valueOf(i));
     }
 
-    public void addServerTypeToSnooper(PlayerUsageSnooper playerSnooper)
-    {
+    public void addServerTypeToSnooper(PlayerUsageSnooper playerSnooper) {
         playerSnooper.addStatToSnooper("singleplayer", Boolean.valueOf(this.isSinglePlayer()));
         playerSnooper.addStatToSnooper("server_brand", this.getServerModName());
         playerSnooper.addStatToSnooper("gui_supported", GraphicsEnvironment.isHeadless() ? "headless" : "supported");
         playerSnooper.addStatToSnooper("dedicated", Boolean.valueOf(this.isDedicatedServer()));
     }
 
-    public boolean isSnooperEnabled()
-    {
+    public boolean isSnooperEnabled() {
         return true;
     }
 
     public abstract boolean isDedicatedServer();
 
-    public boolean isServerInOnlineMode()
-    {
-        return this.onlineMode;
+    public boolean isServerInOnlineMode() {
+        return server.getOnlineMode(); // CraftBukkit
     }
 
-    public void setOnlineMode(boolean online)
-    {
+    public void setOnlineMode(boolean online) {
         this.onlineMode = online;
     }
 
-    public boolean getCanSpawnAnimals()
-    {
+    public boolean getCanSpawnAnimals() {
         return this.canSpawnAnimals;
     }
 
-    public void setCanSpawnAnimals(boolean spawnAnimals)
-    {
+    public void setCanSpawnAnimals(boolean spawnAnimals) {
         this.canSpawnAnimals = spawnAnimals;
     }
 
-    public boolean getCanSpawnNPCs()
-    {
+    public boolean getCanSpawnNPCs() {
         return this.canSpawnNPCs;
     }
 
-    public void setCanSpawnNPCs(boolean spawnNpcs)
-    {
+    public void setCanSpawnNPCs(boolean spawnNpcs) {
         this.canSpawnNPCs = spawnNpcs;
     }
 
-    public boolean isPVPEnabled()
-    {
+    public boolean isPVPEnabled() {
         return this.pvpEnabled;
     }
 
-    public void setAllowPvp(boolean allowPvp)
-    {
+    public void setAllowPvp(boolean allowPvp) {
         this.pvpEnabled = allowPvp;
     }
 
-    public boolean isFlightAllowed()
-    {
+    public boolean isFlightAllowed() {
         return this.allowFlight;
     }
 
-    public void setAllowFlight(boolean allow)
-    {
+    public void setAllowFlight(boolean allow) {
         this.allowFlight = allow;
     }
 
     public abstract boolean isCommandBlockEnabled();
 
-    public String getMOTD()
-    {
+    public String getMOTD() {
         return this.motd;
     }
 
-    public void setMOTD(String motdIn)
-    {
+    public void setMOTD(String motdIn) {
         this.motd = motdIn;
     }
 
-    public int getBuildLimit()
-    {
+    public int getBuildLimit() {
         return this.buildLimit;
     }
 
-    public void setBuildLimit(int maxBuildHeight)
-    {
+    public void setBuildLimit(int maxBuildHeight) {
         this.buildLimit = maxBuildHeight;
     }
 
-    public ServerConfigurationManager getConfigurationManager()
-    {
+    public ServerConfigurationManager getConfigurationManager() {
         return this.serverConfigManager;
     }
 
-    public void setConfigManager(ServerConfigurationManager configManager)
-    {
+    public void setConfigManager(ServerConfigurationManager configManager) {
         this.serverConfigManager = configManager;
     }
 
-    public void setGameType(WorldSettings.GameType gameMode)
-    {
-        for (int i = 0; i < this.worldServers.length; ++i)
-        {
-            getServer().worldServers[i].getWorldInfo().setGameType(gameMode);
+    public void setGameType(WorldSettings.GameType gameMode) {
+        // CraftBukkit start
+        for (int i = 0; i < this.worlds.size(); ++i) {
+            getServer().worlds.get(i).getWorldInfo().setGameType(gameMode);
+            // CraftBukkit end
         }
     }
 
-    public NetworkSystem getNetworkSystem()
-    {
+
+    // Spigot Start
+    public NetworkSystem getServerConnection() {
         return this.networkSystem;
     }
+    // Spigot End
 
-    @SideOnly(Side.CLIENT)
-    public boolean serverIsInRunLoop()
-    {
-        return this.serverIsRunning;
+    public NetworkSystem getNetworkSystem() {
+        return this.networkSystem == null ? this.networkSystem = new NetworkSystem(this) : this.networkSystem; // Spigot
     }
 
-    public boolean getGuiEnabled()
-    {
+    public boolean getGuiEnabled() {
         return false;
     }
 
     public abstract String shareToLAN(WorldSettings.GameType type, boolean allowCheats);
 
-    public int getTickCounter()
-    {
+    public int getTickCounter() {
         return this.tickCounter;
     }
 
-    public void enableProfiling()
-    {
+    public void enableProfiling() {
         this.startProfiling = true;
     }
 
-    @SideOnly(Side.CLIENT)
-    public PlayerUsageSnooper getPlayerUsageSnooper()
-    {
-        return this.usageSnooper;
-    }
-
-    public BlockPos getPosition()
-    {
+    public BlockPos getPosition() {
         return BlockPos.ORIGIN;
     }
 
-    public Vec3 getPositionVector()
-    {
+    public Vec3 getPositionVector() {
         return new Vec3(0.0D, 0.0D, 0.0D);
     }
 
-    public World getEntityWorld()
-    {
-        return this.worldServers[0];
+    public World getEntityWorld() {
+        return this.worlds.get(0); // CraftBukkit
     }
 
-    public Entity getCommandSenderEntity()
-    {
+    public Entity getCommandSenderEntity() {
         return null;
     }
 
-    public int getSpawnProtectionSize()
-    {
+    public int getSpawnProtectionSize() {
         return 16;
     }
 
-    public boolean isBlockProtected(World worldIn, BlockPos pos, EntityPlayer playerIn)
-    {
+    public boolean isBlockProtected(World worldIn, BlockPos pos, EntityPlayer playerIn) {
         return false;
     }
 
-    public boolean getForceGamemode()
-    {
+    public boolean getForceGamemode() {
         return this.isGamemodeForced;
     }
 
-    public Proxy getServerProxy()
-    {
+    public Proxy getServerProxy() {
         return this.serverProxy;
     }
 
-    public static long getCurrentTimeMillis()
-    {
+    public static long getCurrentTimeMillis() {
         return System.currentTimeMillis();
     }
 
-    public int getMaxPlayerIdleMinutes()
-    {
+    public int getMaxPlayerIdleMinutes() {
         return this.maxPlayerIdleMinutes;
     }
 
-    public void setPlayerIdleTimeout(int idleTimeout)
-    {
+    public void setPlayerIdleTimeout(int idleTimeout) {
         this.maxPlayerIdleMinutes = idleTimeout;
     }
 
-    public IChatComponent getDisplayName()
-    {
+    public IChatComponent getDisplayName() {
         return new ChatComponentText(this.getName());
     }
 
-    public boolean isAnnouncingPlayerAchievements()
-    {
+    public boolean isAnnouncingPlayerAchievements() {
         return true;
     }
 
-    public MinecraftSessionService getMinecraftSessionService()
-    {
+    public MinecraftSessionService getMinecraftSessionService() {
         return this.sessionService;
     }
 
-    public GameProfileRepository getGameProfileRepository()
-    {
+    public GameProfileRepository getGameProfileRepository() {
         return this.profileRepo;
     }
 
-    public PlayerProfileCache getPlayerProfileCache()
-    {
+    public PlayerProfileCache getPlayerProfileCache() {
         return this.profileCache;
     }
 
-    public ServerStatusResponse getServerStatusResponse()
-    {
+    public ServerStatusResponse getServerStatusResponse() {
         return this.statusResponse;
     }
 
-    public void refreshStatusNextTick()
-    {
+    public void refreshStatusNextTick() {
         this.nanoTimeSinceStatusRefresh = 0L;
     }
 
-    public Entity getEntityFromUuid(UUID uuid)
-    {
-        WorldServer[] aworldserver = this.worldServers;
-        int i = aworldserver.length;
+    public Entity getEntityFromUuid(UUID uuid) {
+        // CraftBukkit start
+        for (int j = 0; j < worlds.size(); ++j) {
+            WorldServer worldserver = worlds.get(j);
+            // CraftBukkit end
 
-        for (int j = 0; j < i; ++j)
-        {
-            WorldServer worldserver = aworldserver[j];
-
-            if (worldserver != null)
-            {
+            if (worldserver != null) {
                 Entity entity = worldserver.getEntityFromUuid(uuid);
 
-                if (entity != null)
-                {
+                if (entity != null) {
                     return entity;
                 }
             }
         }
 
         return null;
     }
 
-    public boolean sendCommandFeedback()
-    {
-        return getServer().worldServers[0].getGameRules().getGameRuleBooleanValue("sendCommandFeedback");
+    public boolean sendCommandFeedback() {
+        return getServer().worlds.get(0).getGameRules().getGameRuleBooleanValue("sendCommandFeedback"); // CraftBukkit
     }
 
-    public void setCommandStat(CommandResultStats.Type type, int amount) {}
+    public void setCommandStat(CommandResultStats.Type type, int amount) {
+    }
 
-    public int getMaxWorldSize()
-    {
+    public int getMaxWorldSize() {
         return 29999984;
     }
 
-    public ListenableFuture callFromMainThread(Callable callable)
-    {
+    public ListenableFuture callFromMainThread(Callable callable) {
         Validate.notNull(callable);
 
-        if (!this.isCallingFromMinecraftThread())
-        {
+        if (!this.isCallingFromMinecraftThread()) {
             ListenableFutureTask listenablefuturetask = ListenableFutureTask.create(callable);
             Queue queue = this.futureTaskQueue;
 
-            synchronized (this.futureTaskQueue)
-            {
+            synchronized (this.futureTaskQueue) {
                 this.futureTaskQueue.add(listenablefuturetask);
                 return listenablefuturetask;
             }
-        }
-        else
-        {
-            try
-            {
+        } else {
+            try {
                 return Futures.immediateFuture(callable.call());
-            }
-            catch (Exception exception)
-            {
+            } catch (Exception exception) {
                 return Futures.immediateFailedCheckedFuture(exception);
             }
         }
     }
 
-    public ListenableFuture addScheduledTask(Runnable runnableToSchedule)
-    {
+    public ListenableFuture addScheduledTask(Runnable runnableToSchedule) {
         Validate.notNull(runnableToSchedule);
         return this.callFromMainThread(Executors.callable(runnableToSchedule));
     }
 
-    public boolean isCallingFromMinecraftThread()
-    {
+    public boolean isCallingFromMinecraftThread() {
         return Thread.currentThread() == this.serverThread;
     }
 
-    public int getNetworkCompressionTreshold()
-    {
+    public int getNetworkCompressionTreshold() {
         return 256;
     }
 
-    @SideOnly(Side.SERVER)
-    public String getServerHostname()
-    {
+
+    public String getServerHostname() {
         return this.hostname;
     }
 
-    @SideOnly(Side.SERVER)
-    public void setHostname(String host)
-    {
+
+    public void setHostname(String host) {
         this.hostname = host;
     }
 
-    @SideOnly(Side.SERVER)
-    public void registerTickable(IUpdatePlayerListBox tickable)
-    {
+
+    public void registerTickable(IUpdatePlayerListBox tickable) {
         this.playersOnline.add(tickable);
     }
 
-    @SideOnly(Side.SERVER)
-    public static void main(String[] p_main_0_)
-    {
+
+    public static void main(final OptionSet options) { // CraftBukkit - replaces main(String[] astring)
         Bootstrap.register();
 
-        try
-        {
+        try {
+            // CraftBukkit start - Replace everything
+            /*
             boolean flag = true;
             String s = null;
             String s1 = ".";
             String s2 = null;
             boolean flag1 = false;
             boolean flag2 = false;
             int i = -1;
 
-            for (int j = 0; j < p_main_0_.length; ++j)
-            {
+            for (int j = 0; j < p_main_0_.length; ++j) {
                 String s3 = p_main_0_[j];
                 String s4 = j == p_main_0_.length - 1 ? null : p_main_0_[j + 1];
                 boolean flag3 = false;
 
-                if (!s3.equals("nogui") && !s3.equals("--nogui"))
-                {
-                    if (s3.equals("--port") && s4 != null)
-                    {
+                if (!s3.equals("nogui") && !s3.equals("--nogui")) {
+                    if (s3.equals("--port") && s4 != null) {
                         flag3 = true;
 
-                        try
-                        {
+                        try {
                             i = Integer.parseInt(s4);
-                        }
-                        catch (NumberFormatException numberformatexception)
-                        {
+                        } catch (NumberFormatException numberformatexception) {
                             ;
                         }
-                    }
-                    else if (s3.equals("--singleplayer") && s4 != null)
-                    {
+                    } else if (s3.equals("--singleplayer") && s4 != null) {
                         flag3 = true;
                         s = s4;
-                    }
-                    else if (s3.equals("--universe") && s4 != null)
-                    {
+                    } else if (s3.equals("--universe") && s4 != null) {
                         flag3 = true;
                         s1 = s4;
-                    }
-                    else if (s3.equals("--world") && s4 != null)
-                    {
+                    } else if (s3.equals("--world") && s4 != null) {
                         flag3 = true;
                         s2 = s4;
-                    }
-                    else if (s3.equals("--demo"))
-                    {
+                    } else if (s3.equals("--demo")) {
                         flag1 = true;
-                    }
-                    else if (s3.equals("--bonusChest"))
-                    {
+                    } else if (s3.equals("--bonusChest")) {
                         flag2 = true;
                     }
-                }
-                else
-                {
+                } else {
                     flag = false;
                 }
 
-                if (flag3)
-                {
+                if (flag3) {
                     ++j;
                 }
             }
 
             final DedicatedServer dedicatedserver = new DedicatedServer(new File(s1));
 
-            if (s != null)
-            {
+            if (s != null) {
                 dedicatedserver.setServerOwner(s);
             }
 
-            if (s2 != null)
-            {
+            if (s2 != null) {
                 dedicatedserver.setFolderName(s2);
             }
 
-            if (i >= 0)
-            {
+            if (i >= 0) {
                 dedicatedserver.setServerPort(i);
             }
 
-            if (flag1)
-            {
+            if (flag1) {
                 dedicatedserver.setDemo(true);
             }
 
-            if (flag2)
-            {
+            if (flag2) {
                 dedicatedserver.canCreateBonusChest(true);
             }
 
-            if (flag && !GraphicsEnvironment.isHeadless())
-            {
+            if (flag && !GraphicsEnvironment.isHeadless()) {
                 dedicatedserver.setGuiEnabled();
             }
 
             dedicatedserver.startServerThread();
-            Runtime.getRuntime().addShutdownHook(new Thread("Server Shutdown Thread")
-            {
+            Runtime.getRuntime().addShutdownHook(new Thread("Server Shutdown Thread") {
+
                 private static final String __OBFID = "CL_00001806";
-                public void run()
-                {
+
+                public void run() {
                     dedicatedserver.stopServer();
                 }
             });
-        }
-        catch (Exception exception)
-        {
+            */
+
+            DedicatedServer dedicatedserver = new DedicatedServer(options);
+
+            if (options.has("port")) {
+                int port = (Integer) options.valueOf("port");
+                if (port > 0) {
+                    dedicatedserver.setServerPort(port);
+                }
+            }
+
+            if (options.has("universe")) {
+                dedicatedserver.anvilFile = (File) options.valueOf("universe");
+            }
+
+            if (options.has("world")) {
+                dedicatedserver.setFolderName((String) options.valueOf("world"));
+            }
+
+            dedicatedserver.primaryThread.start();
+            // CraftBukkit end
+        } catch (Exception exception) {
             logger.fatal("Failed to start the minecraft server", exception);
         }
     }
 
-    @SideOnly(Side.SERVER)
-    public void logInfo(String msg)
-    {
+
+    public void logInfo(String msg) {
         logger.info(msg);
     }
 
-    @SideOnly(Side.SERVER)
-    public String getHostname()
-    {
+
+    public String getHostname() {
         return this.hostname;
     }
 
-    @SideOnly(Side.SERVER)
-    public int getPort()
-    {
+
+    public int getPort() {
         return this.serverPort;
     }
 
-    @SideOnly(Side.SERVER)
-    public String getMotd()
-    {
+
+    public String getMotd() {
         return this.motd;
     }
 
-    @SideOnly(Side.SERVER)
-    public String getPlugins()
-    {
-        return "";
+
+    public String getPlugins() {
+        // CraftBukkit start - Whole method
+        StringBuilder result = new StringBuilder();
+        Plugin[] plugins = server.getPluginManager().getPlugins();
+
+        result.append(server.getName());
+        result.append(" on Bukkit ");
+        result.append(server.getBukkitVersion());
+
+        if (plugins.length > 0 && server.getQueryPlugins()) {
+            result.append(": ");
+
+            for (int i = 0; i < plugins.length; i++) {
+                if (i > 0) {
+                    result.append("; ");
+                }
+
+                result.append(plugins[i].getDescription().getName());
+                result.append(" ");
+                result.append(plugins[i].getDescription().getVersion().replaceAll(";", ","));
+            }
+        }
+
+        return result.toString();
+        // CraftBukkit end
     }
 
-    @SideOnly(Side.SERVER)
-    public String handleRConCommand(String command)
-    {
-        RConConsoleSource.getInstance().resetLog();
-        this.commandManager.executeCommand(RConConsoleSource.getInstance(), command);
-        return RConConsoleSource.getInstance().getLogContents();
+    // CraftBukkit start - fire RemoteServerCommandEvent
+
+    public String handleRConCommand(final String command) {
+        // CraftBukkit start - fire RemoteServerCommandEvent
+        Waitable<String> waitable = new Waitable<String>() {
+
+            @Override
+            protected String evaluate() {
+                RConConsoleSource.getInstance().resetLog();
+                // this.commandManager.executeCommand(RConConsoleSource.getInstance(), command);
+                return RConConsoleSource.getInstance().getLogContents();
+            }
+        };
+        processQueue.add(waitable);
+        try {
+            return waitable.get();
+        } catch (ExecutionException e) {
+            throw new RuntimeException("Exception processing rcon command " + command, e.getCause());
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt(); // Maintain interrupted state
+            throw new RuntimeException("Interrupted processing rcon command " + command, e);
+        }
+        // CraftBukkit end
     }
 
-    @SideOnly(Side.SERVER)
-    public boolean isDebuggingEnabled()
-    {
-        return false;
+
+    public boolean isDebuggingEnabled() {
+        return this.getPropertyManager().getBooleanProperty("debug", false); // CraftBukkit - don't hardcode
     }
 
-    @SideOnly(Side.SERVER)
-    public void logSevere(String msg)
-    {
+
+    public void logSevere(String msg) {
         logger.error(msg);
     }
 
-    @SideOnly(Side.SERVER)
-    public void logDebug(String msg)
-    {
-        if (this.isDebuggingEnabled())
-        {
+
+    public void logDebug(String msg) {
+        if (this.isDebuggingEnabled()) {
             logger.info(msg);
         }
     }
 
-    @SideOnly(Side.SERVER)
-    public int getServerPort()
-    {
+
+    public int getServerPort() {
         return this.serverPort;
     }
 
-    @SideOnly(Side.SERVER)
-    public void setServerPort(int port)
-    {
+
+    public void setServerPort(int port) {
         this.serverPort = port;
     }
 
-    @SideOnly(Side.SERVER)
-    public boolean isServerStopped()
-    {
+
+    public boolean isServerStopped() {
         return this.serverStopped;
     }
 
-    @SideOnly(Side.SERVER)
-    public void setForceGamemode(boolean force)
-    {
+
+    public void setForceGamemode(boolean force) {
         this.isGamemodeForced = force;
     }
 
-    @SideOnly(Side.SERVER)
-    public long getCurrentTime()
-    {
+
+    public long getCurrentTime() {
         return this.currentTime;
     }
 
-    @SideOnly(Side.SERVER)
-    public Thread getServerThread()
-    {
+
+    public Thread getServerThread() {
         return this.serverThread;
     }
+
+    // SpigotMCP -- Add Method
+    public static Logger getLogger() {
+        return logger;
+    }
+    // SpigotMCP End
 }
