--- decompiled\net\minecraft\server\management\ServerConfigurationManager.java
+++ src\main\java\net\minecraft\server\management\ServerConfigurationManager.java
@@ -1,22 +1,19 @@
 package net.minecraft.server.management;
 
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-import com.mojang.authlib.GameProfile;
-import io.netty.buffer.Unpooled;
 import java.io.File;
 import java.net.SocketAddress;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.UUID;
+import java.util.concurrent.CopyOnWriteArrayList;
+
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityList;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.nbt.NBTTagCompound;
@@ -43,57 +40,90 @@
 import net.minecraft.scoreboard.ScoreObjective;
 import net.minecraft.scoreboard.ScorePlayerTeam;
 import net.minecraft.scoreboard.ServerScoreboard;
 import net.minecraft.scoreboard.Team;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.network.NetHandlerLoginServer;
 import net.minecraft.stats.StatList;
 import net.minecraft.stats.StatisticsFile;
 import net.minecraft.util.BlockPos;
-import net.minecraft.util.ChatComponentTranslation;
-import net.minecraft.util.EnumChatFormatting;
 import net.minecraft.util.IChatComponent;
 import net.minecraft.util.MathHelper;
+import net.minecraft.util.StatCollector;
 import net.minecraft.world.World;
 import net.minecraft.world.WorldServer;
 import net.minecraft.world.WorldSettings;
 import net.minecraft.world.border.IBorderListener;
 import net.minecraft.world.border.WorldBorder;
-import net.minecraft.world.demo.DemoWorldManager;
 import net.minecraft.world.storage.IPlayerFileData;
 import net.minecraft.world.storage.WorldInfo;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
+
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.TravelAgent;
+import org.bukkit.WeatherType;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
+import org.bukkit.craftbukkit.command.ColouredConsoleSender;
+import org.bukkit.craftbukkit.command.ConsoleCommandCompleter;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.bukkit.entity.Player;
+import org.bukkit.event.player.PlayerChangedWorldEvent;
+import org.bukkit.event.player.PlayerJoinEvent;
+import org.bukkit.event.player.PlayerLoginEvent;
+import org.bukkit.event.player.PlayerPortalEvent;
+import org.bukkit.event.player.PlayerQuitEvent;
+import org.bukkit.event.player.PlayerRespawnEvent;
+import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
+import org.bukkit.util.Vector;
+import org.spigotmc.event.player.PlayerSpawnLocationEvent;
 
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.mojang.authlib.GameProfile;
+
+import io.netty.buffer.Unpooled;
+
 public abstract class ServerConfigurationManager
 {
+
     public static final File FILE_PLAYERBANS = new File("banned-players.json");
     public static final File FILE_IPBANS = new File("banned-ips.json");
     public static final File FILE_OPS = new File("ops.json");
     public static final File FILE_WHITELIST = new File("whitelist.json");
     private static final Logger logger = LogManager.getLogger();
     private static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd \'at\' HH:mm:ss z");
     private final MinecraftServer mcServer;
-    public final List playerEntityList = Lists.newArrayList();
+    public final List playerEntityList = new CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
     public final Map uuidToPlayerMap = Maps.newHashMap();
     private final UserListBans bannedPlayers;
     private final BanList bannedIPs;
     private final UserListOps ops;
     private final UserListWhitelist whiteListedPlayers;
     private final Map playerStatFiles;
-    private IPlayerFileData playerNBTManagerObj;
+    public IPlayerFileData playerNBTManagerObj; // SpigotMCP -- Apply access transformation
     private boolean whiteListEnforced;
     protected int maxPlayers;
     private int viewDistance;
     private WorldSettings.GameType gameType;
     private boolean commandsAllowedForAll;
     private int playerPingIndex;
     private static final String __OBFID = "CL_00001423";
 
+    // CraftBukkit start
+    private CraftServer cserver;
+
     public ServerConfigurationManager(MinecraftServer server)
     {
+        this.cserver = server.server = new CraftServer(server, this);
+        server.console = ColouredConsoleSender.getInstance();
+        server.reader.addCompleter(new ConsoleCommandCompleter(server.server));
+        // CraftBukkit end
         this.bannedPlayers = new UserListBans(FILE_PLAYERBANS);
         this.bannedIPs = new BanList(FILE_IPBANS);
         this.ops = new UserListOps(FILE_OPS);
         this.whiteListedPlayers = new UserListWhitelist(FILE_WHITELIST);
         this.playerStatFiles = Maps.newHashMap();
@@ -109,49 +139,73 @@
         PlayerProfileCache playerprofilecache = this.mcServer.getPlayerProfileCache();
         GameProfile gameprofile1 = playerprofilecache.func_152652_a(gameprofile.getId());
         String s = gameprofile1 == null ? gameprofile.getName() : gameprofile1.getName();
         playerprofilecache.func_152649_a(gameprofile);
         NBTTagCompound nbttagcompound = this.readPlayerDataFromFile(playerIn);
+
+        // CraftBukkit start - Better rename detection
+        if (nbttagcompound != null && nbttagcompound.hasKey("bukkit"))
+        {
+            NBTTagCompound bukkit = nbttagcompound.getCompoundTag("bukkit");
+            s = bukkit.hasKey("lastKnownName", 8) ? bukkit.getString("lastKnownName") : s;
+        }
+
+        // CraftBukkit end
         playerIn.setWorld(this.mcServer.worldServerForDimension(playerIn.dimension));
         playerIn.theItemInWorldManager.setWorld((WorldServer)playerIn.worldObj);
         String s1 = "local";
 
         if (netManager.getRemoteAddress() != null)
         {
             s1 = netManager.getRemoteAddress().toString();
         }
 
-        logger.info(playerIn.getName() + "[" + s1 + "] logged in with entity id " + playerIn.getEntityId() + " at (" + playerIn.posX + ", " + playerIn.posY + ", " + playerIn.posZ + ")");
-        WorldServer worldserver = this.mcServer.worldServerForDimension(playerIn.dimension);
+        // Spigot start - spawn location event
+        Player bukkitPlayer = playerIn.getBukkitEntity();
+        PlayerSpawnLocationEvent ev = new PlayerSpawnLocationEvent(bukkitPlayer, bukkitPlayer.getLocation());
+        Bukkit.getPluginManager().callEvent(ev);
+        Location loc = ev.getSpawnLocation();
+        WorldServer world = ((CraftWorld)loc.getWorld()).getHandle();
+        playerIn.setWorld(world);
+        playerIn.setPosition(loc.getX(), loc.getY(), loc.getZ());
+        playerIn.setRotation(loc.getYaw(), loc.getPitch());
+        // Spigot end
         WorldInfo worldinfo = worldserver.getWorldInfo();
         BlockPos blockpos = worldserver.getSpawnPoint();
         this.func_72381_a(playerIn, (EntityPlayerMP)null, worldserver);
         NetHandlerPlayServer nethandlerplayserver = new NetHandlerPlayServer(this.mcServer, netManager, playerIn);
         nethandlerplayserver.sendPacket(new S01PacketJoinGame(playerIn.getEntityId(), playerIn.theItemInWorldManager.getGameType(), worldinfo.isHardcoreModeEnabled(), worldserver.provider.getDimensionId(), worldserver.getDifficulty(), this.getMaxPlayers(), worldinfo.getTerrainType(), worldserver.getGameRules().getGameRuleBooleanValue("reducedDebugInfo")));
+        playerIn.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         nethandlerplayserver.sendPacket(new S3FPacketCustomPayload("MC|Brand", (new PacketBuffer(Unpooled.buffer())).writeString(this.getServerInstance().getServerModName())));
         nethandlerplayserver.sendPacket(new S41PacketServerDifficulty(worldinfo.getDifficulty(), worldinfo.isDifficultyLocked()));
         nethandlerplayserver.sendPacket(new S05PacketSpawnPosition(blockpos));
         nethandlerplayserver.sendPacket(new S39PacketPlayerAbilities(playerIn.capabilities));
         nethandlerplayserver.sendPacket(new S09PacketHeldItemChange(playerIn.inventory.currentItem));
         playerIn.getStatFile().func_150877_d();
         playerIn.getStatFile().func_150884_b(playerIn);
         this.func_96456_a((ServerScoreboard)worldserver.getScoreboard(), playerIn);
         this.mcServer.refreshStatusNextTick();
-        ChatComponentTranslation chatcomponenttranslation;
+        // CraftBukkit start - login message is handled in the event
+        // ChatComponentTranslation chatcomponenttranslation;
+        String joinMessage;
 
         if (!playerIn.getName().equalsIgnoreCase(s))
         {
-            chatcomponenttranslation = new ChatComponentTranslation("multiplayer.player.joined.renamed", new Object[] {playerIn.getDisplayName(), s});
+            // chatcomponenttranslation = new ChatComponentTranslation("multiplayer.player.joined.renamed", new Object[]{playerIn.getDisplayName(), s});
+            joinMessage = "\u00A7e" + StatCollector.translateToLocalFormatted("multiplayer.player.joined.renamed", playerIn.getName(), s);
         }
         else
         {
-            chatcomponenttranslation = new ChatComponentTranslation("multiplayer.player.joined", new Object[] {playerIn.getDisplayName()});
+            // chatcomponenttranslation = new ChatComponentTranslation("multiplayer.player.joined", new Object[]{playerIn.getDisplayName()});
+            joinMessage = "\u00A7e" + StatCollector.translateToLocalFormatted("multiplayer.player.joined", playerIn.getName());
         }
 
-        chatcomponenttranslation.getChatStyle().setColor(EnumChatFormatting.YELLOW);
-        this.sendChatMsg(chatcomponenttranslation);
-        this.playerLoggedIn(playerIn);
+        // chatcomponenttranslation.getChatStyle().setColor(EnumChatFormatting.YELLOW);
+        // this.sendChatMsg(chatcomponenttranslation);
+        this.playerLoggedIn(playerIn, joinMessage);
+        // CraftBukkit end
+        worldserver = mcServer.worldServerForDimension(playerIn.dimension);  // CraftBukkit - Update in case join event changed it
         nethandlerplayserver.setPlayerLocation(playerIn.posX, playerIn.posY, playerIn.posZ, playerIn.rotationYaw, playerIn.rotationPitch);
         this.updateTimeAndWeatherForPlayer(playerIn, worldserver);
 
         if (this.mcServer.getResourcePackUrl().length() > 0)
         {
@@ -178,13 +232,16 @@
                 worldserver.spawnEntityInWorld(entity);
                 playerIn.mountEntity(entity);
                 entity.forceSpawn = false;
             }
         }
+
+        // CraftBukkit - Moved from above, added world
+        ServerConfigurationManager.logger.info(playerIn.getName() + "[" + s1 + "] logged in with entity id " + playerIn.getEntityId() + " at ([" + playerIn.worldObj.worldInfo.getWorldName() + "] " + playerIn.posX + ", " + playerIn.posY + ", " + playerIn.posZ + ")");
     }
 
-    protected void func_96456_a(ServerScoreboard scoreboardIn, EntityPlayerMP playerIn)
+    public void func_96456_a(ServerScoreboard scoreboardIn, EntityPlayerMP playerIn)   // SpigotMCP -- Apply access transformation
     {
         HashSet hashset = Sets.newHashSet();
         Iterator iterator = scoreboardIn.getTeams().iterator();
 
         while (iterator.hasNext())
@@ -211,39 +268,57 @@
                 hashset.add(scoreobjective);
             }
         }
     }
 
+    // SpigotMCP Start -- Convert to regualar inner class
+    public class WorldBorderListener implements IBorderListener
+    {
+
+        private static final String __OBFID = "CL_00002267";
+
+        public void onSizeChanged(WorldBorder border, double newSize)
+        {
+            ServerConfigurationManager.this.sendAll(new S44PacketWorldBorder(border, S44PacketWorldBorder.Action.SET_SIZE), border.world); // CraftBukkit
+        }
+
+        public void onTransitionStarted(WorldBorder border, double oldSize, double newSize, long time)
+        {
+            ServerConfigurationManager.this.sendAll(new S44PacketWorldBorder(border, S44PacketWorldBorder.Action.LERP_SIZE), border.world); // CraftBukkit
+        }
+
+        public void onCenterChanged(WorldBorder border, double x, double z)
+        {
+            ServerConfigurationManager.this.sendAll(new S44PacketWorldBorder(border, S44PacketWorldBorder.Action.SET_CENTER), border.world); // CraftBukkit
+        }
+
+        public void onWarningTimeChanged(WorldBorder border, int newTime)
+        {
+            ServerConfigurationManager.this.sendAll(new S44PacketWorldBorder(border, S44PacketWorldBorder.Action.SET_WARNING_TIME), border.world); // CraftBukkit
+        }
+
+        public void onWarningDistanceChanged(WorldBorder border, int newDistance)
+        {
+            ServerConfigurationManager.this.sendAll(new S44PacketWorldBorder(border, S44PacketWorldBorder.Action.SET_WARNING_BLOCKS), border.world); // CraftBukkit
+        }
+
+        public void onDamageAmountChanged(WorldBorder border, double newAmount)
+        {
+        }
+
+        public void onDamageBufferChanged(WorldBorder border, double newSize)
+        {
+        }
+    }
+
+    // SpigotMCP End
     public void setPlayerManager(WorldServer[] p_72364_1_)
     {
+        if (playerNBTManagerObj != null) return; // CraftBukkit
+
         this.playerNBTManagerObj = p_72364_1_[0].getSaveHandler().getPlayerNBTManager();
-        p_72364_1_[0].getWorldBorder().addListener(new IBorderListener()
-        {
-            private static final String __OBFID = "CL_00002267";
-            public void onSizeChanged(WorldBorder border, double newSize)
-            {
-                ServerConfigurationManager.this.sendPacketToAllPlayers(new S44PacketWorldBorder(border, S44PacketWorldBorder.Action.SET_SIZE));
-            }
-            public void onTransitionStarted(WorldBorder border, double oldSize, double newSize, long time)
-            {
-                ServerConfigurationManager.this.sendPacketToAllPlayers(new S44PacketWorldBorder(border, S44PacketWorldBorder.Action.LERP_SIZE));
-            }
-            public void onCenterChanged(WorldBorder border, double x, double z)
-            {
-                ServerConfigurationManager.this.sendPacketToAllPlayers(new S44PacketWorldBorder(border, S44PacketWorldBorder.Action.SET_CENTER));
-            }
-            public void onWarningTimeChanged(WorldBorder border, int newTime)
-            {
-                ServerConfigurationManager.this.sendPacketToAllPlayers(new S44PacketWorldBorder(border, S44PacketWorldBorder.Action.SET_WARNING_TIME));
-            }
-            public void onWarningDistanceChanged(WorldBorder border, int newDistance)
-            {
-                ServerConfigurationManager.this.sendPacketToAllPlayers(new S44PacketWorldBorder(border, S44PacketWorldBorder.Action.SET_WARNING_BLOCKS));
-            }
-            public void onDamageAmountChanged(WorldBorder border, double newAmount) {}
-            public void onDamageBufferChanged(WorldBorder border, double newSize) {}
-        });
+        p_72364_1_[0].getWorldBorder().addListener(new WorldBorderListener()); // SpigotMCP -- Use regular inner class
     }
 
     public void func_72375_a(EntityPlayerMP playerIn, WorldServer worldIn)
     {
         WorldServer worldserver1 = playerIn.getServerForPlayer();
@@ -262,11 +337,11 @@
         return PlayerManager.getFurthestViewableBlock(this.getViewDistance());
     }
 
     public NBTTagCompound readPlayerDataFromFile(EntityPlayerMP playerIn)
     {
-        NBTTagCompound nbttagcompound = this.mcServer.worldServers[0].getWorldInfo().getPlayerNBTTagCompound();
+        NBTTagCompound nbttagcompound = this.mcServer.worlds.get(0).getWorldInfo().getPlayerNBTTagCompound(); // CraftBukkit
         NBTTagCompound nbttagcompound1;
 
         if (playerIn.getName().equals(this.mcServer.getServerOwner()) && nbttagcompound != null)
         {
             playerIn.readFromNBT(nbttagcompound);
@@ -290,53 +365,150 @@
         {
             statisticsfile.saveStatFile();
         }
     }
 
-    public void playerLoggedIn(EntityPlayerMP playerIn)
+    public void playerLoggedIn(EntityPlayerMP playerIn, String joinMessage)   // CraftBukkit added joinMessage
     {
         this.playerEntityList.add(playerIn);
         this.uuidToPlayerMap.put(playerIn.getUniqueID(), playerIn);
-        this.sendPacketToAllPlayers(new S38PacketPlayerListItem(S38PacketPlayerListItem.Action.ADD_PLAYER, new EntityPlayerMP[] {playerIn}));
+        // this.sendPacketToAllPlayers(new S38PacketPlayerListItem(S38PacketPlayerListItem.Action.ADD_PLAYER, new EntityPlayerMP[]{playerIn})); // CraftBukkit - replaced with loop below
         WorldServer worldserver = this.mcServer.worldServerForDimension(playerIn.dimension);
-        worldserver.spawnEntityInWorld(playerIn);
-        this.func_72375_a(playerIn, (WorldServer)null);
+        // CraftBukkit start
+        PlayerJoinEvent playerJoinEvent = new PlayerJoinEvent(cserver.getPlayer(playerIn), joinMessage);
+        cserver.getPluginManager().callEvent(playerJoinEvent);
+        joinMessage = playerJoinEvent.getJoinMessage();
 
+        if (joinMessage != null && joinMessage.length() > 0)
+        {
+            for (IChatComponent line : org.bukkit.craftbukkit.util.CraftChatMessage.fromString(joinMessage))
+            {
+                mcServer.getConfigurationManager().sendPacketToAllPlayers(new S02PacketChat(line));
+            }
+        }
+
+        ChunkIOExecutor.adjustPoolSize(getCurrentPlayerCount());
+        // CraftBukkit end
+        // CraftBukkit start - sendAll above replaced with this loop
+        S38PacketPlayerListItem packet = new S38PacketPlayerListItem(S38PacketPlayerListItem.Action.ADD_PLAYER, playerIn);
+
         for (int i = 0; i < this.playerEntityList.size(); ++i)
         {
-            EntityPlayerMP entityplayermp1 = (EntityPlayerMP)this.playerEntityList.get(i);
-            playerIn.playerNetServerHandler.sendPacket(new S38PacketPlayerListItem(S38PacketPlayerListItem.Action.ADD_PLAYER, new EntityPlayerMP[] {entityplayermp1}));
+            EntityPlayerMP entityplayer1 = (EntityPlayerMP)this.playerEntityList.get(i);
+
+            if (entityplayer1.getBukkitEntity().canSee(playerIn.getBukkitEntity()))
+            {
+                entityplayer1.playerNetServerHandler.sendPacket(packet);
+            }
+
+            if (!playerIn.getBukkitEntity().canSee(entityplayer1.getBukkitEntity()))
+            {
+                continue;
+            }
+
+            playerIn.playerNetServerHandler.sendPacket(new S38PacketPlayerListItem(S38PacketPlayerListItem.Action.ADD_PLAYER, new EntityPlayerMP[] {entityplayer1}));
         }
+
+        // CraftBukkit end
+
+        // CraftBukkit start - Only add if the player wasn't moved in the event
+        if (playerIn.worldObj == worldserver && !worldserver.playerEntities.contains(playerIn))
+        {
+            worldserver.spawnEntityInWorld(playerIn);
+            this.func_72375_a(playerIn, (WorldServer)null);
+        }
+
+        // CraftBukkit end
     }
 
     public void serverUpdateMountedMovingPlayer(EntityPlayerMP playerIn)
     {
         playerIn.getServerForPlayer().getPlayerManager().updateMountedMovingPlayer(playerIn);
     }
 
-    public void playerLoggedOut(EntityPlayerMP playerIn)
+    public String playerLoggedOut(EntityPlayerMP playerIn)   // CraftBukkit - return string
     {
         playerIn.triggerAchievement(StatList.leaveGameStat);
+        // CraftBukkit start - Quitting must be before we do final save of data, in case plugins need to modify it
+        org.bukkit.craftbukkit.event.CraftEventFactory.handleInventoryCloseEvent(playerIn);
+        PlayerQuitEvent playerQuitEvent = new PlayerQuitEvent(cserver.getPlayer(playerIn), "\u00A7e" + playerIn.getName() + " left the game.");
+        cserver.getPluginManager().callEvent(playerQuitEvent);
+        playerIn.getBukkitEntity().disconnect(playerQuitEvent.getQuitMessage());
+        // CraftBukkit end
         this.writePlayerData(playerIn);
         WorldServer worldserver = playerIn.getServerForPlayer();
 
-        if (playerIn.ridingEntity != null)
+        if (playerIn.ridingEntity != null && !(playerIn.ridingEntity instanceof EntityPlayer))   // CraftBukkit - Don't remove players
         {
             worldserver.removePlayerEntityDangerously(playerIn.ridingEntity);
             logger.debug("removing player mount");
         }
 
         worldserver.removeEntity(playerIn);
         worldserver.getPlayerManager().removePlayer(playerIn);
         this.playerEntityList.remove(playerIn);
         this.uuidToPlayerMap.remove(playerIn.getUniqueID());
         this.playerStatFiles.remove(playerIn.getUniqueID());
-        this.sendPacketToAllPlayers(new S38PacketPlayerListItem(S38PacketPlayerListItem.Action.REMOVE_PLAYER, new EntityPlayerMP[] {playerIn}));
+        // CraftBukkit start
+        // this.sendPacketToAllPlayers(new S38PacketPlayerListItem(S38PacketPlayerListItem.Action.REMOVE_PLAYER, new EntityPlayerMP[]{playerIn}));
+        S38PacketPlayerListItem packet = new S38PacketPlayerListItem(S38PacketPlayerListItem.Action.REMOVE_PLAYER, playerIn);
+
+        for (int i = 0; i < playerEntityList.size(); i++)
+        {
+            EntityPlayerMP entityplayer1 = (EntityPlayerMP)this.playerEntityList.get(i);
+
+            if (entityplayer1.getBukkitEntity().canSee(playerIn.getBukkitEntity()))
+            {
+                entityplayer1.playerNetServerHandler.sendPacket(packet);
+            }
+            else
+            {
+                entityplayer1.getBukkitEntity().removeDisconnectingPlayer(playerIn.getBukkitEntity());
+            }
+        }
+
+        // This removes the scoreboard (and player reference) for the specific player in the manager
+        cserver.getScoreboardManager().removePlayer(playerIn.getBukkitEntity());
+        // CraftBukkit end
+        ChunkIOExecutor.adjustPoolSize(this.getCurrentPlayerCount()); // CraftBukkit
+        return playerQuitEvent.getQuitMessage(); // CraftBukkit
     }
 
-    public String allowUserToConnect(SocketAddress address, GameProfile profile)
+    // CraftBukkit start - Whole method, SocketAddress to LoginListener, added hostname to signature, return EntityPlayer
+    public EntityPlayerMP attemptLogin(NetHandlerLoginServer loginlistener, GameProfile profile, String hostname)
     {
+        // Moved from processLogin
+        UUID uuid = EntityPlayer.getUUID(profile);
+        ArrayList arraylist = Lists.newArrayList();
+        EntityPlayerMP entityplayer;
+
+        for (int i = 0; i < this.playerEntityList.size(); ++i)
+        {
+            entityplayer = (EntityPlayerMP)this.playerEntityList.get(i);
+
+            if (entityplayer.getUniqueID().equals(uuid))
+            {
+                arraylist.add(entityplayer);
+            }
+        }
+
+        Iterator iterator = arraylist.iterator();
+
+        while (iterator.hasNext())
+        {
+            entityplayer = (EntityPlayerMP)iterator.next();
+            writePlayerData(entityplayer); // CraftBukkit - Force the player's inventory to be saved
+            entityplayer.playerNetServerHandler.kickPlayerFromServer("You logged in from another location");
+        }
+
+        // Instead of kicking then returning, we need to store the kick reason
+        // in the event, check with plugins to see if it's ok, and THEN kick
+        // depending on the outcome.
+        SocketAddress socketaddress = loginlistener.networkManager.getRemoteAddress();
+        EntityPlayerMP entity = new EntityPlayerMP(mcServer, mcServer.worldServerForDimension(0), profile, new ItemInWorldManager(mcServer.worldServerForDimension(0)));
+        Player player = entity.getBukkitEntity();
+        PlayerLoginEvent event = new PlayerLoginEvent(player, hostname, ((java.net.InetSocketAddress)socketaddress).getAddress(), ((java.net.InetSocketAddress)loginlistener.networkManager.getRawAddress()).getAddress());
         String s;
 
         if (this.bannedPlayers.isBanned(profile))
         {
             UserListBansEntry userlistbansentry = (UserListBansEntry)this.bannedPlayers.getEntry(profile);
@@ -345,192 +517,369 @@
             if (userlistbansentry.getBanEndDate() != null)
             {
                 s = s + "\nYour ban will be removed on " + dateFormat.format(userlistbansentry.getBanEndDate());
             }
 
-            return s;
+            // return s;
+            if (!userlistbansentry.hasBanExpired()) event.disallow(PlayerLoginEvent.Result.KICK_BANNED, s); // Spigot
         }
         else if (!this.canJoin(profile))
         {
-            return "You are not white-listed on this server!";
+            // return "You are not white-listed on this server!";
+            event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, org.spigotmc.SpigotConfig.whitelistMessage); // Spigot
         }
-        else if (this.bannedIPs.isBanned(address))
+        else if (this.bannedIPs.isBanned(socketaddress))
         {
-            IPBanEntry ipbanentry = this.bannedIPs.getBanEntry(address);
+            IPBanEntry ipbanentry = this.bannedIPs.getBanEntry(socketaddress);
             s = "Your IP address is banned from this server!\nReason: " + ipbanentry.getBanReason();
 
             if (ipbanentry.getBanEndDate() != null)
             {
                 s = s + "\nYour ban will be removed on " + dateFormat.format(ipbanentry.getBanEndDate());
             }
 
-            return s;
+            // return s;
+            event.disallow(PlayerLoginEvent.Result.KICK_BANNED, s);
         }
         else
         {
-            return this.playerEntityList.size() >= this.maxPlayers ? "The server is full!" : null;
+            // return this.playerEntityList.size() >= this.maxPlayers ? "The server is full!" : null;
+            if (this.playerEntityList.size() >= this.maxPlayers)
+            {
+                event.disallow(PlayerLoginEvent.Result.KICK_FULL, org.spigotmc.SpigotConfig.serverFullMessage); // Spigot
+            }
         }
+
+        cserver.getPluginManager().callEvent(event);
+
+        if (event.getResult() != PlayerLoginEvent.Result.ALLOWED)
+        {
+            loginlistener.closeConnection(event.getKickMessage());
+            return null;
+        }
+
+        return entity;
     }
+    // CraftBukkit end
 
-    public EntityPlayerMP createPlayerForUser(GameProfile profile)
+    public EntityPlayerMP createPlayerForUser(GameProfile profile, EntityPlayerMP player)   // CraftBukkit - added EntityPlayer
     {
+        // CraftBukkit start -- Moved up
+        /*
         UUID uuid = EntityPlayer.getUUID(profile);
         ArrayList arraylist = Lists.newArrayList();
         EntityPlayerMP entityplayermp;
 
-        for (int i = 0; i < this.playerEntityList.size(); ++i)
-        {
-            entityplayermp = (EntityPlayerMP)this.playerEntityList.get(i);
+        for (int i = 0; i < this.playerEntityList.size(); ++i) {
+            entityplayermp = (EntityPlayerMP) this.playerEntityList.get(i);
 
-            if (entityplayermp.getUniqueID().equals(uuid))
-            {
+            if (entityplayermp.getUniqueID().equals(uuid)) {
                 arraylist.add(entityplayermp);
             }
         }
 
         Iterator iterator = arraylist.iterator();
 
-        while (iterator.hasNext())
-        {
-            entityplayermp = (EntityPlayerMP)iterator.next();
+        while (iterator.hasNext()) {
+            entityplayermp = (EntityPlayerMP) iterator.next();
             entityplayermp.playerNetServerHandler.kickPlayerFromServer("You logged in from another location");
         }
-
+        // CraftBukkit end */
+        // CraftBukkit start
+        /*
         Object object;
 
-        if (this.mcServer.isDemo())
-        {
+        if (this.mcServer.isDemo()) {
             object = new DemoWorldManager(this.mcServer.worldServerForDimension(0));
-        }
-        else
-        {
+        } else {
             object = new ItemInWorldManager(this.mcServer.worldServerForDimension(0));
         }
 
-        return new EntityPlayerMP(this.mcServer, this.mcServer.worldServerForDimension(0), profile, (ItemInWorldManager)object);
+        return new EntityPlayerMP(this.mcServer, this.mcServer.worldServerForDimension(0), profile, (ItemInWorldManager) object);
+        */
+        return player;
+        // CraftBukkit end
     }
 
+    // CraftBukkit Start
     public EntityPlayerMP recreatePlayerEntity(EntityPlayerMP playerIn, int dimension, boolean conqueredEnd)
     {
+        return this.moveToWorld(playerIn, dimension, conqueredEnd, null, true);
+    }
+
+    public EntityPlayerMP moveToWorld(EntityPlayerMP playerIn, int dimension, boolean conqueredEnd, Location location, boolean avoidSuffocation)   // SpigotMCP -- Use mcp mappings
+    {
+        // CraftBukkit end
         playerIn.getServerForPlayer().getEntityTracker().removePlayerFromTrackers(playerIn);
-        playerIn.getServerForPlayer().getEntityTracker().untrackEntity(playerIn);
+        // playerIn.getServerForPlayer().getEntityTracker().untrackEntity(playerIn); // CraftBukkit
         playerIn.getServerForPlayer().getPlayerManager().removePlayer(playerIn);
         this.playerEntityList.remove(playerIn);
         this.mcServer.worldServerForDimension(playerIn.dimension).removePlayerEntityDangerously(playerIn);
         BlockPos blockpos = playerIn.getBedLocation();
         boolean flag1 = playerIn.isSpawnForced();
+        // CraftBukkit start
+        /*
         playerIn.dimension = dimension;
         Object object;
 
-        if (this.mcServer.isDemo())
-        {
+        if (this.mcServer.isDemo()) {
             object = new DemoWorldManager(this.mcServer.worldServerForDimension(playerIn.dimension));
-        }
-        else
-        {
+        } else {
             object = new ItemInWorldManager(this.mcServer.worldServerForDimension(playerIn.dimension));
         }
 
-        EntityPlayerMP entityplayermp1 = new EntityPlayerMP(this.mcServer, this.mcServer.worldServerForDimension(playerIn.dimension), playerIn.getGameProfile(), (ItemInWorldManager)object);
+        EntityPlayerMP entityplayermp1 = new EntityPlayerMP(this.mcServer, this.mcServer.worldServerForDimension(playerIn.dimension), playerIn.getGameProfile(), (ItemInWorldManager) object);
+        */
+        EntityPlayerMP entityplayermp1 = playerIn;
+        org.bukkit.World fromWorld = playerIn.getBukkitEntity().getWorld();
+        playerIn.playerConqueredTheEnd = false;
+        // CraftBukkit end
         entityplayermp1.playerNetServerHandler = playerIn.playerNetServerHandler;
         entityplayermp1.clonePlayer(playerIn, conqueredEnd);
         entityplayermp1.setEntityId(playerIn.getEntityId());
         entityplayermp1.func_174817_o(playerIn);
-        WorldServer worldserver = this.mcServer.worldServerForDimension(playerIn.dimension);
-        this.func_72381_a(entityplayermp1, playerIn, worldserver);
+        // WorldServer worldserver = this.mcServer.worldServerForDimension(playerIn.dimension); // CraftBukkit - handled later
+        // this.func_72381_a(entityplayermp1, playerIn, worldserver); // CraftBukkit - removed
         BlockPos blockpos1;
 
-        if (blockpos != null)
+        // CraftBukkit start - fire PlayerRespawnEvent
+        if (location == null)
         {
-            blockpos1 = EntityPlayer.getBedSpawnLocation(this.mcServer.worldServerForDimension(playerIn.dimension), blockpos, flag1);
+            boolean isBedSpawn = false;
+            CraftWorld cworld = (CraftWorld)this.mcServer.server.getWorld(playerIn.spawnWorld);
 
-            if (blockpos1 != null)
+            if (cworld != null && blockpos != null)
             {
-                entityplayermp1.setLocationAndAngles((double)((float)blockpos1.getX() + 0.5F), (double)((float)blockpos1.getY() + 0.1F), (double)((float)blockpos1.getZ() + 0.5F), 0.0F, 0.0F);
-                entityplayermp1.setSpawnPoint(blockpos, flag1);
+                blockpos1 = EntityPlayer.getBedSpawnLocation(cworld.getHandle(), blockpos, flag1);
+
+                if (blockpos1 != null)
+                {
+                    isBedSpawn = true;
+                    location = new Location(cworld, blockpos1.getX() + 0.5, blockpos1.getY(), blockpos1.getZ() + 0.5);
+                }
+                else
+                {
+                    entityplayermp1.setSpawnPoint(null, true);
+                    entityplayermp1.playerNetServerHandler.sendPacket(new S2BPacketChangeGameState(0, 0.0F));
+                }
             }
-            else
+
+            if (location == null)
             {
-                entityplayermp1.playerNetServerHandler.sendPacket(new S2BPacketChangeGameState(0, 0.0F));
+                cworld = (CraftWorld)this.mcServer.server.getWorlds().get(0);
+                blockpos = cworld.getHandle().getSpawnPoint();
+                location = new Location(cworld, blockpos.getX() + 0.5, blockpos.getY(), blockpos.getZ() + 0.5);
             }
+
+            Player respawnPlayer = cserver.getPlayer(entityplayermp1);
+            PlayerRespawnEvent respawnEvent = new PlayerRespawnEvent(respawnPlayer, location, isBedSpawn);
+            cserver.getPluginManager().callEvent(respawnEvent);
+
+            // Spigot Start
+            if (playerIn.playerNetServerHandler.isDisconnected())
+            {
+                return playerIn;
+            }
+
+            // Spigot End
+            location = respawnEvent.getRespawnLocation();
+            playerIn.reset();
         }
+        else
+        {
+            location.setWorld(mcServer.worldServerForDimension(dimension).getWorld());
+        }
 
+        WorldServer worldserver = ((CraftWorld)location.getWorld()).getHandle();
+        entityplayermp1.setPositionAndRotation(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch());
+        // CraftBukkit end
         worldserver.theChunkProviderServer.loadChunk((int)entityplayermp1.posX >> 4, (int)entityplayermp1.posZ >> 4);
 
-        while (!worldserver.getCollidingBoundingBoxes(entityplayermp1, entityplayermp1.getEntityBoundingBox()).isEmpty() && entityplayermp1.posY < 256.0D)
+        while (avoidSuffocation && !worldserver.getCollidingBoundingBoxes(entityplayermp1, entityplayermp1.getEntityBoundingBox()).isEmpty() && entityplayermp1.posY < 256.0D)   // CraftBukkit
         {
             entityplayermp1.setPosition(entityplayermp1.posX, entityplayermp1.posY + 1.0D, entityplayermp1.posZ);
         }
 
-        entityplayermp1.playerNetServerHandler.sendPacket(new S07PacketRespawn(entityplayermp1.dimension, entityplayermp1.worldObj.getDifficulty(), entityplayermp1.worldObj.getWorldInfo().getTerrainType(), entityplayermp1.theItemInWorldManager.getGameType()));
+        // CraftBukkit start
+        byte actualDimension = (byte)(worldserver.getWorld().getEnvironment().getId());
+        // Force the client to refresh their chunk cache
+        entityplayermp1.playerNetServerHandler.sendPacket(new S07PacketRespawn(actualDimension, worldserver.getDifficulty(), worldserver.getWorldInfo().getTerrainType(), entityplayermp1.theItemInWorldManager.getGameType()));
+        entityplayermp1.setWorld(worldserver);
+        entityplayermp1.isDead = false;
+        entityplayermp1.playerNetServerHandler.teleport(new Location(worldserver.getWorld(), entityplayermp1.posX, entityplayermp1.posY, entityplayermp1.posZ, entityplayermp1.rotationYaw, entityplayermp1.rotationPitch));
+        entityplayermp1.setSneaking(false);
         blockpos1 = worldserver.getSpawnPoint();
-        entityplayermp1.playerNetServerHandler.setPlayerLocation(entityplayermp1.posX, entityplayermp1.posY, entityplayermp1.posZ, entityplayermp1.rotationYaw, entityplayermp1.rotationPitch);
+        // entityplayermp1.playerNetServerHandler.setPlayerLocation(entityplayermp1.posX, entityplayermp1.posY, entityplayermp1.posZ, entityplayermp1.rotationYaw, entityplayermp1.rotationPitch);
+        // CraftBukkit End
         entityplayermp1.playerNetServerHandler.sendPacket(new S05PacketSpawnPosition(blockpos1));
         entityplayermp1.playerNetServerHandler.sendPacket(new S1FPacketSetExperience(entityplayermp1.experience, entityplayermp1.experienceTotal, entityplayermp1.experienceLevel));
         this.updateTimeAndWeatherForPlayer(entityplayermp1, worldserver);
-        worldserver.getPlayerManager().addPlayer(entityplayermp1);
-        worldserver.spawnEntityInWorld(entityplayermp1);
-        this.playerEntityList.add(entityplayermp1);
-        this.uuidToPlayerMap.put(entityplayermp1.getUniqueID(), entityplayermp1);
-        entityplayermp1.addSelfToInternalCraftingInventory();
+
+        // CraftBukkit Start
+        if (!playerIn.playerNetServerHandler.isDisconnected())
+        {
+            worldserver.getPlayerManager().addPlayer(entityplayermp1);
+            worldserver.spawnEntityInWorld(entityplayermp1);
+            this.playerEntityList.add(entityplayermp1);
+            this.uuidToPlayerMap.put(entityplayermp1.getUniqueID(), entityplayermp1);
+        }
+
+        // Added from changeDimension
+        syncPlayerInventory(playerIn); // Update health, etc...
+        playerIn.sendPlayerAbilities();
+
+        for (Object o1 : playerIn.getActivePotionEffects())
+        {
+            PotionEffect mobEffect = (PotionEffect)o1;
+            playerIn.playerNetServerHandler.sendPacket(new S1DPacketEntityEffect(playerIn.getEntityId(), mobEffect));
+        }
+
+        // entityplayermp1.addSelfToInternalCraftingInventory();
         entityplayermp1.setHealth(entityplayermp1.getHealth());
+
+        // CraftBukkit start
+        // Don't fire on respawn
+        if (fromWorld != location.getWorld())
+        {
+            PlayerChangedWorldEvent event = new PlayerChangedWorldEvent(playerIn.getBukkitEntity(), fromWorld);
+            mcServer.server.getPluginManager().callEvent(event);
+        }
+
+        // Save player file again if they were disconnected
+        if (playerIn.playerNetServerHandler.isDisconnected())
+        {
+            this.writePlayerData(playerIn);
+        }
+
+        // CraftBukkit end
         return entityplayermp1;
     }
 
-    public void transferPlayerToDimension(EntityPlayerMP playerIn, int dimension)
+    // CraftBukkit start - Replaced the standard handling of portals with a more customised method.
+    public void changeDimension(EntityPlayerMP entityplayer, int i, TeleportCause cause)   // SpigotMCP -- Use Bukkit names
     {
-        int j = playerIn.dimension;
-        WorldServer worldserver = this.mcServer.worldServerForDimension(playerIn.dimension);
-        playerIn.dimension = dimension;
-        WorldServer worldserver1 = this.mcServer.worldServerForDimension(playerIn.dimension);
-        playerIn.playerNetServerHandler.sendPacket(new S07PacketRespawn(playerIn.dimension, playerIn.worldObj.getDifficulty(), playerIn.worldObj.getWorldInfo().getTerrainType(), playerIn.theItemInWorldManager.getGameType()));
-        worldserver.removePlayerEntityDangerously(playerIn);
-        playerIn.isDead = false;
-        this.transferEntityToWorld(playerIn, j, worldserver, worldserver1);
-        this.func_72375_a(playerIn, worldserver);
-        playerIn.playerNetServerHandler.setPlayerLocation(playerIn.posX, playerIn.posY, playerIn.posZ, playerIn.rotationYaw, playerIn.rotationPitch);
-        playerIn.theItemInWorldManager.setWorld(worldserver1);
-        this.updateTimeAndWeatherForPlayer(playerIn, worldserver1);
-        this.syncPlayerInventory(playerIn);
-        Iterator iterator = playerIn.getActivePotionEffects().iterator();
+        WorldServer exitWorld = null;
 
-        while (iterator.hasNext())
+        if (entityplayer.dimension < CraftWorld.CUSTOM_DIMENSION_OFFSET)   // plugins must specify exit from custom Bukkit worlds
         {
-            PotionEffect potioneffect = (PotionEffect)iterator.next();
-            playerIn.playerNetServerHandler.sendPacket(new S1DPacketEntityEffect(playerIn.getEntityId(), potioneffect));
+            // only target existing worlds (compensate for allow-nether/allow-end as false)
+            for (WorldServer world : this.mcServer.worlds)
+            {
+                if (world.dimension == i)
+                {
+                    exitWorld = world;
+                }
+            }
         }
+
+        Location enter = entityplayer.getBukkitEntity().getLocation();
+        Location exit = null;
+        boolean useTravelAgent = false; // don't use agent for custom worlds or return from THE_END
+
+        if (exitWorld != null)
+        {
+            if ((cause == TeleportCause.END_PORTAL) && (i == 0))
+            {
+                // THE_END -> NORMAL; use bed if available, otherwise default spawn
+                exit = ((org.bukkit.craftbukkit.entity.CraftPlayer)entityplayer.getBukkitEntity()).getBedSpawnLocation();
+
+                if (exit == null || ((CraftWorld)exit.getWorld()).getHandle().dimension != 0)
+                {
+                    exit = exitWorld.getWorld().getSpawnLocation();
+                }
+            }
+            else
+            {
+                // NORMAL <-> NETHER or NORMAL -> THE_END
+                exit = this.calculateTarget(enter, exitWorld);
+                useTravelAgent = true;
+            }
+        }
+
+        TravelAgent agent = exit != null ? (TravelAgent)((CraftWorld)exit.getWorld()).getHandle().getDefaultTeleporter() : org.bukkit.craftbukkit.CraftTravelAgent.DEFAULT;  // return arbitrary TA to compensate for implementation dependent plugins
+        PlayerPortalEvent event = new PlayerPortalEvent(entityplayer.getBukkitEntity(), enter, exit, agent, cause);
+        event.useTravelAgent(useTravelAgent);
+        Bukkit.getServer().getPluginManager().callEvent(event);
+
+        if (event.isCancelled() || event.getTo() == null)
+        {
+            return;
+        }
+
+        exit = event.useTravelAgent() ? event.getPortalTravelAgent().findOrCreate(event.getTo()) : event.getTo();
+
+        if (exit == null)
+        {
+            return;
+        }
+
+        exitWorld = ((CraftWorld)exit.getWorld()).getHandle();
+        Vector velocity = entityplayer.getBukkitEntity().getVelocity();
+        boolean before = exitWorld.theChunkProviderServer.chunkLoadOverride;
+        exitWorld.theChunkProviderServer.chunkLoadOverride = true;
+        exitWorld.getDefaultTeleporter().adjustExit(entityplayer, exit, velocity);
+        exitWorld.theChunkProviderServer.chunkLoadOverride = before;
+        this.moveToWorld(entityplayer, exitWorld.dimension, true, exit, false); // Vanilla doesn't check for suffocation when handling portals, so neither should we
+
+        if (entityplayer.motionX != velocity.getX() || entityplayer.motionY != velocity.getY() || entityplayer.motionZ != velocity.getZ())
+        {
+            entityplayer.getBukkitEntity().setVelocity(velocity);
+        }
     }
+    // CraftBukkit end
 
-    public void transferEntityToWorld(Entity entityIn, int p_82448_2_, WorldServer p_82448_3_, WorldServer p_82448_4_)
+    public void transferEntityToWorld(Entity entity, int i, WorldServer worldserver, WorldServer worldserver1)   // SpigotMCP -- Use Bukkit names
     {
+        // CraftBukkit start - Split into modular functions
+        Location exit = calculateTarget(entity.getBukkitEntity().getLocation(), worldserver1);
+        repositionEntity(entity, exit, true);
+    }
+
+    public Location calculateTarget(Location enter, World target)
+    {
+        // SpigotMCP Start -- Convert craftbukkit's fake variables to mcp names
+        WorldServer p_82448_3_ = ((CraftWorld)enter.getWorld()).getHandle();
+        WorldServer p_82448_4_ = ((CraftWorld)target.getWorld()).getHandle();
+        int p_82448_2_ = p_82448_3_.dimension;
+        // SpigotMCP End
+        double y = enter.getY();
+        float yaw = enter.getYaw();
+        float pitch = enter.getPitch();
+        double d0 = enter.getX();
+        double d1 = enter.getZ();
+        double d2 = 8.0D;
+        /*
         double d0 = entityIn.posX;
         double d1 = entityIn.posZ;
         double d2 = 8.0D;
         float f = entityIn.rotationYaw;
         p_82448_3_.theProfiler.startSection("moving");
+        */
 
-        if (entityIn.dimension == -1)
+        if (p_82448_4_.dimension == -1)
         {
             d0 = MathHelper.clamp_double(d0 / d2, p_82448_4_.getWorldBorder().minX() + 16.0D, p_82448_4_.getWorldBorder().maxX() - 16.0D);
             d1 = MathHelper.clamp_double(d1 / d2, p_82448_4_.getWorldBorder().minZ() + 16.0D, p_82448_4_.getWorldBorder().maxZ() - 16.0D);
+            /*
             entityIn.setLocationAndAngles(d0, entityIn.posY, d1, entityIn.rotationYaw, entityIn.rotationPitch);
 
-            if (entityIn.isEntityAlive())
-            {
+            if (entityIn.isEntityAlive()) {
                 p_82448_3_.updateEntityWithOptionalForce(entityIn, false);
             }
+            */
         }
-        else if (entityIn.dimension == 0)
+        else if (p_82448_4_.dimension == 0)
         {
             d0 = MathHelper.clamp_double(d0 * d2, p_82448_4_.getWorldBorder().minX() + 16.0D, p_82448_4_.getWorldBorder().maxX() - 16.0D);
             d1 = MathHelper.clamp_double(d1 * d2, p_82448_4_.getWorldBorder().minZ() + 16.0D, p_82448_4_.getWorldBorder().maxZ() - 16.0D);
+            /*
             entityIn.setLocationAndAngles(d0, entityIn.posY, d1, entityIn.rotationYaw, entityIn.rotationPitch);
 
-            if (entityIn.isEntityAlive())
-            {
+            if (entityIn.isEntityAlive()) {
                 p_82448_3_.updateEntityWithOptionalForce(entityIn, false);
             }
+            */
         }
         else
         {
             BlockPos blockpos;
 
@@ -542,40 +891,137 @@
             {
                 blockpos = p_82448_4_.func_180504_m();
             }
 
             d0 = (double)blockpos.getX();
-            entityIn.posY = (double)blockpos.getY();
+            y = (double)blockpos.getY();
             d1 = (double)blockpos.getZ();
+            /*
             entityIn.setLocationAndAngles(d0, entityIn.posY, d1, 90.0F, 0.0F);
 
-            if (entityIn.isEntityAlive())
-            {
+            if (entityIn.isEntityAlive()) {
                 p_82448_3_.updateEntityWithOptionalForce(entityIn, false);
             }
+            */
         }
 
-        p_82448_3_.theProfiler.endSection();
+        // p_82448_3_.theProfiler.endSection();
 
         if (p_82448_2_ != 1)
         {
             p_82448_3_.theProfiler.startSection("placing");
             d0 = (double)MathHelper.clamp_int((int)d0, -29999872, 29999872);
             d1 = (double)MathHelper.clamp_int((int)d1, -29999872, 29999872);
+            /*
+            if (entityIn.isEntityAlive()) {
+                entityIn.setLocationAndAngles(d0, entityIn.posY, d1, entityIn.rotationYaw, entityIn.rotationPitch);
+                p_82448_4_.getDefaultTeleporter().placeInPortal(entityIn, f);
+                p_82448_4_.spawnEntityInWorld(entityIn);
+                p_82448_4_.updateEntityWithOptionalForce(entityIn, false);
+            }
 
+            p_82448_3_.theProfiler.endSection();
+            */
+        }
+
+        // entityIn.setWorld(p_82448_4_);
+        return new Location(p_82448_4_.getWorld(), d0, y, d1, yaw, pitch);
+    }
+
+    // copy of original a(Entity, int, WorldServer, WorldServer) method with only entity repositioning logic
+    // SpigotMCP Start -- Use mcp paramater names for the craftbukkit fake variables and arguments
+    public void repositionEntity(Entity entityIn, Location exit, boolean portal)
+    {
+        WorldServer p_82448_3_ = (WorldServer)entityIn.worldObj;
+        WorldServer p_82448_4_ = ((CraftWorld)exit.getWorld()).getHandle();
+        int p_82448_2_ = p_82448_3_.dimension;
+        // SpigotMCP End
+        /*
+        double d0 = entityIn.posX;
+        double d1 = entityIn.posZ;
+        double d2 = 8.0D;
+        float f = entityIn.rotationYaw;
+        p_82448_3_.theProfiler.startSection("moving");
+        */
+        entityIn.setLocationAndAngles(exit.getX(), exit.getY(), exit.getZ(), exit.getYaw(), exit.getPitch());
+
+        if (entityIn.isEntityAlive())
+        {
+            p_82448_3_.updateEntityWithOptionalForce(entityIn, false);
+        }
+
+        /*
+        if (p_82448_4_.dimension == -1) {
+            d0 = MathHelper.clamp_double(d0 / d2, p_82448_4_.getWorldBorder().minX() + 16.0D, p_82448_4_.getWorldBorder().maxX() - 16.0D);
+            d1 = MathHelper.clamp_double(d1 / d2, p_82448_4_.getWorldBorder().minZ() + 16.0D, p_82448_4_.getWorldBorder().maxZ() - 16.0D);
+            entityIn.setLocationAndAngles(d0, entityIn.posY, d1, entityIn.rotationYaw, entityIn.rotationPitch);
+
+            if (entityIn.isEntityAlive()) {
+                p_82448_3_.updateEntityWithOptionalForce(entityIn, false);
+            }
+        } else if (p_82448_4_.dimension == 0) {
+            d0 = MathHelper.clamp_double(d0 * d2, p_82448_4_.getWorldBorder().minX() + 16.0D, p_82448_4_.getWorldBorder().maxX() - 16.0D);
+            d1 = MathHelper.clamp_double(d1 * d2, p_82448_4_.getWorldBorder().minZ() + 16.0D, p_82448_4_.getWorldBorder().maxZ() - 16.0D);
+            entityIn.setLocationAndAngles(d0, entityIn.posY, d1, entityIn.rotationYaw, entityIn.rotationPitch);
+
+            if (entityIn.isEntityAlive()) {
+                p_82448_3_.updateEntityWithOptionalForce(entityIn, false);
+            }
+        } else {
+            BlockPos blockpos;
+
+            if (p_82448_2_ == 1) {
+                blockpos = p_82448_4_.getSpawnPoint();
+            } else {
+                blockpos = p_82448_4_.func_180504_m();
+            }
+
+            d0 = (double) blockpos.getX();
+            y = (double) blockpos.getY();
+            d1 = (double) blockpos.getZ();
+            entityIn.setLocationAndAngles(d0, entityIn.posY, d1, 90.0F, 0.0F);
+
+            if (entityIn.isEntityAlive()) {
+                p_82448_3_.updateEntityWithOptionalForce(entityIn, false);
+            }
+        }
+        */
+        // p_82448_3_.theProfiler.endSection();
+
+        if (p_82448_2_ != 1)
+        {
+            p_82448_3_.theProfiler.startSection("placing");
+
+            /*
+            d0 = (double) MathHelper.clamp_int((int) d0, -29999872, 29999872);
+            d1 = (double) MathHelper.clamp_int((int) d1, -29999872, 29999872);
+            */
             if (entityIn.isEntityAlive())
             {
-                entityIn.setLocationAndAngles(d0, entityIn.posY, d1, entityIn.rotationYaw, entityIn.rotationPitch);
-                p_82448_4_.getDefaultTeleporter().placeInPortal(entityIn, f);
+                // entityIn.setLocationAndAngles(d0, entityIn.posY, d1, entityIn.rotationYaw, entityIn.rotationPitch);
+                // p_82448_4_.getDefaultTeleporter().placeInPortal(entityIn, f);
+                if (portal)
+                {
+                    Vector velocity = entityIn.getBukkitEntity().getVelocity();
+                    p_82448_4_.getDefaultTeleporter().adjustExit(entityIn, exit, velocity);
+                    entityIn.setLocationAndAngles(exit.getX(), exit.getY(), exit.getZ(), exit.getYaw(), exit.getPitch());
+
+                    if (entityIn.motionX != velocity.getX() || entityIn.motionY != velocity.getY() || entityIn.motionZ != velocity.getZ())
+                    {
+                        entityIn.getBukkitEntity().setVelocity(velocity);
+                    }
+                }
+
                 p_82448_4_.spawnEntityInWorld(entityIn);
                 p_82448_4_.updateEntityWithOptionalForce(entityIn, false);
             }
 
             p_82448_3_.theProfiler.endSection();
         }
 
         entityIn.setWorld(p_82448_4_);
+        // CraftBukkit end
     }
 
     public void onTick()
     {
         if (++this.playerPingIndex > 600)
@@ -591,10 +1037,20 @@
         {
             ((EntityPlayerMP)this.playerEntityList.get(i)).playerNetServerHandler.sendPacket(packetIn);
         }
     }
 
+    // CraftBukkit start - add a world limited version
+    public void sendAll(Packet packet, World world)
+    {
+        for (int i = 0; i < world.playerEntities.size(); ++i)
+        {
+            ((EntityPlayerMP)this.playerEntityList.get(i)).playerNetServerHandler.sendPacket(packet);
+        }
+    }
+    // CraftBukkit end
+
     public void sendPacketToAllPlayersInDimension(Packet packetIn, int dimension)
     {
         for (int j = 0; j < this.playerEntityList.size(); ++j)
         {
             EntityPlayerMP entityplayermp = (EntityPlayerMP)this.playerEntityList.get(j);
@@ -702,25 +1158,43 @@
     }
 
     public void addOp(GameProfile profile)
     {
         this.ops.addEntry(new UserListOpsEntry(profile, this.mcServer.getOpPermissionLevel()));
+        // CraftBukkit start
+        Player player = mcServer.server.getPlayer(profile.getId());
+
+        if (player != null)
+        {
+            player.recalculatePermissions();
+        }
+
+        // CraftBukkit end
     }
 
     public void removeOp(GameProfile profile)
     {
         this.ops.removeEntry(profile);
+        // CraftBukkit start
+        Player player = mcServer.server.getPlayer(profile.getId());
+
+        if (player != null)
+        {
+            player.recalculatePermissions();
+        }
+
+        // CraftBukkit end
     }
 
     public boolean canJoin(GameProfile profile)
     {
         return !this.whiteListEnforced || this.ops.hasEntry(profile) || this.whiteListedPlayers.hasEntry(profile);
     }
 
     public boolean canSendCommands(GameProfile profile)
     {
-        return this.ops.hasEntry(profile) || this.mcServer.isSinglePlayer() && this.mcServer.worldServers[0].getWorldInfo().areCommandsAllowed() && this.mcServer.getServerOwner().equalsIgnoreCase(profile.getName()) || this.commandsAllowedForAll;
+        return this.ops.hasEntry(profile) || this.mcServer.isSinglePlayer() && this.mcServer.worlds.get(0).getWorldInfo().areCommandsAllowed() && this.mcServer.getServerOwner().equalsIgnoreCase(profile.getName()) || this.commandsAllowedForAll; // CraftBukkit
     }
 
     public EntityPlayerMP getPlayerByUsername(String username)
     {
         Iterator iterator = this.playerEntityList.iterator();
@@ -749,10 +1223,18 @@
     {
         for (int j = 0; j < this.playerEntityList.size(); ++j)
         {
             EntityPlayerMP entityplayermp = (EntityPlayerMP)this.playerEntityList.get(j);
 
+            // CraftBukkit start - Test if player receiving packet can see the source of the packet
+            if (p_148543_1_ != null && p_148543_1_ instanceof EntityPlayerMP && !entityplayermp.getBukkitEntity().canSee(((EntityPlayerMP)p_148543_1_).getBukkitEntity()))
+            {
+                continue;
+            }
+
+            // CraftBukkit end
+
             if (entityplayermp != p_148543_1_ && entityplayermp.dimension == dimension)
             {
                 double d4 = x - entityplayermp.posX;
                 double d5 = y - entityplayermp.posY;
                 double d6 = z - entityplayermp.posZ;
@@ -801,30 +1283,37 @@
     public String[] getOppedPlayerNames()
     {
         return this.ops.getKeys();
     }
 
-    public void loadWhiteList() {}
+    public void loadWhiteList()
+    {
+    }
 
     public void updateTimeAndWeatherForPlayer(EntityPlayerMP playerIn, WorldServer worldIn)
     {
-        WorldBorder worldborder = this.mcServer.worldServers[0].getWorldBorder();
+        WorldBorder worldborder = playerIn.worldObj.getWorldBorder(); // CraftBukkit
         playerIn.playerNetServerHandler.sendPacket(new S44PacketWorldBorder(worldborder, S44PacketWorldBorder.Action.INITIALIZE));
         playerIn.playerNetServerHandler.sendPacket(new S03PacketTimeUpdate(worldIn.getTotalWorldTime(), worldIn.getWorldTime(), worldIn.getGameRules().getGameRuleBooleanValue("doDaylightCycle")));
 
         if (worldIn.isRaining())
         {
-            playerIn.playerNetServerHandler.sendPacket(new S2BPacketChangeGameState(1, 0.0F));
-            playerIn.playerNetServerHandler.sendPacket(new S2BPacketChangeGameState(7, worldIn.getRainStrength(1.0F)));
-            playerIn.playerNetServerHandler.sendPacket(new S2BPacketChangeGameState(8, worldIn.getThunderStrength(1.0F)));
+            // CraftBukkit start - handle player weather
+            // playerIn.playerNetServerHandler.sendPacket(new S2BPacketChangeGameState(1, 0.0F));
+            // playerIn.playerNetServerHandler.sendPacket(new S2BPacketChangeGameState(7, worldIn.getRainStrength(1.0F)));
+            // playerIn.playerNetServerHandler.sendPacket(new S2BPacketChangeGameState(8, worldIn.getThunderStrength(1.0F)));
+            playerIn.setPlayerWeather(WeatherType.DOWNFALL, false);
+            playerIn.updateWeather(-worldIn.rainingStrength, worldIn.rainingStrength, -worldIn.rainingStrength, worldIn.rainingStrength);
+            // CraftBukkit end
         }
     }
 
     public void syncPlayerInventory(EntityPlayerMP playerIn)
     {
         playerIn.sendContainerToPlayer(playerIn.inventoryContainer);
-        playerIn.setPlayerHealthUpdated();
+        // playerIn.setPlayerHealthUpdated();
+        playerIn.getBukkitEntity().updateScaledHealth(); // CraftBukkit - Update scaled health on respawn and worldchange
         playerIn.playerNetServerHandler.sendPacket(new S09PacketHeldItemChange(playerIn.inventory.currentItem));
     }
 
     public int getCurrentPlayerCount()
     {
@@ -836,11 +1325,11 @@
         return this.maxPlayers;
     }
 
     public String[] getAvailablePlayerDat()
     {
-        return this.mcServer.worldServers[0].getSaveHandler().getPlayerNBTManager().getAvailablePlayerDat();
+        return this.mcServer.worlds.get(0).getSaveHandler().getPlayerNBTManager().getAvailablePlayerDat(); // CraftBukkit
     }
 
     public void setWhiteListEnabled(boolean whitelistEnabled)
     {
         this.whiteListEnforced = whitelistEnabled;
@@ -877,16 +1366,10 @@
     public NBTTagCompound getHostPlayerData()
     {
         return null;
     }
 
-    @SideOnly(Side.CLIENT)
-    public void setGameType(WorldSettings.GameType p_152604_1_)
-    {
-        this.gameType = p_152604_1_;
-    }
-
     private void func_72381_a(EntityPlayerMP p_72381_1_, EntityPlayerMP p_72381_2_, World worldIn)
     {
         if (p_72381_2_ != null)
         {
             p_72381_1_.theItemInWorldManager.setGameType(p_72381_2_.theItemInWorldManager.getGameType());
@@ -897,29 +1380,35 @@
         }
 
         p_72381_1_.theItemInWorldManager.initializeGameType(worldIn.getWorldInfo().getGameType());
     }
 
-    @SideOnly(Side.CLIENT)
-    public void setCommandsAllowedForAll(boolean p_72387_1_)
+    public void removeAllPlayers()
     {
-        this.commandsAllowedForAll = p_72387_1_;
+        for (int i = 0; i < this.playerEntityList.size(); ++i)
+        {
+            ((EntityPlayerMP)this.playerEntityList.get(i)).playerNetServerHandler.kickPlayerFromServer(this.mcServer.server.getShutdownMessage()); // CraftBukkit - add custom shutdown message
+        }
     }
 
-    public void removeAllPlayers()
+    // CraftBukkit start
+    public void sendMessage(IChatComponent[] iChatBaseComponents)
     {
-        for (int i = 0; i < this.playerEntityList.size(); ++i)
+        for (IChatComponent component : iChatBaseComponents)
         {
-            ((EntityPlayerMP)this.playerEntityList.get(i)).playerNetServerHandler.kickPlayerFromServer("Server closed");
+            sendChatMsgImpl(component, true);
         }
     }
+    // CraftBukkit end
 
     public void sendChatMsgImpl(IChatComponent component, boolean isChat)
     {
         this.mcServer.addChatMessage(component);
         int i = isChat ? 1 : 0;
-        this.sendPacketToAllPlayers(new S02PacketChat(component, (byte)i));
+        // CraftBukkit start - we run this through our processor first so we can get web links etc
+        this.sendPacketToAllPlayers(new S02PacketChat(CraftChatMessage.fixComponent(component), (byte)i));
+        // CraftBukkit end
     }
 
     public void sendChatMsg(IChatComponent component)
     {
         this.sendChatMsgImpl(component, true);
@@ -957,16 +1446,15 @@
     {
         this.viewDistance = distance;
 
         if (this.mcServer.worldServers != null)
         {
-            WorldServer[] aworldserver = this.mcServer.worldServers;
-            int j = aworldserver.length;
-
-            for (int k = 0; k < j; ++k)
+            // CraftBukkit start
+            for (int k = 0; k < mcServer.worlds.size(); ++k)
             {
-                WorldServer worldserver = aworldserver[k];
+                WorldServer worldserver = mcServer.worlds.get(0);
+                // CraftBukkit end
 
                 if (worldserver != null)
                 {
                     worldserver.getPlayerManager().setPlayerViewRadius(distance);
                 }
@@ -977,11 +1465,10 @@
     public EntityPlayerMP getPlayerByUUID(UUID playerUUID)
     {
         return (EntityPlayerMP)this.uuidToPlayerMap.get(playerUUID);
     }
 
-    @SideOnly(Side.SERVER)
     public boolean isWhiteListEnabled()
     {
         return this.whiteListEnforced;
     }
 }
