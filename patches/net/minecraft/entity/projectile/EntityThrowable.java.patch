---a/net/minecraft/entity/projectile/EntityThrowable.java
+++b/net/minecraft/entity/projectile/EntityThrowable.java
@@ -1,6 +1,7 @@
 package net.minecraft.entity.projectile;
 
 import java.util.List;
+
 import net.minecraft.block.Block;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityLivingBase;
@@ -16,130 +16,96 @@
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.Vec3;
 import net.minecraft.world.World;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
 
-public abstract class EntityThrowable extends Entity implements IProjectile
-{
+
+public abstract class EntityThrowable extends Entity implements IProjectile {
+
     private int xTile = -1;
     private int yTile = -1;
     private int zTile = -1;
     private Block inTile;
     protected boolean inGround;
     public int throwableShake;
-    private EntityLivingBase thrower;
-    private String throwerName;
+    public EntityLivingBase thrower; // SpigotMCP -- Apply access transformation
+    public String throwerName; // SpigotMCP -- Apply access transformation
     private int ticksInGround;
     private int ticksInAir;
     private static final String __OBFID = "CL_00001723";
 
-    public EntityThrowable(World worldIn)
-    {
+    public EntityThrowable(World worldIn) {
         super(worldIn);
         this.setSize(0.25F, 0.25F);
     }
 
-    protected void entityInit() {}
-
-    @SideOnly(Side.CLIENT)
-    public boolean isInRangeToRenderDist(double distance)
-    {
-        double d1 = this.getEntityBoundingBox().getAverageEdgeLength() * 4.0D;
-        d1 *= 64.0D;
-        return distance < d1 * d1;
+    protected void entityInit() {
     }
 
-    public EntityThrowable(World worldIn, EntityLivingBase throwerIn)
-    {
+    public EntityThrowable(World worldIn, EntityLivingBase throwerIn) {
         super(worldIn);
         this.thrower = throwerIn;
+        this.projectileSource = (org.bukkit.entity.LivingEntity) throwerIn.getBukkitEntity(); // CraftBukkit
         this.setSize(0.25F, 0.25F);
-        this.setLocationAndAngles(throwerIn.posX, throwerIn.posY + (double)throwerIn.getEyeHeight(), throwerIn.posZ, throwerIn.rotationYaw, throwerIn.rotationPitch);
-        this.posX -= (double)(MathHelper.cos(this.rotationYaw / 180.0F * (float)Math.PI) * 0.16F);
+        this.setLocationAndAngles(throwerIn.posX, throwerIn.posY + (double) throwerIn.getEyeHeight(), throwerIn.posZ, throwerIn.rotationYaw, throwerIn.rotationPitch);
+        this.posX -= (double) (MathHelper.cos(this.rotationYaw / 180.0F * (float) Math.PI) * 0.16F);
         this.posY -= 0.10000000149011612D;
-        this.posZ -= (double)(MathHelper.sin(this.rotationYaw / 180.0F * (float)Math.PI) * 0.16F);
+        this.posZ -= (double) (MathHelper.sin(this.rotationYaw / 180.0F * (float) Math.PI) * 0.16F);
         this.setPosition(this.posX, this.posY, this.posZ);
         float f = 0.4F;
-        this.motionX = (double)(-MathHelper.sin(this.rotationYaw / 180.0F * (float)Math.PI) * MathHelper.cos(this.rotationPitch / 180.0F * (float)Math.PI) * f);
-        this.motionZ = (double)(MathHelper.cos(this.rotationYaw / 180.0F * (float)Math.PI) * MathHelper.cos(this.rotationPitch / 180.0F * (float)Math.PI) * f);
-        this.motionY = (double)(-MathHelper.sin((this.rotationPitch + this.getInaccuracy()) / 180.0F * (float)Math.PI) * f);
+        this.motionX = (double) (-MathHelper.sin(this.rotationYaw / 180.0F * (float) Math.PI) * MathHelper.cos(this.rotationPitch / 180.0F * (float) Math.PI) * f);
+        this.motionZ = (double) (MathHelper.cos(this.rotationYaw / 180.0F * (float) Math.PI) * MathHelper.cos(this.rotationPitch / 180.0F * (float) Math.PI) * f);
+        this.motionY = (double) (-MathHelper.sin((this.rotationPitch + this.getInaccuracy()) / 180.0F * (float) Math.PI) * f);
         this.setThrowableHeading(this.motionX, this.motionY, this.motionZ, this.getVelocity(), 1.0F);
     }
 
-    public EntityThrowable(World worldIn, double x, double y, double p_i1778_6_)
-    {
+    public EntityThrowable(World worldIn, double x, double y, double p_i1778_6_) {
         super(worldIn);
         this.ticksInGround = 0;
         this.setSize(0.25F, 0.25F);
         this.setPosition(x, y, p_i1778_6_);
     }
 
-    protected float getVelocity()
-    {
+    protected float getVelocity() {
         return 1.5F;
     }
 
-    protected float getInaccuracy()
-    {
+    protected float getInaccuracy() {
         return 0.0F;
     }
 
-    public void setThrowableHeading(double x, double y, double z, float velocity, float inaccuracy)
-    {
+    public void setThrowableHeading(double x, double y, double z, float velocity, float inaccuracy) {
         float f2 = MathHelper.sqrt_double(x * x + y * y + z * z);
-        x /= (double)f2;
-        y /= (double)f2;
-        z /= (double)f2;
-        x += this.rand.nextGaussian() * 0.007499999832361937D * (double)inaccuracy;
-        y += this.rand.nextGaussian() * 0.007499999832361937D * (double)inaccuracy;
-        z += this.rand.nextGaussian() * 0.007499999832361937D * (double)inaccuracy;
-        x *= (double)velocity;
-        y *= (double)velocity;
-        z *= (double)velocity;
+        x /= (double) f2;
+        y /= (double) f2;
+        z /= (double) f2;
+        x += this.rand.nextGaussian() * 0.007499999832361937D * (double) inaccuracy;
+        y += this.rand.nextGaussian() * 0.007499999832361937D * (double) inaccuracy;
+        z += this.rand.nextGaussian() * 0.007499999832361937D * (double) inaccuracy;
+        x *= (double) velocity;
+        y *= (double) velocity;
+        z *= (double) velocity;
         this.motionX = x;
         this.motionY = y;
         this.motionZ = z;
         float f3 = MathHelper.sqrt_double(x * x + z * z);
-        this.prevRotationYaw = this.rotationYaw = (float)(Math.atan2(x, z) * 180.0D / Math.PI);
-        this.prevRotationPitch = this.rotationPitch = (float)(Math.atan2(y, (double)f3) * 180.0D / Math.PI);
+        this.prevRotationYaw = this.rotationYaw = (float) (Math.atan2(x, z) * 180.0D / Math.PI);
+        this.prevRotationPitch = this.rotationPitch = (float) (Math.atan2(y, (double) f3) * 180.0D / Math.PI);
         this.ticksInGround = 0;
     }
 
-    @SideOnly(Side.CLIENT)
-    public void setVelocity(double x, double y, double z)
-    {
-        this.motionX = x;
-        this.motionY = y;
-        this.motionZ = z;
-
-        if (this.prevRotationPitch == 0.0F && this.prevRotationYaw == 0.0F)
-        {
-            float f = MathHelper.sqrt_double(x * x + z * z);
-            this.prevRotationYaw = this.rotationYaw = (float)(Math.atan2(x, z) * 180.0D / Math.PI);
-            this.prevRotationPitch = this.rotationPitch = (float)(Math.atan2(y, (double)f) * 180.0D / Math.PI);
-        }
-    }
-
-    public void onUpdate()
-    {
+    public void onUpdate() {
         this.lastTickPosX = this.posX;
         this.lastTickPosY = this.posY;
         this.lastTickPosZ = this.posZ;
         super.onUpdate();
 
-        if (this.throwableShake > 0)
-        {
+        if (this.throwableShake > 0) {
             --this.throwableShake;
         }
 
-        if (this.inGround)
-        {
-            if (this.worldObj.getBlockState(new BlockPos(this.xTile, this.yTile, this.zTile)).getBlock() == this.inTile)
-            {
+        if (this.inGround) {
+            if (this.worldObj.getBlockState(new BlockPos(this.xTile, this.yTile, this.zTile)).getBlock() == this.inTile) {
                 ++this.ticksInGround;
 
-                if (this.ticksInGround == 1200)
-                {
+                if (this.ticksInGround == 1200) {
                     this.setDead();
                 }
 
@@ -147,14 +147,14 @@
             }
 
             this.inGround = false;
-            this.motionX *= (double)(this.rand.nextFloat() * 0.2F);
-            this.motionY *= (double)(this.rand.nextFloat() * 0.2F);
-            this.motionZ *= (double)(this.rand.nextFloat() * 0.2F);
+            this.motionX *= (double) (this.rand.nextFloat() * 0.2F);
+            this.motionY *= (double) (this.rand.nextFloat() * 0.2F);
+            this.motionZ *= (double) (this.rand.nextFloat() * 0.2F);
             this.ticksInGround = 0;
             this.ticksInAir = 0;
-        }
-        else
-        {
+        } else {
             ++this.ticksInAir;
         }
 
@@ -164,34 +164,28 @@
         vec3 = new Vec3(this.posX, this.posY, this.posZ);
         vec31 = new Vec3(this.posX + this.motionX, this.posY + this.motionY, this.posZ + this.motionZ);
 
-        if (movingobjectposition != null)
-        {
+        if (movingobjectposition != null) {
             vec31 = new Vec3(movingobjectposition.hitVec.xCoord, movingobjectposition.hitVec.yCoord, movingobjectposition.hitVec.zCoord);
         }
 
-        if (!this.worldObj.isRemote)
-        {
+        if (!this.worldObj.isRemote) {
             Entity entity = null;
             List list = this.worldObj.getEntitiesWithinAABBExcludingEntity(this, this.getEntityBoundingBox().addCoord(this.motionX, this.motionY, this.motionZ).expand(1.0D, 1.0D, 1.0D));
             double d0 = 0.0D;
             EntityLivingBase entitylivingbase = this.getThrower();
 
-            for (int j = 0; j < list.size(); ++j)
-            {
-                Entity entity1 = (Entity)list.get(j);
+            for (int j = 0; j < list.size(); ++j) {
+                Entity entity1 = (Entity) list.get(j);
 
-                if (entity1.canBeCollidedWith() && (entity1 != entitylivingbase || this.ticksInAir >= 5))
-                {
+                if (entity1.canBeCollidedWith() && (entity1 != entitylivingbase || this.ticksInAir >= 5)) {
                     float f = 0.3F;
-                    AxisAlignedBB axisalignedbb = entity1.getEntityBoundingBox().expand((double)f, (double)f, (double)f);
+                    AxisAlignedBB axisalignedbb = entity1.getEntityBoundingBox().expand((double) f, (double) f, (double) f);
                     MovingObjectPosition movingobjectposition1 = axisalignedbb.calculateIntercept(vec3, vec31);
 
-                    if (movingobjectposition1 != null)
-                    {
-                        double d1 = vec3.distanceTo(movingobjectposition1.hitVec);
+                    if (movingobjectposition1 != null) {
+                        double d1 = vec3.squareDistanceTo(movingobjectposition1.hitVec); // CraftBukkit - distance efficiency
 
-                        if (d1 < d0 || d0 == 0.0D)
-                        {
+                        if (d1 < d0 || d0 == 0.0D) {
                             entity = entity1;
                             d0 = d1;
                         }
@@ -199,23 +199,17 @@
                 }
             }
 
-            if (entity != null)
-            {
+            if (entity != null) {
                 movingobjectposition = new MovingObjectPosition(entity);
             }
         }
 
-        if (movingobjectposition != null)
-        {
-            if (movingobjectposition.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK && this.worldObj.getBlockState(movingobjectposition.getBlockPos()).getBlock() == Blocks.portal)
-            {
+        if (movingobjectposition != null) {
+            if (movingobjectposition.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK && this.worldObj.getBlockState(movingobjectposition.getBlockPos()).getBlock() == Blocks.portal) {
                 this.setInPortal();
-            }
-            else
-            {
+            } else {
                 this.onImpact(movingobjectposition);
+                // CraftBukkit start
+                if (this.isDead) {
+                    org.bukkit.craftbukkit.event.CraftEventFactory.callProjectileHitEvent(this);
+                }
+                // CraftBukkit end
             }
         }
 
@@ -221,24 +221,21 @@
         this.posY += this.motionY;
         this.posZ += this.motionZ;
         float f1 = MathHelper.sqrt_double(this.motionX * this.motionX + this.motionZ * this.motionZ);
-        this.rotationYaw = (float)(Math.atan2(this.motionX, this.motionZ) * 180.0D / Math.PI);
+        this.rotationYaw = (float) (Math.atan2(this.motionX, this.motionZ) * 180.0D / Math.PI);
 
-        for (this.rotationPitch = (float)(Math.atan2(this.motionY, (double)f1) * 180.0D / Math.PI); this.rotationPitch - this.prevRotationPitch < -180.0F; this.prevRotationPitch -= 360.0F)
-        {
+        for (this.rotationPitch = (float) (Math.atan2(this.motionY, (double) f1) * 180.0D / Math.PI); this.rotationPitch - this.prevRotationPitch < -180.0F; this.prevRotationPitch -= 360.0F) {
             ;
         }
 
-        while (this.rotationPitch - this.prevRotationPitch >= 180.0F)
-        {
+        while (this.rotationPitch - this.prevRotationPitch >= 180.0F) {
             this.prevRotationPitch += 360.0F;
         }
 
-        while (this.rotationYaw - this.prevRotationYaw < -180.0F)
-        {
+        while (this.rotationYaw - this.prevRotationYaw < -180.0F) {
             this.prevRotationYaw -= 360.0F;
         }
 
-        while (this.rotationYaw - this.prevRotationYaw >= 180.0F)
-        {
+        while (this.rotationYaw - this.prevRotationYaw >= 180.0F) {
             this.prevRotationYaw += 360.0F;
         }
 
@@ -248,62 +248,53 @@
         float f2 = 0.99F;
         float f3 = this.getGravityVelocity();
 
-        if (this.isInWater())
-        {
-            for (int i = 0; i < 4; ++i)
-            {
+        if (this.isInWater()) {
+            for (int i = 0; i < 4; ++i) {
                 float f4 = 0.25F;
-                this.worldObj.spawnParticle(EnumParticleTypes.WATER_BUBBLE, this.posX - this.motionX * (double)f4, this.posY - this.motionY * (double)f4, this.posZ - this.motionZ * (double)f4, this.motionX, this.motionY, this.motionZ, new int[0]);
+                this.worldObj.spawnParticle(EnumParticleTypes.WATER_BUBBLE, this.posX - this.motionX * (double) f4, this.posY - this.motionY * (double) f4, this.posZ - this.motionZ * (double) f4, this.motionX, this.motionY, this.motionZ, new int[0]);
             }
 
             f2 = 0.8F;
         }
 
-        this.motionX *= (double)f2;
-        this.motionY *= (double)f2;
-        this.motionZ *= (double)f2;
-        this.motionY -= (double)f3;
+        this.motionX *= (double) f2;
+        this.motionY *= (double) f2;
+        this.motionZ *= (double) f2;
+        this.motionY -= (double) f3;
         this.setPosition(this.posX, this.posY, this.posZ);
     }
 
-    protected float getGravityVelocity()
-    {
+    protected float getGravityVelocity() {
         return 0.03F;
     }
 
     protected abstract void onImpact(MovingObjectPosition p_70184_1_);
 
-    public void writeEntityToNBT(NBTTagCompound tagCompound)
-    {
-        tagCompound.setShort("xTile", (short)this.xTile);
-        tagCompound.setShort("yTile", (short)this.yTile);
-        tagCompound.setShort("zTile", (short)this.zTile);
-        ResourceLocation resourcelocation = (ResourceLocation)Block.blockRegistry.getNameForObject(this.inTile);
+    public void writeEntityToNBT(NBTTagCompound tagCompound) {
+        tagCompound.setShort("xTile", (short) this.xTile);
+        tagCompound.setShort("yTile", (short) this.yTile);
+        tagCompound.setShort("zTile", (short) this.zTile);
+        ResourceLocation resourcelocation = (ResourceLocation) Block.blockRegistry.getNameForObject(this.inTile);
         tagCompound.setString("inTile", resourcelocation == null ? "" : resourcelocation.toString());
-        tagCompound.setByte("shake", (byte)this.throwableShake);
-        tagCompound.setByte("inGround", (byte)(this.inGround ? 1 : 0));
+        tagCompound.setByte("shake", (byte) this.throwableShake);
+        tagCompound.setByte("inGround", (byte) (this.inGround ? 1 : 0));
 
-        if ((this.throwerName == null || this.throwerName.length() == 0) && this.thrower instanceof EntityPlayer)
-        {
+        if ((this.throwerName == null || this.throwerName.length() == 0) && this.thrower instanceof EntityPlayer) {
             this.throwerName = this.thrower.getName();
         }
 
         tagCompound.setString("ownerName", this.throwerName == null ? "" : this.throwerName);
     }
 
-    public void readEntityFromNBT(NBTTagCompound tagCompund)
-    {
+    public void readEntityFromNBT(NBTTagCompound tagCompund) {
         this.xTile = tagCompund.getShort("xTile");
         this.yTile = tagCompund.getShort("yTile");
         this.zTile = tagCompund.getShort("zTile");
 
-        if (tagCompund.hasKey("inTile", 8))
-        {
+        if (tagCompund.hasKey("inTile", 8)) {
             this.inTile = Block.getBlockFromName(tagCompund.getString("inTile"));
-        }
-        else
-        {
+        } else {
             this.inTile = Block.getBlockById(tagCompund.getByte("inTile") & 255);
         }
 
@@ -310,20 +310,16 @@
         this.inGround = tagCompund.getByte("inGround") == 1;
         this.throwerName = tagCompund.getString("ownerName");
 
-        if (this.throwerName != null && this.throwerName.length() == 0)
-        {
+        if (this.throwerName != null && this.throwerName.length() == 0) {
             this.throwerName = null;
         }
     }
 
-    public EntityLivingBase getThrower()
-    {
-        if (this.thrower == null && this.throwerName != null && this.throwerName.length() > 0)
-        {
+    public EntityLivingBase getThrower() {
+        if (this.thrower == null && this.throwerName != null && this.throwerName.length() > 0) {
             this.thrower = this.worldObj.getPlayerEntityByName(this.throwerName);
         }
 
         return this.thrower;
     }
-}
+}
