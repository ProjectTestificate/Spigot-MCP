--- decompiled\net\minecraft\entity\Entity.java
+++ src\main\java\net\minecraft\entity\Entity.java
@@ -3,10 +3,11 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
 import java.util.UUID;
 import java.util.concurrent.Callable;
+
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockFence;
 import net.minecraft.block.BlockFenceGate;
 import net.minecraft.block.BlockLiquid;
 import net.minecraft.block.BlockWall;
@@ -18,10 +19,11 @@
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.enchantment.EnchantmentHelper;
 import net.minecraft.enchantment.EnchantmentProtection;
 import net.minecraft.entity.effect.EntityLightningBolt;
 import net.minecraft.entity.item.EntityItem;
+import net.minecraft.entity.passive.EntityTameable;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.event.HoverEvent;
 import net.minecraft.init.Blocks;
 import net.minecraft.item.Item;
@@ -37,22 +39,57 @@
 import net.minecraft.util.DamageSource;
 import net.minecraft.util.EnumFacing;
 import net.minecraft.util.EnumParticleTypes;
 import net.minecraft.util.IChatComponent;
 import net.minecraft.util.MathHelper;
-import net.minecraft.util.MovingObjectPosition;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.StatCollector;
 import net.minecraft.util.Vec3;
 import net.minecraft.world.Explosion;
 import net.minecraft.world.World;
 import net.minecraft.world.WorldServer;
-import net.minecraftforge.fml.relauncher.Side;
-import net.minecraftforge.fml.relauncher.SideOnly;
 
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.Server;
+import org.bukkit.TravelAgent;
+import org.bukkit.block.BlockFace;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.entity.Hanging;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.Painting;
+import org.bukkit.entity.Vehicle;
+import org.bukkit.event.entity.EntityCombustByBlockEvent;
+import org.bukkit.event.entity.EntityCombustByEntityEvent;
+import org.bukkit.event.entity.EntityCombustEvent;
+import org.bukkit.event.entity.EntityPortalEvent;
+import org.bukkit.event.hanging.HangingBreakByEntityEvent;
+import org.bukkit.event.painting.PaintingBreakByEntityEvent;
+import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
+import org.bukkit.event.vehicle.VehicleEnterEvent;
+import org.bukkit.event.vehicle.VehicleExitEvent;
+import org.bukkit.plugin.PluginManager;
+import org.bukkit.projectiles.ProjectileSource;
+import org.spigotmc.CustomTimingsHandler;
+import org.spigotmc.event.entity.EntityDismountEvent;
+import org.spigotmc.event.entity.EntityMountEvent;
+
 public abstract class Entity implements ICommandSender
 {
+
+    // CraftBukkit start
+    private static final int CURRENT_LEVEL = 2;
+
+    static boolean isLevelAtLeast(NBTTagCompound tag, int level)
+    {
+        return tag.hasKey("Bukkit.updateLevel") && tag.getInteger("Bukkit.updateLevel") >= level;
+    }
+    // CraftBukikt end
+
     private static final AxisAlignedBB ZERO_AABB = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
     private static int nextEntityID;
     private int entityId;
     public double renderDistanceWeight;
     public boolean preventEntitySpawning;
@@ -96,40 +133,54 @@
     public boolean noClip;
     public float entityCollisionReduction;
     protected Random rand;
     public int ticksExisted;
     public int fireResistance;
-    private int fire;
-    protected boolean inWater;
+    public int fire; // SpigotMCP -- Apply access transformation
+    public boolean inWater; // Spigot - protected -> public
     public int hurtResistantTime;
     protected boolean firstUpdate;
     protected boolean isImmuneToFire;
-    protected DataWatcher dataWatcher;
+    public DataWatcher dataWatcher; // SpigotMCP -- make public as bukkit assumes in same package
     private double entityRiderPitchDelta;
     private double entityRiderYawDelta;
     public boolean addedToChunk;
+
+    public boolean isAddedToChunk()
+    {
+        return addedToChunk;
+    } // Spigot
+
     public int chunkCoordX;
     public int chunkCoordY;
     public int chunkCoordZ;
-    @SideOnly(Side.CLIENT)
-    public int serverPosX;
-    @SideOnly(Side.CLIENT)
-    public int serverPosY;
-    @SideOnly(Side.CLIENT)
-    public int serverPosZ;
     public boolean ignoreFrustumCheck;
     public boolean isAirBorne;
     public int timeUntilPortal;
     protected boolean inPortal;
     protected int portalCounter;
     public int dimension;
     protected int teleportDirection;
     private boolean invulnerable;
     protected UUID entityUniqueID;
     private final CommandResultStats cmdResultStats;
+    public boolean valid; // CraftBukkit
+    public ProjectileSource projectileSource; // CraftBukkit - For projectiles only
     private static final String __OBFID = "CL_00001533";
 
+    // Spigot start
+    public CustomTimingsHandler tickTimer = org.bukkit.craftbukkit.SpigotTimings.getEntityTimings(this); // Spigot
+    public final byte activationType = org.spigotmc.ActivationRange.initializeEntityActivationType(this);
+    public final boolean defaultActivationState;
+    public long activatedTick = Integer.MIN_VALUE;
+    public boolean fromMobSpawner;
+
+    public void inactiveTick()
+    {
+    }
+    // Spigot end
+
     public int getEntityId()
     {
         return this.entityId;
     }
 
@@ -160,12 +211,19 @@
         this.setPosition(0.0D, 0.0D, 0.0D);
 
         if (worldIn != null)
         {
             this.dimension = worldIn.provider.getDimensionId();
+            // Spigot start
+            this.defaultActivationState = org.spigotmc.ActivationRange.initializeEntityActivationState(this, worldIn.spigotConfig);
         }
+        else
+        {
+            this.defaultActivationState = false;
+        }
 
+        // Spigot end
         this.dataWatcher = new DataWatcher(this);
         this.dataWatcher.addObject(0, Byte.valueOf((byte)0));
         this.dataWatcher.addObject(1, Short.valueOf((short)300));
         this.dataWatcher.addObject(3, Byte.valueOf((byte)0));
         this.dataWatcher.addObject(2, "");
@@ -188,38 +246,17 @@
     public int hashCode()
     {
         return this.entityId;
     }
 
-    @SideOnly(Side.CLIENT)
-    protected void preparePlayerToSpawn()
-    {
-        if (this.worldObj != null)
-        {
-            while (this.posY > 0.0D && this.posY < 256.0D)
-            {
-                this.setPosition(this.posX, this.posY, this.posZ);
-
-                if (this.worldObj.getCollidingBoundingBoxes(this, this.getEntityBoundingBox()).isEmpty())
-                {
-                    break;
-                }
-
-                ++this.posY;
-            }
-
-            this.motionX = this.motionY = this.motionZ = 0.0D;
-            this.rotationPitch = 0.0F;
-        }
-    }
-
     public void setDead()
     {
         this.isDead = true;
     }
 
-    protected void setSize(float width, float height)
+    // PAIL: Access + rename please
+    public void setSize(float width, float height) // CraftBukkit - protected to public
     {
         if (width != this.width || height != this.height)
         {
             float f2 = this.width;
             this.width = width;
@@ -231,12 +268,47 @@
                 this.moveEntity((double)(f2 - this.width), 0.0D, (double)(f2 - this.width));
             }
         }
     }
 
-    protected void setRotation(float yaw, float pitch)
+    public void setRotation(float yaw, float pitch)   // SpigotMCP -- Make public as bukkit assumes in the same package
     {
+        // CraftBukkit start - yaw was sometimes set to NaN, so we need to set it back to 0
+        if (Float.isNaN(yaw))
+        {
+            yaw = 0;
+        }
+
+        if (yaw == Float.POSITIVE_INFINITY || yaw == Float.NEGATIVE_INFINITY)
+        {
+            if (this instanceof EntityPlayer)
+            {
+                this.worldObj.getServer().getLogger().warning(this.getName() + " was caught trying to crash the server with an invalid yaw");
+                ((CraftPlayer)this.getBukkitEntity()).kickPlayer("Infinite yaw (Hacking?)"); //Spigot "Nope" -> Descriptive reason
+            }
+
+            yaw = 0;
+        }
+
+        // pitch was sometimes set to NaN, so we need to set it back to 0
+        if (Float.isNaN(pitch))
+        {
+            pitch = 0;
+        }
+
+        if (pitch == Float.POSITIVE_INFINITY || pitch == Float.NEGATIVE_INFINITY)
+        {
+            if (this instanceof EntityPlayer)
+            {
+                this.worldObj.getServer().getLogger().warning(this.getName() + " was caught trying to crash the server with an invalid pitch");
+                ((CraftPlayer)this.getBukkitEntity()).kickPlayer("Infinite pitch (Hacking?)"); //Spigot "Nope" -> Descriptive reason
+            }
+
+            pitch = 0;
+        }
+
+        // CraftBukkit end
         this.rotationYaw = yaw % 360.0F;
         this.rotationPitch = pitch % 360.0F;
     }
 
     public void setPosition(double x, double y, double z)
@@ -247,22 +319,10 @@
         float f = this.width / 2.0F;
         float f1 = this.height;
         this.setEntityBoundingBox(new AxisAlignedBB(x - (double)f, y, z - (double)f, x + (double)f, y + (double)f1, z + (double)f));
     }
 
-    @SideOnly(Side.CLIENT)
-    public void setAngles(float yaw, float pitch)
-    {
-        float f2 = this.rotationPitch;
-        float f3 = this.rotationYaw;
-        this.rotationYaw = (float)((double)this.rotationYaw + (double)yaw * 0.15D);
-        this.rotationPitch = (float)((double)this.rotationPitch - (double)pitch * 0.15D);
-        this.rotationPitch = MathHelper.clamp_float(this.rotationPitch, -90.0F, 90.0F);
-        this.prevRotationPitch += this.rotationPitch - f2;
-        this.prevRotationYaw += this.rotationYaw - f3;
-    }
-
     public void onUpdate()
     {
         this.onEntityUpdate();
     }
 
@@ -288,11 +348,11 @@
             MinecraftServer minecraftserver = ((WorldServer)this.worldObj).getMinecraftServer();
             int i = this.getMaxInPortalTime();
 
             if (this.inPortal)
             {
-                if (minecraftserver.getAllowNether())
+                if (true || minecraftserver.getAllowNether()) // CraftBukkit
                 {
                     if (this.ridingEntity == null && this.portalCounter++ >= i)
                     {
                         this.portalCounter = i;
                         this.timeUntilPortal = this.getPortalCooldown();
@@ -391,10 +451,38 @@
     protected void setOnFireFromLava()
     {
         if (!this.isImmuneToFire)
         {
             this.attackEntityFrom(DamageSource.lava, 4.0F);
+
+            // CraftBukkit start - Fallen in lava TODO: this event spams!
+            if (this instanceof EntityLivingBase)
+            {
+                if (fire <= 0)
+                {
+                    // not on fire yet
+                    // TODO: shouldn't be sending null for the block
+                    org.bukkit.block.Block damager = null; // ((WorldServer) this.l).getWorld().getBlockAt(i, j, k);
+                    org.bukkit.entity.Entity damagee = this.getBukkitEntity();
+                    EntityCombustEvent combustEvent = new EntityCombustByBlockEvent(damager, damagee, 15);
+                    this.worldObj.getServer().getPluginManager().callEvent(combustEvent);
+
+                    if (!combustEvent.isCancelled())
+                    {
+                        this.setFire(combustEvent.getDuration());
+                    }
+                }
+                else
+                {
+                    // This will be called every single tick the entity is in lava, so don't throw an event
+                    this.setFire(15);
+                }
+
+                return;
+            }
+
+            // CraftBukkit end - we also don't throw an event unless the object in lava is living, to save on some event calls
             this.setFire(15);
         }
     }
 
     public void setFire(int seconds)
@@ -429,17 +517,40 @@
         return this.worldObj.getCollidingBoundingBoxes(this, p_174809_1_).isEmpty() && !this.worldObj.isAnyLiquid(p_174809_1_);
     }
 
     public void moveEntity(double x, double y, double z)
     {
+        org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.startTiming(); // Spigot
+
         if (this.noClip)
         {
             this.setEntityBoundingBox(this.getEntityBoundingBox().offset(x, y, z));
             this.resetPositionToBB();
         }
         else
         {
+            // CraftBukkit start - Don't do anything if we aren't moving
+            // We need to do this regardless of whether or not we are moving thanks to portals
+            try
+            {
+                this.doBlockCollisions();
+            }
+            catch (Throwable throwable)
+            {
+                CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Checking entity block collision");
+                CrashReportCategory crashreportsystemdetails = crashreport.makeCategory("Entity being checked for collision");
+                this.addEntityCrashInfo(crashreportsystemdetails);
+                throw new ReportedException(crashreport);
+            }
+
+            // Check if we're moving
+            if (x == 0 && y == 0 && z == 0 && this.ridingEntity == null && this.riddenByEntity == null)
+            {
+                return;
+            }
+
+            // CraftBukkit end
             this.worldObj.theProfiler.startSection("move");
             double d3 = this.posX;
             double d4 = this.posY;
             double d5 = this.posZ;
 
@@ -695,10 +806,39 @@
             if (d7 != y)
             {
                 block1.onLanded(this.worldObj, this);
             }
 
+            // CraftBukkit start
+            if (isCollidedHorizontally && getBukkitEntity() instanceof Vehicle)
+            {
+                Vehicle vehicle = (Vehicle)this.getBukkitEntity();
+                org.bukkit.block.Block bl = this.worldObj.getWorld().getBlockAt(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY), MathHelper.floor_double(this.posZ));
+
+                if (d6 > x)
+                {
+                    bl = bl.getRelative(BlockFace.EAST);
+                }
+                else if (d6 < x)
+                {
+                    bl = bl.getRelative(BlockFace.WEST);
+                }
+                else if (d8 > z)
+                {
+                    bl = bl.getRelative(BlockFace.SOUTH);
+                }
+                else if (d8 < z)
+                {
+                    bl = bl.getRelative(BlockFace.NORTH);
+                }
+
+                VehicleBlockCollisionEvent event = new VehicleBlockCollisionEvent(vehicle, bl);
+                worldObj.getServer().getPluginManager().callEvent(event);
+            }
+
+            // CraftBukkit end
+
             if (this.canTriggerWalking() && !flag && this.ridingEntity == null)
             {
                 double d15 = this.posX - d3;
                 double d16 = this.posY - d4;
                 double d17 = this.posZ - d5;
@@ -708,11 +848,11 @@
                     d16 = 0.0D;
                 }
 
                 if (block1 != null && this.onGround)
                 {
-                    block1.onEntityCollidedWithBlock(this.worldObj, blockpos, this);
+                    // block1.onEntityCollidedWithBlock(this.worldObj, blockpos, this); // CraftBukkit removed down
                 }
 
                 this.distanceWalkedModified = (float)((double)this.distanceWalkedModified + (double)MathHelper.sqrt_double(d15 * d15 + d17 * d17) * 0.6D);
                 this.distanceWalkedOnStepModified = (float)((double)this.distanceWalkedOnStepModified + (double)MathHelper.sqrt_double(d15 * d15 + d16 * d16 + d17 * d17) * 0.6D);
 
@@ -731,13 +871,16 @@
 
                         this.playSound(this.getSwimSound(), f, 1.0F + (this.rand.nextFloat() - this.rand.nextFloat()) * 0.4F);
                     }
 
                     this.playStepSound(blockpos, block1);
+                    block1.onEntityCollidedWithBlock(this.worldObj, blockpos, this); // CraftBukkit - moved from above
                 }
             }
 
+            // CraftBukkit start - Move to the top of the method
+            /*
             try
             {
                 this.doBlockCollisions();
             }
             catch (Throwable throwable)
@@ -745,23 +888,36 @@
                 CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Checking entity block collision");
                 CrashReportCategory crashreportcategory = crashreport.makeCategory("Entity being checked for collision");
                 this.addEntityCrashInfo(crashreportcategory);
                 throw new ReportedException(crashreport);
             }
-
+            */
+            // CraftBukkit end
             boolean flag2 = this.isWet();
 
             if (this.worldObj.func_147470_e(this.getEntityBoundingBox().contract(0.001D, 0.001D, 0.001D)))
             {
                 this.dealFireDamage(1);
 
                 if (!flag2)
                 {
                     ++this.fire;
 
-                    if (this.fire == 0)
+                    // CraftBukkit start - Not on fire yet
+                    if (this.fire <= 0)  // Only throw events on the first combust, otherwise it spams
                     {
+                        EntityCombustEvent event = new EntityCombustEvent(getBukkitEntity(), 8);
+                        worldObj.getServer().getPluginManager().callEvent(event);
+
+                        if (!event.isCancelled())
+                        {
+                            setFire(event.getDuration());
+                        }
+                    }
+                    else
+                    {
+                        // CraftBukkit end
                         this.setFire(8);
                     }
                 }
             }
             else if (this.fire <= 0)
@@ -775,10 +931,12 @@
                 this.fire = -this.fireResistance;
             }
 
             this.worldObj.theProfiler.endSection();
         }
+
+        org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.stopTiming(); // Spigot
     }
 
     private void resetPositionToBB()
     {
         this.posX = (this.getEntityBoundingBox().minX + this.getEntityBoundingBox().maxX) / 2.0D;
@@ -889,11 +1047,11 @@
     public AxisAlignedBB getBoundingBox()
     {
         return null;
     }
 
-    protected void dealFireDamage(int amount)
+    protected void dealFireDamage(float amount) // CraftBukkit - int -> float
     {
         if (!this.isImmuneToFire)
         {
             this.attackEntityFrom(DamageSource.inFire, (float)amount);
         }
@@ -1047,27 +1205,10 @@
             this.motionX += (double)(strafe * f5 - forward * f4);
             this.motionZ += (double)(forward * f5 + strafe * f4);
         }
     }
 
-    @SideOnly(Side.CLIENT)
-    public int getBrightnessForRender(float p_70070_1_)
-    {
-        BlockPos blockpos = new BlockPos(this.posX, 0.0D, this.posZ);
-
-        if (this.worldObj.isBlockLoaded(blockpos))
-        {
-            double d0 = (this.getEntityBoundingBox().maxY - this.getEntityBoundingBox().minY) * 0.66D;
-            int i = MathHelper.floor_double(this.posY + d0);
-            return this.worldObj.getCombinedLight(blockpos.up(i), 0);
-        }
-        else
-        {
-            return 0;
-        }
-    }
-
     public float getBrightness(float p_70013_1_)
     {
         BlockPos blockpos = new BlockPos(this.posX, 0.0D, this.posZ);
 
         if (this.worldObj.isBlockLoaded(blockpos))
@@ -1082,10 +1223,19 @@
         }
     }
 
     public void setWorld(World worldIn)
     {
+        // CraftBukkit start
+        if (worldIn == null)
+        {
+            setDead();
+            this.worldObj = ((CraftWorld)Bukkit.getServer().getWorlds().get(0)).getHandle();
+            return;
+        }
+
+        // CraftBukkit end
         this.worldObj = worldIn;
     }
 
     public void setPositionAndRotation(double x, double y, double z, float yaw, float pitch)
     {
@@ -1165,12 +1315,16 @@
         double d1 = this.posY - entityIn.posY;
         double d2 = this.posZ - entityIn.posZ;
         return d0 * d0 + d1 * d1 + d2 * d2;
     }
 
-    public void onCollideWithPlayer(EntityPlayer entityIn) {}
+    public void onCollideWithPlayer(EntityPlayer entityIn)
+    {
+    }
 
+    int numCollisions = 0; // Spigot
+
     public void applyEntityCollision(Entity entityIn)
     {
         if (entityIn.riddenByEntity != this && entityIn.ridingEntity != this)
         {
             if (!entityIn.noClip && !this.noClip)
@@ -1259,65 +1413,24 @@
         float f4 = -MathHelper.cos(-pitch * 0.017453292F);
         float f5 = MathHelper.sin(-pitch * 0.017453292F);
         return new Vec3((double)(f3 * f4), (double)f5, (double)(f2 * f4));
     }
 
-    @SideOnly(Side.CLIENT)
-    public Vec3 getPositionEyes(float p_174824_1_)
-    {
-        if (p_174824_1_ == 1.0F)
-        {
-            return new Vec3(this.posX, this.posY + (double)this.getEyeHeight(), this.posZ);
-        }
-        else
-        {
-            double d0 = this.prevPosX + (this.posX - this.prevPosX) * (double)p_174824_1_;
-            double d1 = this.prevPosY + (this.posY - this.prevPosY) * (double)p_174824_1_ + (double)this.getEyeHeight();
-            double d2 = this.prevPosZ + (this.posZ - this.prevPosZ) * (double)p_174824_1_;
-            return new Vec3(d0, d1, d2);
-        }
-    }
-
-    @SideOnly(Side.CLIENT)
-    public MovingObjectPosition rayTrace(double p_174822_1_, float p_174822_3_)
-    {
-        Vec3 vec3 = this.getPositionEyes(p_174822_3_);
-        Vec3 vec31 = this.getLook(p_174822_3_);
-        Vec3 vec32 = vec3.addVector(vec31.xCoord * p_174822_1_, vec31.yCoord * p_174822_1_, vec31.zCoord * p_174822_1_);
-        return this.worldObj.rayTraceBlocks(vec3, vec32, false, false, true);
-    }
-
     public boolean canBeCollidedWith()
     {
         return false;
     }
 
     public boolean canBePushed()
     {
         return false;
     }
 
-    public void addToPlayerScore(Entity entityIn, int amount) {}
-
-    @SideOnly(Side.CLIENT)
-    public boolean isInRangeToRender3d(double x, double y, double z)
+    public void addToPlayerScore(Entity entityIn, int amount)
     {
-        double d3 = this.posX - x;
-        double d4 = this.posY - y;
-        double d5 = this.posZ - z;
-        double d6 = d3 * d3 + d4 * d4 + d5 * d5;
-        return this.isInRangeToRenderDist(d6);
     }
 
-    @SideOnly(Side.CLIENT)
-    public boolean isInRangeToRenderDist(double distance)
-    {
-        double d1 = this.getEntityBoundingBox().getAverageEdgeLength();
-        d1 *= 64.0D * this.renderDistanceWeight;
-        return distance < d1 * d1;
-    }
-
     public boolean writeMountToNBT(NBTTagCompound tagCompund)
     {
         String s = this.getEntityString();
 
         if (!this.isDead && s != null)
@@ -1352,21 +1465,41 @@
     {
         try
         {
             tagCompund.setTag("Pos", this.newDoubleNBTList(new double[] {this.posX, this.posY, this.posZ}));
             tagCompund.setTag("Motion", this.newDoubleNBTList(new double[] {this.motionX, this.motionY, this.motionZ}));
+
+            // CraftBukkit start - Checking for NaN pitch/yaw and resetting to zero
+            // TODO: make sure this is the best way to address this.
+            if (Float.isNaN(this.rotationYaw))
+            {
+                this.rotationYaw = 0;
+            }
+
+            if (Float.isNaN(this.rotationPitch))
+            {
+                this.rotationPitch = 0;
+            }
+
+            // CraftBukkit end
             tagCompund.setTag("Rotation", this.newFloatNBTList(new float[] {this.rotationYaw, this.rotationPitch}));
             tagCompund.setFloat("FallDistance", this.fallDistance);
             tagCompund.setShort("Fire", (short)this.fire);
             tagCompund.setShort("Air", (short)this.getAir());
             tagCompund.setBoolean("OnGround", this.onGround);
             tagCompund.setInteger("Dimension", this.dimension);
             tagCompund.setBoolean("Invulnerable", this.invulnerable);
             tagCompund.setInteger("PortalCooldown", this.timeUntilPortal);
             tagCompund.setLong("UUIDMost", this.getUniqueID().getMostSignificantBits());
             tagCompund.setLong("UUIDLeast", this.getUniqueID().getLeastSignificantBits());
+            // CraftBukkit start
+            tagCompund.setLong("WorldUUIDLeast", this.worldObj.getSaveHandler().getUUID().getLeastSignificantBits());
+            tagCompund.setLong("WorldUUIDMost", this.worldObj.getSaveHandler().getUUID().getMostSignificantBits());
+            tagCompund.setInteger("Bukkit.updateLevel", CURRENT_LEVEL);
+            tagCompund.setInteger("Spigot.ticksLived", this.ticksExisted);
 
+            // CraftBukkit end
             if (this.getCustomNameTag() != null && this.getCustomNameTag().length() > 0)
             {
                 tagCompund.setString("CustomName", this.getCustomNameTag());
                 tagCompund.setBoolean("CustomNameVisible", this.getAlwaysRenderNameTag());
             }
@@ -1407,11 +1540,11 @@
             NBTTagList nbttaglist1 = tagCompund.getTagList("Motion", 6);
             NBTTagList nbttaglist2 = tagCompund.getTagList("Rotation", 5);
             this.motionX = nbttaglist1.getDouble(0);
             this.motionY = nbttaglist1.getDouble(1);
             this.motionZ = nbttaglist1.getDouble(2);
-
+            /* CraftBukkit start - Moved section down
             if (Math.abs(this.motionX) > 10.0D)
             {
                 this.motionX = 0.0D;
             }
 
@@ -1422,11 +1555,11 @@
 
             if (Math.abs(this.motionZ) > 10.0D)
             {
                 this.motionZ = 0.0D;
             }
-
+            // CraftBukkit end */
             this.prevPosX = this.lastTickPosX = this.posX = nbttaglist.getDouble(0);
             this.prevPosY = this.lastTickPosY = this.posY = nbttaglist.getDouble(1);
             this.prevPosZ = this.lastTickPosZ = this.posZ = nbttaglist.getDouble(2);
             this.prevRotationYaw = this.rotationYaw = nbttaglist2.getFloat(0);
             this.prevRotationPitch = this.rotationPitch = nbttaglist2.getFloat(1);
@@ -1462,10 +1595,76 @@
 
             if (this.shouldSetPosAfterLoading())
             {
                 this.setPosition(this.posX, this.posY, this.posZ);
             }
+
+            // CraftBukkit start
+            if (this instanceof EntityLiving)
+            {
+                EntityLiving entity = (EntityLiving)this;
+                this.ticksExisted = tagCompund.getInteger("Spigot.ticksLived");
+
+                // Reset the persistence for tamed animals
+                if (entity instanceof EntityTameable && !isLevelAtLeast(tagCompund, 2) && !tagCompund.getBoolean("PersistenceRequired"))
+                {
+                    EntityLiving entityinsentient = (EntityLiving)entity;
+                    entityinsentient.persistenceRequired = !entityinsentient.canDespawn();
+                }
+            }
+
+            // CraftBukkit end
+
+            // CraftBukkit start - Exempt Vehicles from notch's sanity check
+            if (!(getBukkitEntity() instanceof Vehicle))
+            {
+                if (Math.abs(this.motionX) > 10.0D)
+                {
+                    this.motionX = 0.0D;
+                }
+
+                if (Math.abs(this.motionY) > 10.0D)
+                {
+                    this.motionY = 0.0D;
+                }
+
+                if (Math.abs(this.motionZ) > 10.0D)
+                {
+                    this.motionZ = 0.0D;
+                }
+            }
+
+            // CraftBukkit end
+
+            // CraftBukkit start - Reset world
+            if (this instanceof EntityPlayer)
+            {
+                Server server = Bukkit.getServer();
+                org.bukkit.World bworld = null;
+                // TODO: Remove World related checks, replaced with WorldUID
+                String worldName = tagCompund.getString("world");
+
+                if (tagCompund.hasKey("WorldUUIDMost") && tagCompund.hasKey("WorldUUIDLeast"))
+                {
+                    UUID uid = new UUID(tagCompund.getLong("WorldUUIDMost"), tagCompund.getLong("WorldUUIDLeast"));
+                    bworld = server.getWorld(uid);
+                }
+                else
+                {
+                    bworld = server.getWorld(worldName);
+                }
+
+                if (bworld == null)
+                {
+                    EntityPlayer entityPlayer = (EntityPlayer)this;
+                    bworld = ((org.bukkit.craftbukkit.CraftServer)server).getServer().worldServerForDimension(entityPlayer.dimension).getWorld();
+                }
+
+                setWorld(bworld == null ? null : ((CraftWorld)bworld).getHandle());
+            }
+
+            // CraftBukkit end
         }
         catch (Throwable throwable)
         {
             CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Loading entity NBT");
             CrashReportCategory crashreportcategory = crashreport.makeCategory("Entity being loaded");
@@ -1486,13 +1685,15 @@
 
     protected abstract void readEntityFromNBT(NBTTagCompound tagCompund);
 
     protected abstract void writeEntityToNBT(NBTTagCompound tagCompound);
 
-    public void onChunkLoad() {}
+    public void onChunkLoad()
+    {
+    }
 
-    protected NBTTagList newDoubleNBTList(double ... numbers)
+    protected NBTTagList newDoubleNBTList(double... numbers)
     {
         NBTTagList nbttaglist = new NBTTagList();
         double[] adouble = numbers;
         int i = numbers.length;
 
@@ -1503,11 +1704,11 @@
         }
 
         return nbttaglist;
     }
 
-    protected NBTTagList newFloatNBTList(float ... numbers)
+    protected NBTTagList newFloatNBTList(float... numbers)
     {
         NBTTagList nbttaglist = new NBTTagList();
         float[] afloat = numbers;
         int i = numbers.length;
 
@@ -1532,10 +1733,18 @@
 
     public EntityItem entityDropItem(ItemStack itemStackIn, float offsetY)
     {
         if (itemStackIn.stackSize != 0 && itemStackIn.getItem() != null)
         {
+            // CraftBukkit start - Capture drops for death event
+            if (this instanceof EntityLiving && ((EntityLiving)this).drops != null)
+            {
+                ((EntityLiving)this).drops.add(org.bukkit.craftbukkit.inventory.CraftItemStack.asBukkitCopy(itemStackIn));
+                return null;
+            }
+
+            // CraftBukkit end
             EntityItem entityitem = new EntityItem(this.worldObj, this.posX, this.posY + (double)offsetY, this.posZ, itemStackIn);
             entityitem.setDefaultPickupDelay();
             this.worldObj.spawnEntityInWorld(entityitem);
             return entityitem;
         }
@@ -1668,27 +1877,108 @@
     public double getMountedYOffset()
     {
         return (double)this.height * 0.75D;
     }
 
+    // CraftBukkit start
+    protected CraftEntity bukkitEntity;
+
+    public org.bukkit.craftbukkit.entity.CraftEntity getBukkitEntity()
+    {
+        if (bukkitEntity == null)
+        {
+            bukkitEntity = CraftEntity.getEntity(worldObj.getServer(), this);
+        }
+
+        return bukkitEntity;
+    }
+
     public void mountEntity(Entity entityIn)
     {
+        Entity originalVehicle = this.ridingEntity;
+        Entity originalPassenger = this.ridingEntity == null ? null : this.ridingEntity.riddenByEntity;
+        PluginManager pluginManager = Bukkit.getPluginManager();
+        getBukkitEntity(); // make sure bukkitEntity is initialised
+        // CraftBukkit end
         this.entityRiderPitchDelta = 0.0D;
         this.entityRiderYawDelta = 0.0D;
 
         if (entityIn == null)
         {
             if (this.ridingEntity != null)
             {
+                // CraftBukkit start
+                if ((this.bukkitEntity instanceof LivingEntity) && (this.ridingEntity.getBukkitEntity() instanceof Vehicle))
+                {
+                    VehicleExitEvent event = new VehicleExitEvent((Vehicle)this.ridingEntity.getBukkitEntity(), (LivingEntity)this.bukkitEntity);
+                    pluginManager.callEvent(event);
+
+                    if (event.isCancelled() || ridingEntity != originalVehicle)
+                    {
+                        return;
+                    }
+                }
+
+                // CraftBukkit end
+                pluginManager.callEvent(new EntityDismountEvent(this.getBukkitEntity(), this.ridingEntity.getBukkitEntity())); // Spigot
                 this.setLocationAndAngles(this.ridingEntity.posX, this.ridingEntity.getEntityBoundingBox().minY + (double)this.ridingEntity.height, this.ridingEntity.posZ, this.rotationYaw, this.rotationPitch);
                 this.ridingEntity.riddenByEntity = null;
             }
 
             this.ridingEntity = null;
         }
         else
         {
+            // CraftBukkit start
+            if ((this.bukkitEntity instanceof LivingEntity) && (entityIn.getBukkitEntity() instanceof Vehicle) && entityIn.worldObj.isChunkLoaded((int)entityIn.posX >> 4, (int)entityIn.posZ >> 4, true))
+            {
+                // It's possible to move from one vehicle to another.  We need to check if they're already in a vehicle, and fire an exit event if they are.
+                VehicleExitEvent exitEvent = null;
+
+                if (this.ridingEntity != null && this.ridingEntity.getBukkitEntity() instanceof Vehicle)
+                {
+                    exitEvent = new VehicleExitEvent((Vehicle)this.ridingEntity.getBukkitEntity(), (LivingEntity)this.bukkitEntity);
+                    pluginManager.callEvent(exitEvent);
+
+                    if (exitEvent.isCancelled() || this.ridingEntity != originalVehicle || (this.ridingEntity != null && this.ridingEntity.riddenByEntity != originalPassenger))
+                    {
+                        return;
+                    }
+                }
+
+                VehicleEnterEvent event = new VehicleEnterEvent((Vehicle)entityIn.getBukkitEntity(), this.bukkitEntity);
+                pluginManager.callEvent(event);
+
+                // If a plugin messes with the vehicle or the vehicle's passenger
+                if (event.isCancelled() || this.ridingEntity != originalVehicle || (this.ridingEntity != null && this.ridingEntity.riddenByEntity != originalPassenger))
+                {
+                    // If we only cancelled the enterevent then we need to put the player in a decent position.
+                    if (exitEvent != null && this.ridingEntity == originalVehicle && this.ridingEntity != null && this.ridingEntity.riddenByEntity == originalPassenger)
+                    {
+                        this.setLocationAndAngles(this.ridingEntity.posX, this.ridingEntity.getEntityBoundingBox().minY + (double)this.ridingEntity.height, this.ridingEntity.posZ, this.rotationYaw, this.rotationPitch);
+                        this.ridingEntity.riddenByEntity = null;
+                        this.ridingEntity = null;
+                    }
+
+                    return;
+                }
+            }
+
+            // CraftBukkit end
+            // Spigot Start
+            if (entityIn.worldObj.isChunkLoaded((int)entityIn.posX >> 4, (int)entityIn.posZ >> 4, true))
+            {
+                org.spigotmc.event.entity.EntityMountEvent event = new EntityMountEvent(this.getBukkitEntity(), entityIn.getBukkitEntity());
+                pluginManager.callEvent(event);
+
+                if (event.isCancelled())
+                {
+                    return;
+                }
+            }
+
+            // Spigot End
             if (this.ridingEntity != null)
             {
                 this.ridingEntity.riddenByEntity = null;
             }
 
@@ -1706,37 +1996,10 @@
             this.ridingEntity = entityIn;
             entityIn.riddenByEntity = this;
         }
     }
 
-    @SideOnly(Side.CLIENT)
-    public void func_180426_a(double p_180426_1_, double p_180426_3_, double p_180426_5_, float p_180426_7_, float p_180426_8_, int p_180426_9_, boolean p_180426_10_)
-    {
-        this.setPosition(p_180426_1_, p_180426_3_, p_180426_5_);
-        this.setRotation(p_180426_7_, p_180426_8_);
-        List list = this.worldObj.getCollidingBoundingBoxes(this, this.getEntityBoundingBox().contract(0.03125D, 0.0D, 0.03125D));
-
-        if (!list.isEmpty())
-        {
-            double d3 = 0.0D;
-            Iterator iterator = list.iterator();
-
-            while (iterator.hasNext())
-            {
-                AxisAlignedBB axisalignedbb = (AxisAlignedBB)iterator.next();
-
-                if (axisalignedbb.maxY > d3)
-                {
-                    d3 = axisalignedbb.maxY;
-                }
-            }
-
-            p_180426_3_ += d3 - this.getEntityBoundingBox().minY;
-            this.setPosition(p_180426_1_, p_180426_3_, p_180426_5_);
-        }
-    }
-
     public float getCollisionBorderSize()
     {
         return 0.1F;
     }
 
@@ -1779,31 +2042,19 @@
     public int getPortalCooldown()
     {
         return 300;
     }
 
-    @SideOnly(Side.CLIENT)
-    public void setVelocity(double x, double y, double z)
+    public ItemStack[] getInventory()
     {
-        this.motionX = x;
-        this.motionY = y;
-        this.motionZ = z;
+        return null;
     }
 
-    @SideOnly(Side.CLIENT)
-    public void handleHealthUpdate(byte p_70103_1_) {}
-
-    @SideOnly(Side.CLIENT)
-    public void performHurtAnimation() {}
-
-    public ItemStack[] getInventory()
+    public void setCurrentItemOrArmor(int slotIn, ItemStack stack)
     {
-        return null;
     }
 
-    public void setCurrentItemOrArmor(int slotIn, ItemStack stack) {}
-
     public boolean isBurning()
     {
         boolean flag = this.worldObj != null && this.worldObj.isRemote;
         return !this.isImmuneToFire && (this.fire > 0 || flag && this.getFlag(0));
     }
@@ -1836,27 +2087,15 @@
     public boolean isInvisible()
     {
         return this.getFlag(5);
     }
 
-    @SideOnly(Side.CLIENT)
-    public boolean isInvisibleToPlayer(EntityPlayer player)
-    {
-        return player.isSpectator() ? false : this.isInvisible();
-    }
-
     public void setInvisible(boolean invisible)
     {
         this.setFlag(5, invisible);
     }
 
-    @SideOnly(Side.CLIENT)
-    public boolean isEating()
-    {
-        return this.getFlag(4);
-    }
-
     public void setEating(boolean eating)
     {
         this.setFlag(4, eating);
     }
 
@@ -1889,20 +2128,74 @@
         this.dataWatcher.updateObject(1, Short.valueOf((short)air));
     }
 
     public void onStruckByLightning(EntityLightningBolt lightningBolt)
     {
-        this.attackEntityFrom(DamageSource.lightningBolt, 5.0F);
+        // CraftBukkit start
+        final org.bukkit.entity.Entity thisBukkitEntity = this.getBukkitEntity();
+        final org.bukkit.entity.Entity stormBukkitEntity = lightningBolt.getBukkitEntity();
+        final PluginManager pluginManager = Bukkit.getPluginManager();
+
+        if (thisBukkitEntity instanceof Hanging)
+        {
+            HangingBreakByEntityEvent hangingEvent = new HangingBreakByEntityEvent((Hanging)thisBukkitEntity, stormBukkitEntity);
+            PaintingBreakByEntityEvent paintingEvent = null;
+
+            if (thisBukkitEntity instanceof Painting)
+            {
+                paintingEvent = new PaintingBreakByEntityEvent((Painting)thisBukkitEntity, stormBukkitEntity);
+            }
+
+            pluginManager.callEvent(hangingEvent);
+
+            if (paintingEvent != null)
+            {
+                paintingEvent.setCancelled(hangingEvent.isCancelled());
+                pluginManager.callEvent(paintingEvent);
+            }
+
+            if (hangingEvent.isCancelled() || (paintingEvent != null && paintingEvent.isCancelled()))
+            {
+                return;
+            }
+        }
+
+        if (this.isImmuneToFire)
+        {
+            return;
+        }
+
+        CraftEventFactory.entityDamage = lightningBolt;
+
+        if (!this.attackEntityFrom(DamageSource.lightningBolt, 5.0F))
+        {
+            CraftEventFactory.entityDamage = null;
+            return;
+        }
+
+        // CraftBukkit end
         ++this.fire;
 
         if (this.fire == 0)
         {
             this.setFire(8);
+            // CraftBukkit start - Call a combust event when lightning strikes
+            EntityCombustByEntityEvent entityCombustEvent = new EntityCombustByEntityEvent(stormBukkitEntity, thisBukkitEntity, 8);
+            pluginManager.callEvent(entityCombustEvent);
+
+            if (!entityCombustEvent.isCancelled())
+            {
+                this.setFire(entityCombustEvent.getDuration());
+            }
+
+            // CraftBukkit end
         }
     }
 
-    public void onKillEntity(EntityLivingBase entityLivingIn) {}
+    public void onKillEntity(EntityLivingBase entityLivingIn)
+    {
+    }
 
     protected boolean pushOutOfBlocks(double x, double y, double z)
     {
         BlockPos blockpos = new BlockPos(x, y, z);
         double d3 = x - (double)blockpos.getX();
@@ -2018,11 +2311,13 @@
     public float getRotationYawHead()
     {
         return 0.0F;
     }
 
-    public void setRotationYawHead(float rotation) {}
+    public void setRotationYawHead(float rotation)
+    {
+    }
 
     public boolean canAttackWithItem()
     {
         return true;
     }
@@ -2060,39 +2355,92 @@
     {
         if (!this.worldObj.isRemote && !this.isDead)
         {
             this.worldObj.theProfiler.startSection("changeDimension");
             MinecraftServer minecraftserver = MinecraftServer.getServer();
-            int j = this.dimension;
-            WorldServer worldserver = minecraftserver.worldServerForDimension(j);
-            WorldServer worldserver1 = minecraftserver.worldServerForDimension(dimensionId);
-            this.dimension = dimensionId;
+            // CraftBukkit start - Move logic into new function "teleportToLocation"
 
+            if (this.dimension < CraftWorld.CUSTOM_DIMENSION_OFFSET)   // Plugins must specify exit from custom Bukkit worlds
+            {
+                // Only target existing worlds (compensate for allow-nether/allow-end as false)
+                for (WorldServer world : minecraftserver.worlds)
+                {
+                    if (world.dimension == dimensionId)
+                    {
+                        exitWorld = world;
+                    }
+                }
+            }
+
+            Location enter = this.getBukkitEntity().getLocation();
+            Location exit = exitWorld != null ? minecraftserver.getConfigurationManager().calculateTarget(enter, minecraftserver.worldServerForDimension(dimensionId)) : null;
+            boolean useTravelAgent = exitWorld != null && !(this.dimension == 1 && exitWorld.dimension == 1); // don't use agent for custom worlds or return from THE_END
+            TravelAgent agent = exit != null ? (TravelAgent)((CraftWorld)exit.getWorld()).getHandle().getDefaultTeleporter() : org.bukkit.craftbukkit.CraftTravelAgent.DEFAULT;  // return arbitrary TA to compensate for implementation dependent plugins
+            EntityPortalEvent event = new EntityPortalEvent(this.getBukkitEntity(), enter, exit, agent);
+            event.useTravelAgent(useTravelAgent);
+            event.getEntity().getServer().getPluginManager().callEvent(event);
+
+            if (event.isCancelled() || event.getTo() == null || event.getTo().getWorld() == null || !this.isEntityAlive())
+            {
+                return;
+            }
+
+            exit = event.useTravelAgent() ? event.getPortalTravelAgent().findOrCreate(event.getTo()) : event.getTo();
+            this.teleportTo(exit, true);
+        }
+    }
+
+    public void teleportTo(Location exit, boolean portal)
+    {
+        if (true)
+        {
+            WorldServer worldserver = ((CraftWorld)getBukkitEntity().getLocation().getWorld()).getHandle();
+            WorldServer worldserver1 = ((CraftWorld)exit.getWorld()).getHandle();
+            int dimensionId = worldserver1.dimension; // SpigotMCP -- use mcp name
+            // CraftBukkit end
+            this.dimension = dimensionId;
+            /* CraftBukkit start - TODO: Check if we need this
             if (j == 1 && dimensionId == 1)
             {
                 worldserver1 = minecraftserver.worldServerForDimension(0);
                 this.dimension = 0;
             }
-
+            // CraftBukkit end */
             this.worldObj.removeEntity(this);
             this.isDead = false;
             this.worldObj.theProfiler.startSection("reposition");
-            minecraftserver.getConfigurationManager().transferEntityToWorld(this, j, worldserver, worldserver1);
+            // CraftBukkit start - Ensure chunks are loaded in case TravelAgent is not used which would initially cause chunks to load during find/create
+            // minecraftserver.getConfigurationManager().transferEntityToWorld(this, j, worldserver, worldserver1);
+            boolean before = worldserver1.theChunkProviderServer.chunkLoadOverride;
+            worldserver1.theChunkProviderServer.chunkLoadOverride = true;
+            worldserver1.getMinecraftServer().getConfigurationManager().repositionEntity(this, exit, portal);
+            worldserver1.theChunkProviderServer.chunkLoadOverride = before;
+            // CraftBukkit end
             this.worldObj.theProfiler.endStartSection("reloading");
             Entity entity = EntityList.createEntityByName(EntityList.getEntityString(this), worldserver1);
 
             if (entity != null)
             {
                 entity.copyDataFromOld(this);
-
+                /* CraftBukkit start - We need to do this...
                 if (j == 1 && dimensionId == 1)
                 {
                     BlockPos blockpos = this.worldObj.getTopSolidOrLiquidBlock(worldserver1.getSpawnPoint());
                     entity.moveToBlockPosAndAngles(blockpos, entity.rotationYaw, entity.rotationPitch);
                 }
-
+                // CraftBukkit end */
                 worldserver1.spawnEntityInWorld(entity);
+                // CraftBukkit start - Forward the CraftEntity to the new entity
+                this.getBukkitEntity().setHandle(entity);
+                entity.bukkitEntity = this.getBukkitEntity();
+
+                if (this instanceof EntityLiving)
+                {
+                    ((EntityLiving)this).clearLeashed(true, false); // Unleash to prevent duping of leads.
+                }
+
+                // CraftBukkit end
             }
 
             this.isDead = true;
             this.worldObj.theProfiler.endSection();
             worldserver.resetUpdateEntityTick();
@@ -2164,16 +2512,10 @@
                 return Entity.this.ridingEntity.toString();
             }
         });
     }
 
-    @SideOnly(Side.CLIENT)
-    public boolean canRenderOnFire()
-    {
-        return this.isBurning();
-    }
-
     public UUID getUniqueID()
     {
         return this.entityUniqueID;
     }
 
@@ -2218,18 +2560,14 @@
     public void setPositionAndUpdate(double x, double y, double z)
     {
         this.setLocationAndAngles(x, y, z, this.rotationYaw, this.rotationPitch);
     }
 
-    @SideOnly(Side.CLIENT)
-    public boolean getAlwaysRenderNameTagForRender()
+    public void func_145781_i(int p_145781_1_)
     {
-        return this.getAlwaysRenderNameTag();
     }
 
-    public void func_145781_i(int p_145781_1_) {}
-
     public EnumFacing getHorizontalFacing()
     {
         return EnumFacing.getHorizontal(MathHelper.floor_double((double)(this.rotationYaw * 4.0F / 360.0F) + 0.5D) & 3);
     }
 
@@ -2256,13 +2594,39 @@
     public AxisAlignedBB getEntityBoundingBox()
     {
         return this.boundingBox;
     }
 
-    public void setEntityBoundingBox(AxisAlignedBB p_174826_1_)
+    public void setEntityBoundingBox(AxisAlignedBB axisalignedbb)   // SpigotMCP -- use craftbukkit name
     {
-        this.boundingBox = p_174826_1_;
+        // CraftBukkit start - block invalid bounding boxes
+        double a = axisalignedbb.minX,
+                   b = axisalignedbb.minY,
+                       c = axisalignedbb.minZ,
+                           d = axisalignedbb.maxX,
+                               e = axisalignedbb.maxY,
+                                   f = axisalignedbb.maxZ;
+        double len = axisalignedbb.maxX - axisalignedbb.minX;
+
+        if (len < 0) d = a;
+
+        if (len > 64) d = a + 64.0;
+
+        len = axisalignedbb.maxY - axisalignedbb.minY;
+
+        if (len < 0) e = b;
+
+        if (len > 64) e = b + 64.0;
+
+        len = axisalignedbb.maxZ - axisalignedbb.minZ;
+
+        if (len < 0) f = c;
+
+        if (len > 64) f = c + 64.0;
+
+        this.boundingBox = new AxisAlignedBB(a, b, c, d, e, f);
+        // CraftBukkit end
     }
 
     public float getEyeHeight()
     {
         return this.height * 0.85F;
@@ -2281,11 +2645,13 @@
     public boolean replaceItemInInventory(int p_174820_1_, ItemStack p_174820_2_)
     {
         return false;
     }
 
-    public void addChatMessage(IChatComponent message) {}
+    public void addChatMessage(IChatComponent message)
+    {
+    }
 
     public boolean canUseCommand(int permLevel, String commandName)
     {
         return true;
     }
@@ -2333,13 +2699,10 @@
     public NBTTagCompound func_174819_aU()
     {
         return null;
     }
 
-    @SideOnly(Side.CLIENT)
-    public void func_174834_g(NBTTagCompound p_174834_1_) {}
-
     public boolean func_174825_a(EntityPlayer p_174825_1_, Vec3 p_174825_2_)
     {
         return false;
     }
 
